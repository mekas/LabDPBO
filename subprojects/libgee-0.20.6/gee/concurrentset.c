/* concurrentset.c generated by valac 0.56.3, the Vala compiler
 * generated from concurrentset.vala, do not modify */

/* concurrentset.vala
 *
 * Copyright (C) 2012-2014  Maciej Piechotka
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Maciej Piechotka <uzytkownik2@gmail.com>
 */

#include "gee.h"
#include <glib.h>
#include <glib-object.h>
#include <misc.h>
#include <string.h>
#include <gobject/gvaluecollector.h>

#define GEE_CONCURRENT_SET__MAX_HEIGHT 31

#define GEE_CONCURRENT_SET_TYPE_TOWER (gee_concurrent_set_tower_get_type ())
#define GEE_CONCURRENT_SET_TOWER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTower))
#define GEE_CONCURRENT_SET_TOWER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTowerClass))
#define GEE_CONCURRENT_SET_IS_TOWER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_TOWER))
#define GEE_CONCURRENT_SET_IS_TOWER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_TOWER))
#define GEE_CONCURRENT_SET_TOWER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTowerClass))

typedef struct _GeeConcurrentSetTower GeeConcurrentSetTower;
typedef struct _GeeConcurrentSetTowerClass GeeConcurrentSetTowerClass;
enum  {
	GEE_CONCURRENT_SET_0_PROPERTY,
	GEE_CONCURRENT_SET_G_TYPE,
	GEE_CONCURRENT_SET_G_DUP_FUNC,
	GEE_CONCURRENT_SET_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SIZE_PROPERTY,
	GEE_CONCURRENT_SET_READ_ONLY_PROPERTY,
	GEE_CONCURRENT_SET_NUM_PROPERTIES
};
static GParamSpec* gee_concurrent_set_properties[GEE_CONCURRENT_SET_NUM_PROPERTIES];
#define _gee_concurrent_set_tower_unref0(var) ((var == NULL) ? NULL : (var = (gee_concurrent_set_tower_unref (var), NULL)))
#define _gee_hazard_pointer_context_free0(var) ((var == NULL) ? NULL : (var = (gee_hazard_pointer_context_free (var), NULL)))
typedef enum  {
	GEE_CONCURRENT_SET_STATE_NONE = 0,
	GEE_CONCURRENT_SET_STATE_MARKED = 1,
	GEE_CONCURRENT_SET_STATE_FLAGGED = 2
} GeeConcurrentSetState;

#define GEE_CONCURRENT_SET_TYPE_STATE (gee_concurrent_set_state_get_type ())
#define _g_rand_free0(var) ((var == NULL) ? NULL : (var = (g_rand_free (var), NULL)))

#define GEE_CONCURRENT_SET_TYPE_ITERATOR (gee_concurrent_set_iterator_get_type ())
#define GEE_CONCURRENT_SET_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator))
#define GEE_CONCURRENT_SET_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIteratorClass))
#define GEE_CONCURRENT_SET_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR))
#define GEE_CONCURRENT_SET_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_ITERATOR))
#define GEE_CONCURRENT_SET_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIteratorClass))

typedef struct _GeeConcurrentSetIterator GeeConcurrentSetIterator;
typedef struct _GeeConcurrentSetIteratorClass GeeConcurrentSetIteratorClass;

#define GEE_CONCURRENT_SET_TYPE_TOWER_ITER (gee_concurrent_set_tower_iter_get_type ())
typedef struct _GeeConcurrentSetTowerIter GeeConcurrentSetTowerIter;
typedef struct _GeeConcurrentSetTowerPrivate GeeConcurrentSetTowerPrivate;

#define GEE_CONCURRENT_SET_TYPE_TOWER_NODE (gee_concurrent_set_tower_node_get_type ())
typedef struct _GeeConcurrentSetTowerNode GeeConcurrentSetTowerNode;

#define GEE_CONCURRENT_SET_TYPE_RANGE (gee_concurrent_set_range_get_type ())
#define GEE_CONCURRENT_SET_RANGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRange))
#define GEE_CONCURRENT_SET_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRangeClass))
#define GEE_CONCURRENT_SET_IS_RANGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_RANGE))
#define GEE_CONCURRENT_SET_IS_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_RANGE))
#define GEE_CONCURRENT_SET_RANGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRangeClass))

typedef struct _GeeConcurrentSetRange GeeConcurrentSetRange;
typedef struct _GeeConcurrentSetRangeClass GeeConcurrentSetRangeClass;

#define GEE_CONCURRENT_SET_TYPE_SUB_SET (gee_concurrent_set_sub_set_get_type ())
#define GEE_CONCURRENT_SET_SUB_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet))
#define GEE_CONCURRENT_SET_SUB_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSetClass))
#define GEE_CONCURRENT_SET_IS_SUB_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET))
#define GEE_CONCURRENT_SET_IS_SUB_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_SUB_SET))
#define GEE_CONCURRENT_SET_SUB_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSetClass))

typedef struct _GeeConcurrentSetSubSet GeeConcurrentSetSubSet;
typedef struct _GeeConcurrentSetSubSetClass GeeConcurrentSetSubSetClass;
#define _gee_concurrent_set_range_unref0(var) ((var == NULL) ? NULL : (var = (gee_concurrent_set_range_unref (var), NULL)))
typedef struct _GeeConcurrentSetIteratorPrivate GeeConcurrentSetIteratorPrivate;
enum  {
	GEE_CONCURRENT_SET_ITERATOR_0_PROPERTY,
	GEE_CONCURRENT_SET_ITERATOR_G_TYPE,
	GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC,
	GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_ITERATOR_VALID_PROPERTY,
	GEE_CONCURRENT_SET_ITERATOR_READ_ONLY_PROPERTY,
	GEE_CONCURRENT_SET_ITERATOR_NUM_PROPERTIES
};
static GParamSpec* gee_concurrent_set_iterator_properties[GEE_CONCURRENT_SET_ITERATOR_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _GeeConcurrentSetSubSetPrivate GeeConcurrentSetSubSetPrivate;
enum  {
	GEE_CONCURRENT_SET_SUB_SET_0_PROPERTY,
	GEE_CONCURRENT_SET_SUB_SET_G_TYPE,
	GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC,
	GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SUB_SET_SIZE_PROPERTY,
	GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY_PROPERTY,
	GEE_CONCURRENT_SET_SUB_SET_READ_ONLY_PROPERTY,
	GEE_CONCURRENT_SET_SUB_SET_NUM_PROPERTIES
};
static GParamSpec* gee_concurrent_set_sub_set_properties[GEE_CONCURRENT_SET_SUB_SET_NUM_PROPERTIES];

#define GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR (gee_concurrent_set_sub_iterator_get_type ())
#define GEE_CONCURRENT_SET_SUB_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator))
#define GEE_CONCURRENT_SET_SUB_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIteratorClass))
#define GEE_CONCURRENT_SET_IS_SUB_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR))
#define GEE_CONCURRENT_SET_IS_SUB_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR))
#define GEE_CONCURRENT_SET_SUB_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIteratorClass))

typedef struct _GeeConcurrentSetSubIterator GeeConcurrentSetSubIterator;
typedef struct _GeeConcurrentSetSubIteratorClass GeeConcurrentSetSubIteratorClass;
typedef struct _GeeConcurrentSetRangePrivate GeeConcurrentSetRangePrivate;
typedef enum  {
	GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE = -1,
	GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE = 0,
	GEE_CONCURRENT_SET_RANGE_POSITION_AFTER = 1,
	GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY
} GeeConcurrentSetRangePosition;

#define GEE_CONCURRENT_SET_RANGE_TYPE_POSITION (gee_concurrent_set_range_position_get_type ())
typedef struct _GeeConcurrentSetSubIteratorPrivate GeeConcurrentSetSubIteratorPrivate;
enum  {
	GEE_CONCURRENT_SET_SUB_ITERATOR_0_PROPERTY,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SUB_ITERATOR_VALID_PROPERTY,
	GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY_PROPERTY,
	GEE_CONCURRENT_SET_SUB_ITERATOR_NUM_PROPERTIES
};
static GParamSpec* gee_concurrent_set_sub_iterator_properties[GEE_CONCURRENT_SET_SUB_ITERATOR_NUM_PROPERTIES];
typedef struct _GeeConcurrentSetParamSpecRange GeeConcurrentSetParamSpecRange;
typedef struct _GeeConcurrentSetParamSpecTower GeeConcurrentSetParamSpecTower;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeConcurrentSetPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gint _size;
	GeeConcurrentSetTower* _head;
	GCompareDataFunc _cmp;
	gpointer _cmp_target;
	GDestroyNotify _cmp_target_destroy_notify;
};

struct _GeeConcurrentSetTowerIter {
	GeeConcurrentSetTower* _iter[31];
};

struct _GeeConcurrentSetTowerNode {
	GeeConcurrentSetTower* _succ;
	GeeConcurrentSetTower* _backlink;
};

struct _GeeConcurrentSetTower {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeeConcurrentSetTowerPrivate * priv;
	GeeConcurrentSetTowerNode* _nodes;
	gpointer _data;
	gint _height;
};

struct _GeeConcurrentSetTowerClass {
	GTypeClass parent_class;
	void (*finalize) (GeeConcurrentSetTower *self);
};

struct _GeeConcurrentSetIterator {
	GObject parent_instance;
	GeeConcurrentSetIteratorPrivate * priv;
	gboolean _removed;
	GeeConcurrentSet* _set;
	GeeConcurrentSetTowerIter _prev;
	GeeConcurrentSetTower* _curr;
};

struct _GeeConcurrentSetIteratorClass {
	GObjectClass parent_class;
};

struct _GeeConcurrentSetIteratorPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetSubSet {
	GeeAbstractSortedSet parent_instance;
	GeeConcurrentSetSubSetPrivate * priv;
};

struct _GeeConcurrentSetSubSetClass {
	GeeAbstractSortedSetClass parent_class;
};

struct _GeeConcurrentSetSubSetPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	GeeConcurrentSetRange* _range;
};

struct _GeeConcurrentSetRange {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeeConcurrentSetRangePrivate * priv;
	gpointer _start;
	gpointer _end;
	GeeConcurrentSetRangeType _type;
	GeeConcurrentSetTowerIter _bookmark;
	GeeConcurrentSet* _set;
};

struct _GeeConcurrentSetRangeClass {
	GTypeClass parent_class;
	void (*finalize) (GeeConcurrentSetRange *self);
};

struct _GeeConcurrentSetSubIterator {
	GObject parent_instance;
	GeeConcurrentSetSubIteratorPrivate * priv;
	GeeConcurrentSetRange* _range;
	GeeConcurrentSetTowerIter _prev;
	GeeConcurrentSetTower* _curr;
	gboolean _removed;
};

struct _GeeConcurrentSetSubIteratorClass {
	GObjectClass parent_class;
};

struct _GeeConcurrentSetSubIteratorPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetRangePrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetParamSpecRange {
	GParamSpec parent_instance;
};

struct _GeeConcurrentSetTowerPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetParamSpecTower {
	GParamSpec parent_instance;
};

static gint GeeConcurrentSet_private_offset;
static gpointer gee_concurrent_set_parent_class = NULL;
static GPrivate* gee_concurrent_set_rand;
static GPrivate* gee_concurrent_set_rand = NULL;
static gint GeeConcurrentSetIterator_private_offset;
static gpointer gee_concurrent_set_iterator_parent_class = NULL;
static GeeTraversableIface * gee_concurrent_set_iterator_gee_traversable_parent_iface = NULL;
static GeeIteratorIface * gee_concurrent_set_iterator_gee_iterator_parent_iface = NULL;
static gint GeeConcurrentSetSubSet_private_offset;
static gpointer gee_concurrent_set_sub_set_parent_class = NULL;
static gint GeeConcurrentSetSubIterator_private_offset;
static gpointer gee_concurrent_set_sub_iterator_parent_class = NULL;
static GeeTraversableIface * gee_concurrent_set_sub_iterator_gee_traversable_parent_iface = NULL;
static GeeIteratorIface * gee_concurrent_set_sub_iterator_gee_iterator_parent_iface = NULL;
static gint GeeConcurrentSetRange_private_offset;
static gpointer gee_concurrent_set_range_parent_class = NULL;
static gint GeeConcurrentSetTower_private_offset;
static gpointer gee_concurrent_set_tower_parent_class = NULL;

static gpointer gee_concurrent_set_tower_ref (gpointer instance);
static void gee_concurrent_set_tower_unref (gpointer instance);
static GParamSpec* gee_concurrent_set_param_spec_tower (const gchar* name,
                                                 const gchar* nick,
                                                 const gchar* blurb,
                                                 GType object_type,
                                                 GParamFlags flags) G_GNUC_UNUSED ;
static void gee_concurrent_set_value_set_tower (GValue* value,
                                         gpointer v_object) G_GNUC_UNUSED ;
static void gee_concurrent_set_value_take_tower (GValue* value,
                                          gpointer v_object) G_GNUC_UNUSED ;
static gpointer gee_concurrent_set_value_get_tower (const GValue* value) G_GNUC_UNUSED ;
static GType gee_concurrent_set_tower_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GType gee_concurrent_set_state_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static void _gee_concurrent_set_rand_lambda57_ (void* ptr);
static void __gee_concurrent_set_rand_lambda57__gdestroy_notify (void* data);
static GeeConcurrentSetTower* gee_concurrent_set_tower_new_head (GType g_type,
                                                          GBoxedCopyFunc g_dup_func,
                                                          GDestroyNotify g_destroy_func);
static GeeConcurrentSetTower* gee_concurrent_set_tower_construct_head (GType object_type,
                                                                GType g_type,
                                                                GBoxedCopyFunc g_dup_func,
                                                                GDestroyNotify g_destroy_func);
static GeeIterator* gee_concurrent_set_real_iterator (GeeAbstractCollection* base);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new (GType g_type,
                                                           GBoxedCopyFunc g_dup_func,
                                                           GDestroyNotify g_destroy_func,
                                                           GeeConcurrentSet* cset,
                                                           GeeConcurrentSetTower* head);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct (GType object_type,
                                                                 GType g_type,
                                                                 GBoxedCopyFunc g_dup_func,
                                                                 GDestroyNotify g_destroy_func,
                                                                 GeeConcurrentSet* cset,
                                                                 GeeConcurrentSetTower* head);
static GType gee_concurrent_set_iterator_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static gboolean gee_concurrent_set_real_contains (GeeAbstractCollection* base,
                                           gconstpointer key);
static inline gboolean gee_concurrent_set_tower_search (GType g_type,
                                          GBoxedCopyFunc g_dup_func,
                                          GDestroyNotify g_destroy_func,
                                          GCompareDataFunc cmp,
                                          gpointer cmp_target,
                                          gconstpointer key,
                                          GeeConcurrentSetTower** prev,
                                          GeeConcurrentSetTower** next,
                                          guint8 to_level,
                                          guint8 from_level);
static gboolean gee_concurrent_set_real_add (GeeAbstractCollection* base,
                                      gconstpointer key);
static GType gee_concurrent_set_tower_iter_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GeeConcurrentSetTowerIter* gee_concurrent_set_tower_iter_dup (const GeeConcurrentSetTowerIter* self);
static void gee_concurrent_set_tower_iter_free (GeeConcurrentSetTowerIter* self);
static void gee_concurrent_set_tower_iter_copy (const GeeConcurrentSetTowerIter* self,
                                         GeeConcurrentSetTowerIter* dest);
static void gee_concurrent_set_tower_iter_destroy (GeeConcurrentSetTowerIter* self);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert (GType g_type,
                                                        GBoxedCopyFunc g_dup_func,
                                                        GDestroyNotify g_destroy_func,
                                                        GCompareDataFunc cmp,
                                                        gpointer cmp_target,
                                                        GeeConcurrentSetTowerIter* prev,
                                                        gconstpointer key,
                                                        guint8 chosen_level);
static gboolean gee_concurrent_set_real_remove (GeeAbstractCollection* base,
                                         gconstpointer item);
static inline gboolean gee_concurrent_set_tower_remove_key (GType g_type,
                                              GBoxedCopyFunc g_dup_func,
                                              GDestroyNotify g_destroy_func,
                                              GCompareDataFunc cmp,
                                              gpointer cmp_target,
                                              GeeConcurrentSetTowerIter* prev,
                                              gconstpointer key,
                                              guint8 from_level);
static void gee_concurrent_set_real_clear (GeeAbstractCollection* base);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_next (GeeConcurrentSetTower* self,
                                                          guint8 level);
static GType gee_concurrent_set_tower_node_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GeeConcurrentSetTowerNode* gee_concurrent_set_tower_node_dup (const GeeConcurrentSetTowerNode* self);
static void gee_concurrent_set_tower_node_free (GeeConcurrentSetTowerNode* self);
static gpointer gee_concurrent_set_real_first (GeeAbstractSortedSet* base);
static inline gboolean gee_concurrent_set_tower_proceed (GType g_type,
                                           GBoxedCopyFunc g_dup_func,
                                           GDestroyNotify g_destroy_func,
                                           GCompareDataFunc cmp,
                                           gpointer cmp_target,
                                           GeeConcurrentSetTower** arg_prev,
                                           GeeConcurrentSetTower** arg_curr,
                                           guint8 level,
                                           gboolean force);
static gpointer gee_concurrent_set_real_last (GeeAbstractSortedSet* base);
static GeeIterator* gee_concurrent_set_real_iterator_at (GeeAbstractSortedSet* base,
                                                  gconstpointer element);
static inline gboolean gee_concurrent_set_tower_search_from_bookmark (GType g_type,
                                                        GBoxedCopyFunc g_dup_func,
                                                        GDestroyNotify g_destroy_func,
                                                        GCompareDataFunc cmp,
                                                        gpointer cmp_target,
                                                        gconstpointer key,
                                                        GeeConcurrentSetTowerIter* prev,
                                                        GeeConcurrentSetTowerIter* next,
                                                        guint8 to_level,
                                                        guint8 from_level);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new_point_at (GType g_type,
                                                                    GBoxedCopyFunc g_dup_func,
                                                                    GDestroyNotify g_destroy_func,
                                                                    GeeConcurrentSet* cset,
                                                                    GeeConcurrentSetTowerIter* prev,
                                                                    GeeConcurrentSetTower* curr);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct_point_at (GType object_type,
                                                                          GType g_type,
                                                                          GBoxedCopyFunc g_dup_func,
                                                                          GDestroyNotify g_destroy_func,
                                                                          GeeConcurrentSet* cset,
                                                                          GeeConcurrentSetTowerIter* prev,
                                                                          GeeConcurrentSetTower* curr);
static gpointer gee_concurrent_set_real_lower (GeeAbstractSortedSet* base,
                                        gconstpointer element);
static gpointer gee_concurrent_set_real_higher (GeeAbstractSortedSet* base,
                                         gconstpointer element);
static gpointer gee_concurrent_set_real_floor (GeeAbstractSortedSet* base,
                                        gconstpointer element);
static gpointer gee_concurrent_set_real_ceil (GeeAbstractSortedSet* base,
                                       gconstpointer element);
static GeeSortedSet* gee_concurrent_set_real_head_set (GeeAbstractSortedSet* base,
                                                gconstpointer before);
static GeeConcurrentSetRange* gee_concurrent_set_range_new_head (GType g_type,
                                                          GBoxedCopyFunc g_dup_func,
                                                          GDestroyNotify g_destroy_func,
                                                          GeeConcurrentSet* cset,
                                                          gconstpointer end);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_head (GType object_type,
                                                                GType g_type,
                                                                GBoxedCopyFunc g_dup_func,
                                                                GDestroyNotify g_destroy_func,
                                                                GeeConcurrentSet* cset,
                                                                gconstpointer end);
static gpointer gee_concurrent_set_range_ref (gpointer instance);
static void gee_concurrent_set_range_unref (gpointer instance);
static GParamSpec* gee_concurrent_set_param_spec_range (const gchar* name,
                                                 const gchar* nick,
                                                 const gchar* blurb,
                                                 GType object_type,
                                                 GParamFlags flags) G_GNUC_UNUSED ;
static void gee_concurrent_set_value_set_range (GValue* value,
                                         gpointer v_object) G_GNUC_UNUSED ;
static void gee_concurrent_set_value_take_range (GValue* value,
                                          gpointer v_object) G_GNUC_UNUSED ;
static gpointer gee_concurrent_set_value_get_range (const GValue* value) G_GNUC_UNUSED ;
static GType gee_concurrent_set_range_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_new (GType g_type,
                                                        GBoxedCopyFunc g_dup_func,
                                                        GDestroyNotify g_destroy_func,
                                                        GeeConcurrentSetRange* range);
static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_construct (GType object_type,
                                                              GType g_type,
                                                              GBoxedCopyFunc g_dup_func,
                                                              GDestroyNotify g_destroy_func,
                                                              GeeConcurrentSetRange* range);
static GType gee_concurrent_set_sub_set_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GeeSortedSet* gee_concurrent_set_real_tail_set (GeeAbstractSortedSet* base,
                                                gconstpointer after);
static GeeConcurrentSetRange* gee_concurrent_set_range_new_tail (GType g_type,
                                                          GBoxedCopyFunc g_dup_func,
                                                          GDestroyNotify g_destroy_func,
                                                          GeeConcurrentSet* cset,
                                                          gconstpointer start);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_tail (GType object_type,
                                                                GType g_type,
                                                                GBoxedCopyFunc g_dup_func,
                                                                GDestroyNotify g_destroy_func,
                                                                GeeConcurrentSet* cset,
                                                                gconstpointer start);
static GeeSortedSet* gee_concurrent_set_real_sub_set (GeeAbstractSortedSet* base,
                                               gconstpointer from,
                                               gconstpointer to);
static GeeConcurrentSetRange* gee_concurrent_set_range_new (GType g_type,
                                                     GBoxedCopyFunc g_dup_func,
                                                     GDestroyNotify g_destroy_func,
                                                     GeeConcurrentSet* cset,
                                                     gconstpointer start,
                                                     gconstpointer end);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct (GType object_type,
                                                           GType g_type,
                                                           GBoxedCopyFunc g_dup_func,
                                                           GDestroyNotify g_destroy_func,
                                                           GeeConcurrentSet* cset,
                                                           gconstpointer start,
                                                           gconstpointer end);
static gconstpointer gee_concurrent_set_max (GeeConcurrentSet* self,
                                      gconstpointer a,
                                      gconstpointer b,
                                      gboolean* changed);
static gconstpointer gee_concurrent_set_min (GeeConcurrentSet* self,
                                      gconstpointer a,
                                      gconstpointer b,
                                      gboolean* changed);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new_from_iterator (GType g_type,
                                                                         GBoxedCopyFunc g_dup_func,
                                                                         GDestroyNotify g_destroy_func,
                                                                         GeeConcurrentSetIterator* iter);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct_from_iterator (GType object_type,
                                                                               GType g_type,
                                                                               GBoxedCopyFunc g_dup_func,
                                                                               GDestroyNotify g_destroy_func,
                                                                               GeeConcurrentSetIterator* iter);
static gboolean gee_concurrent_set_iterator_real_foreach (GeeTraversable* base,
                                                   GeeForallFunc f,
                                                   gpointer f_target);
static inline gint gee_concurrent_set_tower_get_height (GeeConcurrentSetTower* self);
static GeeIterator** gee_concurrent_set_iterator_real_tee (GeeTraversable* base,
                                                    guint forks,
                                                    gint* result_length1);
static gboolean gee_concurrent_set_iterator_real_next (GeeIterator* base);
static gboolean gee_concurrent_set_iterator_real_has_next (GeeIterator* base);
static gpointer gee_concurrent_set_iterator_real_get (GeeIterator* base);
static void gee_concurrent_set_iterator_real_remove (GeeIterator* base);
static inline gboolean gee_concurrent_set_tower_remove (GType g_type,
                                          GBoxedCopyFunc g_dup_func,
                                          GDestroyNotify g_destroy_func,
                                          GCompareDataFunc cmp,
                                          gpointer cmp_target,
                                          GeeConcurrentSetTowerIter* prev,
                                          GeeConcurrentSetTower* curr);
static void gee_concurrent_set_iterator_finalize (GObject * obj);
static GType gee_concurrent_set_iterator_get_type_once (void);
static void _vala_gee_concurrent_set_iterator_get_property (GObject * object,
                                                     guint property_id,
                                                     GValue * value,
                                                     GParamSpec * pspec);
static void _vala_gee_concurrent_set_iterator_set_property (GObject * object,
                                                     guint property_id,
                                                     const GValue * value,
                                                     GParamSpec * pspec);
static GeeIterator* gee_concurrent_set_sub_set_real_iterator (GeeAbstractCollection* base);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new (GType g_type,
                                                                  GBoxedCopyFunc g_dup_func,
                                                                  GDestroyNotify g_destroy_func,
                                                                  GeeConcurrentSetRange* range);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct (GType object_type,
                                                                        GType g_type,
                                                                        GBoxedCopyFunc g_dup_func,
                                                                        GDestroyNotify g_destroy_func,
                                                                        GeeConcurrentSetRange* range);
static GType gee_concurrent_set_sub_iterator_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static gboolean gee_concurrent_set_sub_set_real_contains (GeeAbstractCollection* base,
                                                   gconstpointer item);
static gboolean gee_concurrent_set_range_inside (GType g_type,
                                          GBoxedCopyFunc g_dup_func,
                                          GDestroyNotify g_destroy_func,
                                          GeeConcurrentSetRange* range,
                                          gconstpointer val);
static void gee_concurrent_set_range_improve_bookmark (GType g_type,
                                                GBoxedCopyFunc g_dup_func,
                                                GDestroyNotify g_destroy_func,
                                                GeeConcurrentSetRange* range,
                                                GeeConcurrentSetTower** out_curr,
                                                GeeConcurrentSetTowerIter* prev);
static gboolean gee_concurrent_set_sub_set_real_add (GeeAbstractCollection* base,
                                              gconstpointer key);
static gboolean gee_concurrent_set_sub_set_real_remove (GeeAbstractCollection* base,
                                                 gconstpointer key);
static void gee_concurrent_set_sub_set_real_clear (GeeAbstractCollection* base);
static gpointer gee_concurrent_set_sub_set_real_first (GeeAbstractSortedSet* base);
static gpointer gee_concurrent_set_sub_set_real_last (GeeAbstractSortedSet* base);
static gboolean gee_concurrent_set_range_proceed (GType g_type,
                                           GBoxedCopyFunc g_dup_func,
                                           GDestroyNotify g_destroy_func,
                                           GeeConcurrentSetRange* range,
                                           GeeConcurrentSetTower** prev,
                                           GeeConcurrentSetTower** curr,
                                           guint8 level);
static GeeIterator* gee_concurrent_set_sub_set_real_iterator_at (GeeAbstractSortedSet* base,
                                                          gconstpointer element);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new_point_at (GType g_type,
                                                                           GBoxedCopyFunc g_dup_func,
                                                                           GDestroyNotify g_destroy_func,
                                                                           GeeConcurrentSetRange* range,
                                                                           GeeConcurrentSetTowerIter* prev,
                                                                           GeeConcurrentSetTower* curr);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct_point_at (GType object_type,
                                                                                 GType g_type,
                                                                                 GBoxedCopyFunc g_dup_func,
                                                                                 GDestroyNotify g_destroy_func,
                                                                                 GeeConcurrentSetRange* range,
                                                                                 GeeConcurrentSetTowerIter* prev,
                                                                                 GeeConcurrentSetTower* curr);
static gpointer gee_concurrent_set_sub_set_real_lower (GeeAbstractSortedSet* base,
                                                gconstpointer element);
static gint gee_concurrent_set_range_cmp (GType g_type,
                                   GBoxedCopyFunc g_dup_func,
                                   GDestroyNotify g_destroy_func,
                                   GeeConcurrentSetRange* range,
                                   gconstpointer val);
static GType gee_concurrent_set_range_position_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static gpointer gee_concurrent_set_sub_set_real_higher (GeeAbstractSortedSet* base,
                                                 gconstpointer element);
static gpointer gee_concurrent_set_sub_set_real_floor (GeeAbstractSortedSet* base,
                                                gconstpointer element);
static inline gboolean gee_concurrent_set_tower_is_head (GeeConcurrentSetTower* self);
static gpointer gee_concurrent_set_sub_set_real_ceil (GeeAbstractSortedSet* base,
                                               gconstpointer element);
static GeeSortedSet* gee_concurrent_set_sub_set_real_head_set (GeeAbstractSortedSet* base,
                                                        gconstpointer before);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut_tail (GType g_type,
                                                          GBoxedCopyFunc g_dup_func,
                                                          GDestroyNotify g_destroy_func,
                                                          GeeConcurrentSetRange* from,
                                                          gconstpointer end);
static GeeSortedSet* gee_concurrent_set_sub_set_real_tail_set (GeeAbstractSortedSet* base,
                                                        gconstpointer after);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut_head (GType g_type,
                                                          GBoxedCopyFunc g_dup_func,
                                                          GDestroyNotify g_destroy_func,
                                                          GeeConcurrentSetRange* from,
                                                          gconstpointer start);
static GeeSortedSet* gee_concurrent_set_sub_set_real_sub_set (GeeAbstractSortedSet* base,
                                                       gconstpointer from,
                                                       gconstpointer to);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut (GType g_type,
                                                     GBoxedCopyFunc g_dup_func,
                                                     GDestroyNotify g_destroy_func,
                                                     GeeConcurrentSetRange* from,
                                                     gconstpointer start,
                                                     gconstpointer end);
static gboolean gee_concurrent_set_sub_set_get_is_empty (GeeConcurrentSetSubSet* self);
static void gee_concurrent_set_sub_set_finalize (GObject * obj);
static GType gee_concurrent_set_sub_set_get_type_once (void);
static void _vala_gee_concurrent_set_sub_set_get_property (GObject * object,
                                                    guint property_id,
                                                    GValue * value,
                                                    GParamSpec * pspec);
static void _vala_gee_concurrent_set_sub_set_set_property (GObject * object,
                                                    guint property_id,
                                                    const GValue * value,
                                                    GParamSpec * pspec);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new_from_iterator (GType g_type,
                                                                                GBoxedCopyFunc g_dup_func,
                                                                                GDestroyNotify g_destroy_func,
                                                                                GeeConcurrentSetSubIterator* iter);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct_from_iterator (GType object_type,
                                                                                      GType g_type,
                                                                                      GBoxedCopyFunc g_dup_func,
                                                                                      GDestroyNotify g_destroy_func,
                                                                                      GeeConcurrentSetSubIterator* iter);
static gboolean gee_concurrent_set_sub_iterator_real_foreach (GeeTraversable* base,
                                                       GeeForallFunc f,
                                                       gpointer f_target);
static gboolean gee_concurrent_set_sub_iterator_begin (GeeConcurrentSetSubIterator* self);
static GeeIterator** gee_concurrent_set_sub_iterator_real_tee (GeeTraversable* base,
                                                        guint forks,
                                                        gint* result_length1);
static gboolean gee_concurrent_set_sub_iterator_real_next (GeeIterator* base);
static gboolean gee_concurrent_set_sub_iterator_real_has_next (GeeIterator* base);
static gboolean gee_concurrent_set_range_beyond (GType g_type,
                                          GBoxedCopyFunc g_dup_func,
                                          GDestroyNotify g_destroy_func,
                                          GeeConcurrentSetRange* range,
                                          GeeConcurrentSetTower* tw);
static gpointer gee_concurrent_set_sub_iterator_real_get (GeeIterator* base);
static void gee_concurrent_set_sub_iterator_real_remove (GeeIterator* base);
static void gee_concurrent_set_sub_iterator_finalize (GObject * obj);
static GType gee_concurrent_set_sub_iterator_get_type_once (void);
static void _vala_gee_concurrent_set_sub_iterator_get_property (GObject * object,
                                                         guint property_id,
                                                         GValue * value,
                                                         GParamSpec * pspec);
static void _vala_gee_concurrent_set_sub_iterator_set_property (GObject * object,
                                                         guint property_id,
                                                         const GValue * value,
                                                         GParamSpec * pspec);
static GeeConcurrentSetRange* gee_concurrent_set_range_new_empty (GType g_type,
                                                           GBoxedCopyFunc g_dup_func,
                                                           GDestroyNotify g_destroy_func,
                                                           GeeConcurrentSet* cset);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_empty (GType object_type,
                                                                 GType g_type,
                                                                 GBoxedCopyFunc g_dup_func,
                                                                 GDestroyNotify g_destroy_func,
                                                                 GeeConcurrentSet* cset);
static void gee_concurrent_set_range_copy_bookmark (GeeConcurrentSetRange* self,
                                             GeeConcurrentSetRange* range);
static inline void gee_concurrent_set_tower_backtrace (GType g_type,
                                         GBoxedCopyFunc g_dup_func,
                                         GDestroyNotify g_destroy_func,
                                         GeeConcurrentSetTower** curr,
                                         guint8 level);
static inline gint gee_concurrent_set_tower_compare (GType g_type,
                                       GBoxedCopyFunc g_dup_func,
                                       GDestroyNotify g_destroy_func,
                                       GCompareDataFunc cmp,
                                       gpointer cmp_target,
                                       GeeConcurrentSetTower* a,
                                       GeeConcurrentSetTower* b);
static inline gint gee_concurrent_set_tower_compare_data (GType g_type,
                                            GBoxedCopyFunc g_dup_func,
                                            GDestroyNotify g_destroy_func,
                                            GCompareDataFunc cmp,
                                            gpointer cmp_target,
                                            GeeConcurrentSetTower* a,
                                            gconstpointer b);
static void gee_concurrent_set_range_finalize (GeeConcurrentSetRange * obj);
static GType gee_concurrent_set_range_get_type_once (void);
static inline void gee_concurrent_set_tower_set_succ (GeeConcurrentSetTower* self,
                                        GeeConcurrentSetTower* next,
                                        GeeConcurrentSetState state,
                                        guint8 level);
static inline void gee_concurrent_set_tower_set_backlink (GeeConcurrentSetTower* self,
                                            GeeConcurrentSetTower* backlink,
                                            guint8 level);
static GeeConcurrentSetTower* gee_concurrent_set_tower_new (GType g_type,
                                                     GBoxedCopyFunc g_dup_func,
                                                     GDestroyNotify g_destroy_func,
                                                     gconstpointer data,
                                                     guint8 height);
static GeeConcurrentSetTower* gee_concurrent_set_tower_construct (GType object_type,
                                                           GType g_type,
                                                           GBoxedCopyFunc g_dup_func,
                                                           GDestroyNotify g_destroy_func,
                                                           gconstpointer data,
                                                           guint8 height);
static inline gboolean gee_concurrent_set_tower_search_helper (GType g_type,
                                                 GBoxedCopyFunc g_dup_func,
                                                 GDestroyNotify g_destroy_func,
                                                 GCompareDataFunc cmp,
                                                 gpointer cmp_target,
                                                 gconstpointer key,
                                                 GeeConcurrentSetTower** prev,
                                                 GeeConcurrentSetTower** next,
                                                 guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert_helper (GType g_type,
                                                               GBoxedCopyFunc g_dup_func,
                                                               GDestroyNotify g_destroy_func,
                                                               GCompareDataFunc cmp,
                                                               gpointer cmp_target,
                                                               GeeConcurrentSetTowerIter* prev,
                                                               gconstpointer key,
                                                               guint8 chosen_level,
                                                               guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_succ (GeeConcurrentSetTower* self,
                                                          GeeConcurrentSetState* state,
                                                          guint8 level);
static inline void gee_concurrent_set_tower_help_flagged (GeeConcurrentSetTower* self,
                                            GeeConcurrentSetTower* prev,
                                            guint8 level);
static inline gboolean gee_concurrent_set_tower_compare_and_exchange (GeeConcurrentSetTower* self,
                                                        GeeConcurrentSetTower* old_tower,
                                                        GeeConcurrentSetState old_state,
                                                        GeeConcurrentSetTower* new_tower,
                                                        GeeConcurrentSetState new_state,
                                                        guint8 level);
static inline GeeConcurrentSetState gee_concurrent_set_tower_get_state (GeeConcurrentSetTower* self,
                                                          guint8 level);
static inline gboolean gee_concurrent_set_tower_remove_level (GType g_type,
                                                GBoxedCopyFunc g_dup_func,
                                                GDestroyNotify g_destroy_func,
                                                GCompareDataFunc cmp,
                                                gpointer cmp_target,
                                                GeeConcurrentSetTower** prev,
                                                GeeConcurrentSetTower* curr,
                                                guint8 level);
static inline gboolean gee_concurrent_set_tower_try_flag (GeeConcurrentSetTower* self,
                                            GCompareDataFunc cmp,
                                            gpointer cmp_target,
                                            GeeConcurrentSetTower** prev_tower,
                                            gboolean* status,
                                            guint8 level);
static inline void gee_concurrent_set_tower_help_marked (GeeConcurrentSetTower* self,
                                           GeeConcurrentSetTower* prev_tower,
                                           guint8 level);
static inline void gee_concurrent_set_tower_try_mark (GeeConcurrentSetTower* self,
                                        guint8 level);
static inline gboolean gee_concurrent_set_tower_compare_succ (GeeConcurrentSetTower* self,
                                                GeeConcurrentSetTower* next,
                                                GeeConcurrentSetState state,
                                                guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_backlink (GeeConcurrentSetTower* self,
                                                              guint8 level);
static void gee_concurrent_set_tower_finalize (GeeConcurrentSetTower * obj);
static GType gee_concurrent_set_tower_get_type_once (void);
static void _vala_array_copy1 (GeeConcurrentSetTower* * self,
                        GeeConcurrentSetTower* * dest);
static void gee_concurrent_set_finalize (GObject * obj);
static GType gee_concurrent_set_get_type_once (void);
static void _vala_gee_concurrent_set_get_property (GObject * object,
                                            guint property_id,
                                            GValue * value,
                                            GParamSpec * pspec);
static void _vala_gee_concurrent_set_set_property (GObject * object,
                                            guint property_id,
                                            const GValue * value,
                                            GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
gee_concurrent_set_get_instance_private (GeeConcurrentSet* self)
{
	return G_STRUCT_MEMBER_P (self, GeeConcurrentSet_private_offset);
}

static GType
gee_concurrent_set_range_type_get_type_once (void)
{
	static const GEnumValue values[] = {{GEE_CONCURRENT_SET_RANGE_TYPE_HEAD, "GEE_CONCURRENT_SET_RANGE_TYPE_HEAD", "head"}, {GEE_CONCURRENT_SET_RANGE_TYPE_TAIL, "GEE_CONCURRENT_SET_RANGE_TYPE_TAIL", "tail"}, {GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED, "GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED", "bounded"}, {GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY, "GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY", "empty"}, {0, NULL, NULL}};
	GType gee_concurrent_set_range_type_type_id;
	gee_concurrent_set_range_type_type_id = g_enum_register_static ("GeeConcurrentSetRangeType", values);
	return gee_concurrent_set_range_type_type_id;
}

GType
gee_concurrent_set_range_type_get_type (void)
{
	static volatile gsize gee_concurrent_set_range_type_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_type_type_id__once)) {
		GType gee_concurrent_set_range_type_type_id;
		gee_concurrent_set_range_type_type_id = gee_concurrent_set_range_type_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_range_type_type_id__once, gee_concurrent_set_range_type_type_id);
	}
	return gee_concurrent_set_range_type_type_id__once;
}

static GType
gee_concurrent_set_state_get_type_once (void)
{
	static const GEnumValue values[] = {{GEE_CONCURRENT_SET_STATE_NONE, "GEE_CONCURRENT_SET_STATE_NONE", "none"}, {GEE_CONCURRENT_SET_STATE_MARKED, "GEE_CONCURRENT_SET_STATE_MARKED", "marked"}, {GEE_CONCURRENT_SET_STATE_FLAGGED, "GEE_CONCURRENT_SET_STATE_FLAGGED", "flagged"}, {0, NULL, NULL}};
	GType gee_concurrent_set_state_type_id;
	gee_concurrent_set_state_type_id = g_enum_register_static ("GeeConcurrentSetState", values);
	return gee_concurrent_set_state_type_id;
}

static GType
gee_concurrent_set_state_get_type (void)
{
	static volatile gsize gee_concurrent_set_state_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_state_type_id__once)) {
		GType gee_concurrent_set_state_type_id;
		gee_concurrent_set_state_type_id = gee_concurrent_set_state_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_state_type_id__once, gee_concurrent_set_state_type_id);
	}
	return gee_concurrent_set_state_type_id__once;
}

static void
_gee_concurrent_set_rand_lambda57_ (void* ptr)
{
	GRand* rnd = NULL;
	GRand* _tmp0_;
	rnd = (GRand*) ptr;
	_tmp0_ = rnd;
	_g_rand_free0 (_tmp0_);
}

static void
__gee_concurrent_set_rand_lambda57__gdestroy_notify (void* data)
{
	_gee_concurrent_set_rand_lambda57_ (data);
}

GeeConcurrentSet*
gee_concurrent_set_construct (GType object_type,
                              GType g_type,
                              GBoxedCopyFunc g_dup_func,
                              GDestroyNotify g_destroy_func,
                              GCompareDataFunc compare_func,
                              gpointer compare_func_target,
                              GDestroyNotify compare_func_target_destroy_notify)
{
	GeeConcurrentSet * self = NULL;
	GCompareDataFunc _tmp3_;
	gpointer _tmp3__target;
	GDestroyNotify _tmp3__target_destroy_notify;
	GeeConcurrentSetTower* _tmp4_;
	self = (GeeConcurrentSet*) gee_abstract_sorted_set_construct (object_type, g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	if (compare_func == NULL) {
		gpointer _tmp0_ = NULL;
		GDestroyNotify _tmp1_ = NULL;
		GCompareDataFunc _tmp2_;
		_tmp2_ = gee_functions_get_compare_func_for (g_type, &_tmp0_, &_tmp1_);
		(compare_func_target_destroy_notify == NULL) ? NULL : (compare_func_target_destroy_notify (compare_func_target), NULL);
		compare_func = NULL;
		compare_func_target = NULL;
		compare_func_target_destroy_notify = NULL;
		compare_func = _tmp2_;
		compare_func_target = _tmp0_;
		compare_func_target_destroy_notify = _tmp1_;
	}
	_tmp3_ = compare_func;
	_tmp3__target = compare_func_target;
	_tmp3__target_destroy_notify = compare_func_target_destroy_notify;
	compare_func = NULL;
	compare_func_target = NULL;
	compare_func_target_destroy_notify = NULL;
	(self->priv->_cmp_target_destroy_notify == NULL) ? NULL : (self->priv->_cmp_target_destroy_notify (self->priv->_cmp_target), NULL);
	self->priv->_cmp = NULL;
	self->priv->_cmp_target = NULL;
	self->priv->_cmp_target_destroy_notify = NULL;
	self->priv->_cmp = _tmp3_;
	self->priv->_cmp_target = _tmp3__target;
	self->priv->_cmp_target_destroy_notify = _tmp3__target_destroy_notify;
	_tmp4_ = gee_concurrent_set_tower_new_head (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func);
	_gee_concurrent_set_tower_unref0 (self->priv->_head);
	self->priv->_head = _tmp4_;
	(compare_func_target_destroy_notify == NULL) ? NULL : (compare_func_target_destroy_notify (compare_func_target), NULL);
	compare_func = NULL;
	compare_func_target = NULL;
	compare_func_target_destroy_notify = NULL;
	return self;
}

GeeConcurrentSet*
gee_concurrent_set_new (GType g_type,
                        GBoxedCopyFunc g_dup_func,
                        GDestroyNotify g_destroy_func,
                        GCompareDataFunc compare_func,
                        gpointer compare_func_target,
                        GDestroyNotify compare_func_target_destroy_notify)
{
	return gee_concurrent_set_construct (GEE_TYPE_CONCURRENT_SET, g_type, g_dup_func, g_destroy_func, compare_func, compare_func_target, compare_func_target_destroy_notify);
}

static GeeIterator*
gee_concurrent_set_real_iterator (GeeAbstractCollection* base)
{
	GeeConcurrentSet * self;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetIterator* _tmp1_;
	GeeIterator* result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = self->priv->_head;
	_tmp1_ = gee_concurrent_set_iterator_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, self, _tmp0_);
	result = (GeeIterator*) _tmp1_;
	return result;
}

static gpointer
_gee_concurrent_set_tower_ref0 (gpointer self)
{
	return self ? gee_concurrent_set_tower_ref (self) : NULL;
}

static gboolean
gee_concurrent_set_real_contains (GeeAbstractCollection* base,
                                  gconstpointer key)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GCompareDataFunc _tmp3_;
	gpointer _tmp3__target;
	gboolean _tmp4_;
	gboolean result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	prev = _tmp2_;
	_tmp3_ = self->priv->_cmp;
	_tmp3__target = self->priv->_cmp_target;
	_tmp4_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_, _tmp3__target, key, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	result = _tmp4_;
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gboolean
gee_concurrent_set_real_add (GeeAbstractCollection* base,
                             gconstpointer key)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GRand* rnd = NULL;
	GPrivate* _tmp2_;
	void* _tmp3_;
	GRand* _tmp4_;
	guint32 rand_int = 0U;
	GRand* _tmp8_;
	guint8 height = 0U;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTower* _tmp9_;
	GeeConcurrentSetTower* _tmp10_;
	GCompareDataFunc _tmp11_;
	gpointer _tmp11__target;
	gboolean _tmp12_;
	GeeConcurrentSetTower* _result_ = NULL;
	GCompareDataFunc _tmp18_;
	gpointer _tmp18__target;
	GeeConcurrentSetTower* _tmp19_;
	GeeConcurrentSetTower* _tmp20_;
	GeeConcurrentSetTower* _tmp21_;
	gboolean result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = gee_concurrent_set_rand;
	_tmp3_ = g_private_get (_tmp2_);
	rnd = _tmp3_;
	_tmp4_ = rnd;
	if (_tmp4_ == NULL) {
		GPrivate* _tmp5_;
		GRand* _tmp6_;
		GRand* _tmp7_;
		_tmp5_ = gee_concurrent_set_rand;
		_tmp6_ = g_rand_new ();
		rnd = _tmp6_;
		_tmp7_ = rnd;
		g_private_set (_tmp5_, _tmp7_);
	}
	_tmp8_ = rnd;
	rand_int = (guint32) g_rand_int_range (_tmp8_, (gint32) 0, G_MAXINT32);
	height = (guint8) (1 + ((guint8) g_bit_nth_lsf ((gulong) (~rand_int), -1)));
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	_tmp9_ = self->priv->_head;
	_tmp10_ = _gee_concurrent_set_tower_ref0 (_tmp9_);
	_gee_concurrent_set_tower_unref0 (prev._iter[height - 1]);
	prev._iter[height - 1] = _tmp10_;
	_tmp11_ = self->priv->_cmp;
	_tmp11__target = self->priv->_cmp_target;
	_tmp12_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp11_, _tmp11__target, key, &prev._iter[height - 1], NULL, (guint8) (height - 1), (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	if (_tmp12_) {
		result = FALSE;
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	{
		gint i = 0;
		i = height - 2;
		{
			gboolean _tmp13_ = FALSE;
			_tmp13_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTowerIter _tmp15_;
				GeeConcurrentSetTower* _tmp16_;
				GeeConcurrentSetTower* _tmp17_;
				if (!_tmp13_) {
					gint _tmp14_;
					_tmp14_ = i;
					i = _tmp14_ - 1;
				}
				_tmp13_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				_tmp15_ = prev;
				_tmp16_ = _tmp15_._iter[height - 1];
				_tmp17_ = _gee_concurrent_set_tower_ref0 (_tmp16_);
				_gee_concurrent_set_tower_unref0 (prev._iter[i]);
				prev._iter[i] = _tmp17_;
			}
		}
	}
	_tmp18_ = self->priv->_cmp;
	_tmp18__target = self->priv->_cmp_target;
	_tmp19_ = gee_concurrent_set_tower_insert (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp18_, _tmp18__target, &prev, key, (guint8) (height - 1));
	_result_ = _tmp19_;
	_tmp20_ = _result_;
	if (_tmp20_ != NULL) {
		g_atomic_int_inc ((volatile gint *) (&self->priv->_size));
	}
	_tmp21_ = _result_;
	result = _tmp21_ != NULL;
	_gee_concurrent_set_tower_unref0 (_result_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gboolean
gee_concurrent_set_real_remove (GeeAbstractCollection* base,
                                gconstpointer item)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTowerIter prev = {0};
	gboolean _result_ = FALSE;
	GCompareDataFunc _tmp6_;
	gpointer _tmp6__target;
	gboolean _tmp7_;
	gboolean result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTower* _tmp4_;
				GeeConcurrentSetTower* _tmp5_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp4_ = self->priv->_head;
				_tmp5_ = _gee_concurrent_set_tower_ref0 (_tmp4_);
				_gee_concurrent_set_tower_unref0 (prev._iter[i]);
				prev._iter[i] = _tmp5_;
			}
		}
	}
	_tmp6_ = self->priv->_cmp;
	_tmp6__target = self->priv->_cmp_target;
	_tmp7_ = gee_concurrent_set_tower_remove_key (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp6_, _tmp6__target, &prev, item, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_result_ = _tmp7_;
	if (_result_) {
		g_atomic_int_dec_and_test ((volatile gint *) (&self->priv->_size));
	}
	result = _result_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static void
gee_concurrent_set_real_clear (GeeAbstractCollection* base)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* first = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	while (TRUE) {
		GeeConcurrentSetTower* _tmp2_;
		GeeConcurrentSetTower* _tmp3_;
		GeeConcurrentSetTower* _tmp4_;
		GeeConcurrentSetTower* _tmp5_;
		gconstpointer _tmp6_;
		_tmp2_ = self->priv->_head;
		_tmp3_ = gee_concurrent_set_tower_get_next (_tmp2_, (guint8) 0);
		_gee_concurrent_set_tower_unref0 (first);
		first = _tmp3_;
		_tmp4_ = first;
		if (!(_tmp4_ != NULL)) {
			break;
		}
		_tmp5_ = first;
		_tmp6_ = _tmp5_->_data;
		gee_abstract_collection_remove ((GeeAbstractCollection*) self, _tmp6_);
	}
	_gee_concurrent_set_tower_unref0 (first);
	_gee_hazard_pointer_context_free0 (ctx);
}

static gpointer
gee_concurrent_set_real_first (GeeAbstractSortedSet* base)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GCompareDataFunc _tmp4_;
	gpointer _tmp4__target;
	gboolean _tmp5_;
	gpointer result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	prev = NULL;
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	curr = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	_tmp5_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp4_, _tmp4__target, &prev, &curr, (guint8) 0, FALSE);
	if (_tmp5_) {
		GeeConcurrentSetTower* _tmp6_;
		gconstpointer _tmp7_;
		gpointer _tmp8_;
		_tmp6_ = curr;
		_tmp7_ = _tmp6_->_data;
		_tmp8_ = ((_tmp7_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp7_) : ((gpointer) _tmp7_);
		result = _tmp8_;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
}

static gpointer
gee_concurrent_set_real_last (GeeAbstractSortedSet* base)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	gboolean found = FALSE;
	GeeConcurrentSetTower* _tmp8_;
	gconstpointer _tmp9_;
	gpointer _tmp10_;
	gpointer result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	prev = NULL;
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	curr = _tmp3_;
	found = FALSE;
	{
		gint i = 0;
		i = GEE_CONCURRENT_SET__MAX_HEIGHT;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp4_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				while (TRUE) {
					GCompareDataFunc _tmp6_;
					gpointer _tmp6__target;
					gboolean _tmp7_;
					_tmp6_ = self->priv->_cmp;
					_tmp6__target = self->priv->_cmp_target;
					_tmp7_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp6_, _tmp6__target, &prev, &curr, (guint8) 0, FALSE);
					if (!_tmp7_) {
						break;
					}
					found = TRUE;
				}
			}
		}
	}
	if (!found) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp8_ = curr;
	_tmp9_ = _tmp8_->_data;
	_tmp10_ = ((_tmp9_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp9_) : ((gpointer) _tmp9_);
	result = _tmp10_;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeIterator*
gee_concurrent_set_real_iterator_at (GeeAbstractSortedSet* base,
                                     gconstpointer element)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTowerIter curr = {0};
	GCompareDataFunc _tmp6_;
	gpointer _tmp6__target;
	GeeConcurrentSetTowerIter _tmp7_ = {0};
	gboolean _tmp8_;
	GeeConcurrentSetTowerIter _tmp9_;
	GeeConcurrentSetTower* _tmp10_;
	GeeConcurrentSetIterator* _tmp11_;
	GeeIterator* result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTower* _tmp4_;
				GeeConcurrentSetTower* _tmp5_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp4_ = self->priv->_head;
				_tmp5_ = _gee_concurrent_set_tower_ref0 (_tmp4_);
				_gee_concurrent_set_tower_unref0 (prev._iter[i]);
				prev._iter[i] = _tmp5_;
			}
		}
	}
	_tmp6_ = self->priv->_cmp;
	_tmp6__target = self->priv->_cmp_target;
	_tmp8_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp6_, _tmp6__target, element, &prev, &_tmp7_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	gee_concurrent_set_tower_iter_destroy (&curr);
	curr = _tmp7_;
	if (!_tmp8_) {
		result = NULL;
		gee_concurrent_set_tower_iter_destroy (&curr);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp9_ = curr;
	_tmp10_ = _tmp9_._iter[0];
	_tmp11_ = gee_concurrent_set_iterator_new_point_at (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, self, &prev, _tmp10_);
	result = (GeeIterator*) _tmp11_;
	gee_concurrent_set_tower_iter_destroy (&curr);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gpointer
gee_concurrent_set_real_lower (GeeAbstractSortedSet* base,
                               gconstpointer element)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GCompareDataFunc _tmp4_;
	gpointer _tmp4__target;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* _tmp6_;
	GeeConcurrentSetTower* _tmp7_;
	gconstpointer _tmp8_;
	gpointer _tmp9_;
	gpointer result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp4_, _tmp4__target, element, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_tmp5_ = prev;
	_tmp6_ = self->priv->_head;
	if (_tmp5_ == _tmp6_) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp7_ = prev;
	_tmp8_ = _tmp7_->_data;
	_tmp9_ = ((_tmp8_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp8_) : ((gpointer) _tmp8_);
	result = _tmp9_;
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gpointer
gee_concurrent_set_real_higher (GeeAbstractSortedSet* base,
                                gconstpointer element)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp4_;
	gpointer _tmp4__target;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	gboolean _tmp6_;
	GeeConcurrentSetTower* _tmp9_;
	GeeConcurrentSetTower* _tmp10_;
	gconstpointer _tmp11_;
	gpointer _tmp12_;
	gpointer result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	_tmp6_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp4_, _tmp4__target, element, &prev, &_tmp5_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp5_;
	if (_tmp6_) {
		GCompareDataFunc _tmp7_;
		gpointer _tmp7__target;
		gboolean _tmp8_;
		_tmp7_ = self->priv->_cmp;
		_tmp7__target = self->priv->_cmp_target;
		_tmp8_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, &next, (guint8) 0, FALSE);
		if (!_tmp8_) {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp9_ = next;
	if (_tmp9_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp10_ = next;
	_tmp11_ = _tmp10_->_data;
	_tmp12_ = ((_tmp11_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp11_) : ((gpointer) _tmp11_);
	result = _tmp12_;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gpointer
gee_concurrent_set_real_floor (GeeAbstractSortedSet* base,
                               gconstpointer element)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp4_;
	gpointer _tmp4__target;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	gboolean _tmp6_;
	gpointer result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	_tmp6_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp4_, _tmp4__target, element, &prev, &_tmp5_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp5_;
	if (_tmp6_) {
		GeeConcurrentSetTower* _tmp7_;
		gconstpointer _tmp8_;
		gpointer _tmp9_;
		_tmp7_ = next;
		_tmp8_ = _tmp7_->_data;
		_tmp9_ = ((_tmp8_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp8_) : ((gpointer) _tmp8_);
		result = _tmp9_;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTower* _tmp10_;
		GeeConcurrentSetTower* _tmp11_;
		_tmp10_ = prev;
		_tmp11_ = self->priv->_head;
		if (_tmp10_ != _tmp11_) {
			GeeConcurrentSetTower* _tmp12_;
			gconstpointer _tmp13_;
			gpointer _tmp14_;
			_tmp12_ = prev;
			_tmp13_ = _tmp12_->_data;
			_tmp14_ = ((_tmp13_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp13_) : ((gpointer) _tmp13_);
			result = _tmp14_;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		} else {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
}

static gpointer
gee_concurrent_set_real_ceil (GeeAbstractSortedSet* base,
                              gconstpointer element)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp4_;
	gpointer _tmp4__target;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp6_;
	GeeConcurrentSetTower* _tmp7_;
	gconstpointer _tmp8_;
	gpointer _tmp9_;
	gpointer result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp4_, _tmp4__target, element, &prev, &_tmp5_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp5_;
	_tmp6_ = next;
	if (_tmp6_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp7_ = next;
	_tmp8_ = _tmp7_->_data;
	_tmp9_ = ((_tmp8_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp8_) : ((gpointer) _tmp8_);
	result = _tmp9_;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeSortedSet*
gee_concurrent_set_real_head_set (GeeAbstractSortedSet* base,
                                  gconstpointer before)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetSubSet* _tmp3_;
	GeeSortedSet* _tmp4_;
	GeeSortedSet* result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = gee_concurrent_set_range_new_head (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, self, before);
	_tmp2_ = _tmp1_;
	_tmp3_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_);
	_tmp4_ = (GeeSortedSet*) _tmp3_;
	_gee_concurrent_set_range_unref0 (_tmp2_);
	result = _tmp4_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeSortedSet*
gee_concurrent_set_real_tail_set (GeeAbstractSortedSet* base,
                                  gconstpointer after)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetSubSet* _tmp3_;
	GeeSortedSet* _tmp4_;
	GeeSortedSet* result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = gee_concurrent_set_range_new_tail (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, self, after);
	_tmp2_ = _tmp1_;
	_tmp3_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_);
	_tmp4_ = (GeeSortedSet*) _tmp3_;
	_gee_concurrent_set_range_unref0 (_tmp2_);
	result = _tmp4_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeSortedSet*
gee_concurrent_set_real_sub_set (GeeAbstractSortedSet* base,
                                 gconstpointer from,
                                 gconstpointer to)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetSubSet* _tmp3_;
	GeeSortedSet* _tmp4_;
	GeeSortedSet* result;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = gee_concurrent_set_range_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, self, from, to);
	_tmp2_ = _tmp1_;
	_tmp3_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_);
	_tmp4_ = (GeeSortedSet*) _tmp3_;
	_gee_concurrent_set_range_unref0 (_tmp2_);
	result = _tmp4_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gconstpointer
gee_concurrent_set_max (GeeConcurrentSet* self,
                        gconstpointer a,
                        gconstpointer b,
                        gboolean* changed)
{
	gboolean _vala_changed = FALSE;
	GCompareDataFunc _tmp0_;
	gpointer _tmp0__target;
	gconstpointer _tmp1_ = NULL;
	gconstpointer result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_cmp;
	_tmp0__target = self->priv->_cmp_target;
	_vala_changed = _tmp0_ (a, b, _tmp0__target) < 0;
	if (_vala_changed) {
		_tmp1_ = b;
	} else {
		_tmp1_ = a;
	}
	result = _tmp1_;
	if (changed) {
		*changed = _vala_changed;
	}
	return result;
}

static gconstpointer
gee_concurrent_set_min (GeeConcurrentSet* self,
                        gconstpointer a,
                        gconstpointer b,
                        gboolean* changed)
{
	gboolean _vala_changed = FALSE;
	GCompareDataFunc _tmp0_;
	gpointer _tmp0__target;
	gconstpointer _tmp1_ = NULL;
	gconstpointer result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_cmp;
	_tmp0__target = self->priv->_cmp_target;
	_vala_changed = _tmp0_ (a, b, _tmp0__target) > 0;
	if (_vala_changed) {
		_tmp1_ = b;
	} else {
		_tmp1_ = a;
	}
	result = _tmp1_;
	if (changed) {
		*changed = _vala_changed;
	}
	return result;
}

static gint
gee_concurrent_set_real_get_size (GeeAbstractCollection* base)
{
	gint result;
	GeeConcurrentSet* self;
	gint _tmp0_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->priv->_size));
	result = _tmp0_;
	return result;
}

static gboolean
gee_concurrent_set_real_get_read_only (GeeAbstractCollection* base)
{
	gboolean result;
	GeeConcurrentSet* self;
	self = (GeeConcurrentSet*) base;
	result = FALSE;
	return result;
}

static inline gpointer
gee_concurrent_set_iterator_get_instance_private (GeeConcurrentSetIterator* self)
{
	return G_STRUCT_MEMBER_P (self, GeeConcurrentSetIterator_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static GeeConcurrentSetIterator*
gee_concurrent_set_iterator_construct (GType object_type,
                                       GType g_type,
                                       GBoxedCopyFunc g_dup_func,
                                       GDestroyNotify g_destroy_func,
                                       GeeConcurrentSet* cset,
                                       GeeConcurrentSetTower* head)
{
	GeeConcurrentSetIterator * self = NULL;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSet* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	g_return_val_if_fail (cset != NULL, NULL);
	g_return_val_if_fail (head != NULL, NULL);
	self = (GeeConcurrentSetIterator*) g_object_new (object_type, "g-type", g_type, "g-dup-func", g_dup_func, "g-destroy-func", g_destroy_func, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = _gee_concurrent_set_tower_ref0 (head);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp0_;
	_tmp1_ = _g_object_ref0 (cset);
	_g_object_unref0 (self->_set);
	self->_set = _tmp1_;
	_tmp2_ = self->_curr;
	_vala_assert (_tmp2_ != NULL, "_curr != null");
	return self;
}

static GeeConcurrentSetIterator*
gee_concurrent_set_iterator_new (GType g_type,
                                 GBoxedCopyFunc g_dup_func,
                                 GDestroyNotify g_destroy_func,
                                 GeeConcurrentSet* cset,
                                 GeeConcurrentSetTower* head)
{
	return gee_concurrent_set_iterator_construct (GEE_CONCURRENT_SET_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, cset, head);
}

static GeeConcurrentSetIterator*
gee_concurrent_set_iterator_construct_point_at (GType object_type,
                                                GType g_type,
                                                GBoxedCopyFunc g_dup_func,
                                                GDestroyNotify g_destroy_func,
                                                GeeConcurrentSet* cset,
                                                GeeConcurrentSetTowerIter* prev,
                                                GeeConcurrentSetTower* curr)
{
	GeeConcurrentSetIterator * self = NULL;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSet* _tmp1_;
	GeeConcurrentSetTowerIter _tmp2_;
	GeeConcurrentSetTowerIter _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetTower* _tmp5_;
	g_return_val_if_fail (cset != NULL, NULL);
	g_return_val_if_fail (prev != NULL, NULL);
	g_return_val_if_fail (curr != NULL, NULL);
	self = (GeeConcurrentSetIterator*) g_object_new (object_type, "g-type", g_type, "g-dup-func", g_dup_func, "g-destroy-func", g_destroy_func, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = _gee_concurrent_set_tower_ref0 (curr);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp0_;
	_tmp1_ = _g_object_ref0 (cset);
	_g_object_unref0 (self->_set);
	self->_set = _tmp1_;
	_tmp2_ = *prev;
	_tmp3_ = _tmp2_;
	gee_concurrent_set_tower_iter_copy (&_tmp3_, &_tmp4_);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp4_;
	_tmp5_ = self->_curr;
	_vala_assert (_tmp5_ != NULL, "_curr != null");
	return self;
}

static GeeConcurrentSetIterator*
gee_concurrent_set_iterator_new_point_at (GType g_type,
                                          GBoxedCopyFunc g_dup_func,
                                          GDestroyNotify g_destroy_func,
                                          GeeConcurrentSet* cset,
                                          GeeConcurrentSetTowerIter* prev,
                                          GeeConcurrentSetTower* curr)
{
	return gee_concurrent_set_iterator_construct_point_at (GEE_CONCURRENT_SET_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, cset, prev, curr);
}

static GeeConcurrentSetIterator*
gee_concurrent_set_iterator_construct_from_iterator (GType object_type,
                                                     GType g_type,
                                                     GBoxedCopyFunc g_dup_func,
                                                     GDestroyNotify g_destroy_func,
                                                     GeeConcurrentSetIterator* iter)
{
	GeeConcurrentSetIterator * self = NULL;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSet* _tmp2_;
	GeeConcurrentSet* _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_;
	GeeConcurrentSetTowerIter _tmp5_;
	GeeConcurrentSetTowerIter _tmp6_ = {0};
	g_return_val_if_fail (iter != NULL, NULL);
	self = (GeeConcurrentSetIterator*) g_object_new (object_type, "g-type", g_type, "g-dup-func", g_dup_func, "g-destroy-func", g_destroy_func, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = iter->_curr;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (_tmp0_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp1_;
	_tmp2_ = iter->_set;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp3_;
	_tmp4_ = iter->_prev;
	_tmp5_ = _tmp4_;
	gee_concurrent_set_tower_iter_copy (&_tmp5_, &_tmp6_);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp6_;
	self->_removed = iter->_removed;
	return self;
}

static GeeConcurrentSetIterator*
gee_concurrent_set_iterator_new_from_iterator (GType g_type,
                                               GBoxedCopyFunc g_dup_func,
                                               GDestroyNotify g_destroy_func,
                                               GeeConcurrentSetIterator* iter)
{
	return gee_concurrent_set_iterator_construct_from_iterator (GEE_CONCURRENT_SET_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, iter);
}

static gboolean
gee_concurrent_set_iterator_real_foreach (GeeTraversable* base,
                                          GeeForallFunc f,
                                          gpointer f_target)
{
	GeeConcurrentSetIterator * self;
	GeeConcurrentSetTower* _tmp0_;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp1_;
	GeeHazardPointerContext* _tmp2_;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetTowerIter _tmp4_;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* new_prev = NULL;
	GeeConcurrentSetTowerIter _tmp10_;
	GeeConcurrentSetTower* _tmp11_;
	GeeConcurrentSetTower* _tmp12_;
	GeeConcurrentSetTower* new_curr = NULL;
	GeeConcurrentSetTower* _tmp13_;
	GeeConcurrentSetTower* _tmp14_;
	GeeConcurrentSetTower* _tmp34_;
	gboolean result;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = self->_curr;
	_vala_assert (_tmp0_ != NULL, "_curr != null");
	_tmp1_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp1_;
	_tmp2_ = ctx;
	gee_utils_misc_unused (_tmp2_);
	_tmp4_ = self->_prev;
	_tmp5_ = _tmp4_._iter[0];
	if (_tmp5_ != NULL) {
		_tmp3_ = !self->_removed;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		GeeConcurrentSetTower* _tmp6_;
		gconstpointer _tmp7_;
		gpointer _tmp8_;
		_tmp6_ = self->_curr;
		_tmp7_ = _tmp6_->_data;
		_tmp8_ = ((_tmp7_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp7_) : ((gpointer) _tmp7_);
		if (!f (_tmp8_, f_target)) {
			GeeConcurrentSetTower* _tmp9_;
			_tmp9_ = self->_curr;
			_vala_assert (_tmp9_ != NULL, "_curr != null");
			result = FALSE;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp10_ = self->_prev;
	_tmp11_ = _tmp10_._iter[0];
	_tmp12_ = _gee_concurrent_set_tower_ref0 (_tmp11_);
	new_prev = _tmp12_;
	_tmp13_ = self->_curr;
	_tmp14_ = _gee_concurrent_set_tower_ref0 (_tmp13_);
	new_curr = _tmp14_;
	while (TRUE) {
		GeeConcurrentSet* _tmp15_;
		GCompareDataFunc _tmp16_;
		gpointer _tmp16__target;
		gboolean _tmp17_;
		GeeConcurrentSetTower* _tmp18_;
		GeeConcurrentSetTower* _tmp28_;
		GeeConcurrentSetTower* _tmp29_;
		GeeConcurrentSetTower* _tmp30_;
		gconstpointer _tmp31_;
		gpointer _tmp32_;
		_tmp15_ = self->_set;
		_tmp16_ = _tmp15_->priv->_cmp;
		_tmp16__target = _tmp15_->priv->_cmp_target;
		_tmp17_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp16_, _tmp16__target, &new_prev, &new_curr, (guint8) 0, FALSE);
		if (!_tmp17_) {
			break;
		}
		_tmp18_ = self->_curr;
		_vala_assert (_tmp18_ != NULL, "_curr != null");
		if (!self->_removed) {
			GeeConcurrentSetTower* _tmp19_;
			GeeConcurrentSetTower* _tmp20_;
			gint prev_height = 0;
			GeeConcurrentSetTowerIter _tmp21_;
			GeeConcurrentSetTower* _tmp22_;
			_tmp19_ = new_prev;
			_tmp20_ = _gee_concurrent_set_tower_ref0 (_tmp19_);
			_gee_concurrent_set_tower_unref0 (self->_prev._iter[0]);
			self->_prev._iter[0] = _tmp20_;
			_tmp21_ = self->_prev;
			_tmp22_ = _tmp21_._iter[0];
			prev_height = gee_concurrent_set_tower_get_height (_tmp22_);
			{
				gint i = 0;
				i = 1;
				{
					gboolean _tmp23_ = FALSE;
					_tmp23_ = TRUE;
					while (TRUE) {
						GeeConcurrentSetTowerIter _tmp25_;
						GeeConcurrentSetTower* _tmp26_;
						GeeConcurrentSetTower* _tmp27_;
						if (!_tmp23_) {
							gint _tmp24_;
							_tmp24_ = i;
							i = _tmp24_ + 1;
						}
						_tmp23_ = FALSE;
						if (!(i < prev_height)) {
							break;
						}
						_tmp25_ = self->_prev;
						_tmp26_ = _tmp25_._iter[0];
						_tmp27_ = _gee_concurrent_set_tower_ref0 (_tmp26_);
						_gee_concurrent_set_tower_unref0 (self->_prev._iter[i]);
						self->_prev._iter[i] = _tmp27_;
					}
				}
			}
		}
		_tmp28_ = new_curr;
		_tmp29_ = _gee_concurrent_set_tower_ref0 (_tmp28_);
		_gee_concurrent_set_tower_unref0 (self->_curr);
		self->_curr = _tmp29_;
		self->_removed = FALSE;
		_tmp30_ = self->_curr;
		_tmp31_ = _tmp30_->_data;
		_tmp32_ = ((_tmp31_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp31_) : ((gpointer) _tmp31_);
		if (!f (_tmp32_, f_target)) {
			GeeConcurrentSetTower* _tmp33_;
			_tmp33_ = self->_curr;
			_vala_assert (_tmp33_ != NULL, "_curr != null");
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp34_ = self->_curr;
	_vala_assert (_tmp34_ != NULL, "_curr != null");
	result = TRUE;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeIterator**
gee_concurrent_set_iterator_real_tee (GeeTraversable* base,
                                      guint forks,
                                      gint* result_length1)
{
	GeeConcurrentSetIterator * self;
	GeeIterator** result;
	self = (GeeConcurrentSetIterator*) base;
	if (forks == ((guint) 0)) {
		GeeIterator** _tmp0_;
		GeeIterator** _tmp1_;
		gint _tmp1__length1;
		_tmp0_ = g_new0 (GeeIterator*, 0 + 1);
		_tmp1_ = _tmp0_;
		_tmp1__length1 = 0;
		if (result_length1) {
			*result_length1 = _tmp1__length1;
		}
		result = _tmp1_;
		return result;
	} else {
		GeeIterator** _result_ = NULL;
		GeeIterator** _tmp2_;
		gint _result__length1;
		gint __result__size_;
		GeeIterator** _tmp3_;
		gint _tmp3__length1;
		GeeIterator* _tmp4_;
		GeeIterator** _tmp9_;
		gint _tmp9__length1;
		_tmp2_ = g_new0 (GeeIterator*, forks + 1);
		_result_ = _tmp2_;
		_result__length1 = forks;
		__result__size_ = _result__length1;
		_tmp3_ = _result_;
		_tmp3__length1 = _result__length1;
		_tmp4_ = _g_object_ref0 ((GeeIterator*) self);
		_g_object_unref0 (_tmp3_[0]);
		_tmp3_[0] = _tmp4_;
		{
			guint i = 0U;
			i = (guint) 1;
			{
				gboolean _tmp5_ = FALSE;
				_tmp5_ = TRUE;
				while (TRUE) {
					GeeIterator** _tmp7_;
					gint _tmp7__length1;
					GeeConcurrentSetIterator* _tmp8_;
					if (!_tmp5_) {
						guint _tmp6_;
						_tmp6_ = i;
						i = _tmp6_ + 1;
					}
					_tmp5_ = FALSE;
					if (!(i < forks)) {
						break;
					}
					_tmp7_ = _result_;
					_tmp7__length1 = _result__length1;
					_tmp8_ = gee_concurrent_set_iterator_new_from_iterator (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, self);
					_g_object_unref0 (_tmp7_[i]);
					_tmp7_[i] = (GeeIterator*) _tmp8_;
				}
			}
		}
		_tmp9_ = _result_;
		_tmp9__length1 = _result__length1;
		if (result_length1) {
			*result_length1 = _tmp9__length1;
		}
		result = _tmp9_;
		return result;
	}
}

static gboolean
gee_concurrent_set_iterator_real_next (GeeIterator* base)
{
	GeeConcurrentSetIterator * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* new_prev = NULL;
	GeeConcurrentSetTowerIter _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* _tmp4_;
	GeeConcurrentSetTower* new_curr = NULL;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* _tmp6_;
	gboolean success = FALSE;
	GeeConcurrentSet* _tmp7_;
	GCompareDataFunc _tmp8_;
	gpointer _tmp8__target;
	gboolean _tmp9_;
	GeeConcurrentSetTower* _tmp19_;
	gboolean result;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->_prev;
	_tmp3_ = _tmp2_._iter[0];
	_tmp4_ = _gee_concurrent_set_tower_ref0 (_tmp3_);
	new_prev = _tmp4_;
	_tmp5_ = self->_curr;
	_tmp6_ = _gee_concurrent_set_tower_ref0 (_tmp5_);
	new_curr = _tmp6_;
	_tmp7_ = self->_set;
	_tmp8_ = _tmp7_->priv->_cmp;
	_tmp8__target = _tmp7_->priv->_cmp_target;
	_tmp9_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp8_, _tmp8__target, &new_prev, &new_curr, (guint8) 0, FALSE);
	success = _tmp9_;
	if (success) {
		GeeConcurrentSetTower* _tmp18_;
		if (!self->_removed) {
			GeeConcurrentSetTower* _tmp10_;
			gint prev_height = 0;
			GeeConcurrentSetTowerIter _tmp11_;
			GeeConcurrentSetTower* _tmp12_;
			_tmp10_ = new_prev;
			new_prev = NULL;
			_gee_concurrent_set_tower_unref0 (self->_prev._iter[0]);
			self->_prev._iter[0] = _tmp10_;
			_tmp11_ = self->_prev;
			_tmp12_ = _tmp11_._iter[0];
			prev_height = gee_concurrent_set_tower_get_height (_tmp12_);
			{
				gint i = 0;
				i = 1;
				{
					gboolean _tmp13_ = FALSE;
					_tmp13_ = TRUE;
					while (TRUE) {
						GeeConcurrentSetTowerIter _tmp15_;
						GeeConcurrentSetTower* _tmp16_;
						GeeConcurrentSetTower* _tmp17_;
						if (!_tmp13_) {
							gint _tmp14_;
							_tmp14_ = i;
							i = _tmp14_ + 1;
						}
						_tmp13_ = FALSE;
						if (!(i < prev_height)) {
							break;
						}
						_tmp15_ = self->_prev;
						_tmp16_ = _tmp15_._iter[0];
						_tmp17_ = _gee_concurrent_set_tower_ref0 (_tmp16_);
						_gee_concurrent_set_tower_unref0 (self->_prev._iter[i]);
						self->_prev._iter[i] = _tmp17_;
					}
				}
			}
		}
		_tmp18_ = new_curr;
		new_curr = NULL;
		_gee_concurrent_set_tower_unref0 (self->_curr);
		self->_curr = _tmp18_;
		self->_removed = FALSE;
	}
	_tmp19_ = self->_curr;
	_vala_assert (_tmp19_ != NULL, "_curr != null");
	result = success;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gboolean
gee_concurrent_set_iterator_real_has_next (GeeIterator* base)
{
	GeeConcurrentSetIterator * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp4_;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSet* _tmp6_;
	GCompareDataFunc _tmp7_;
	gpointer _tmp7__target;
	gboolean _tmp8_;
	gboolean result;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->_prev;
	_tmp2_ = _tmp1_._iter[0];
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->_curr;
	_tmp5_ = _gee_concurrent_set_tower_ref0 (_tmp4_);
	curr = _tmp5_;
	_tmp6_ = self->_set;
	_tmp7_ = _tmp6_->priv->_cmp;
	_tmp7__target = _tmp6_->priv->_cmp_target;
	_tmp8_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, &curr, (guint8) 0, FALSE);
	result = _tmp8_;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gpointer
gee_concurrent_set_iterator_real_get (GeeIterator* base)
{
	GeeConcurrentSetIterator * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	gconstpointer _tmp3_;
	gpointer _tmp4_;
	gpointer result;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = self->_curr;
	_tmp3_ = _tmp2_->_data;
	_tmp4_ = ((_tmp3_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp3_) : ((gpointer) _tmp3_);
	result = _tmp4_;
	return result;
}

static void
gee_concurrent_set_iterator_real_remove (GeeIterator* base)
{
	GeeConcurrentSetIterator * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	GeeConcurrentSet* _tmp4_;
	GCompareDataFunc _tmp5_;
	gpointer _tmp5__target;
	GeeConcurrentSetTower* _tmp6_;
	gboolean _tmp7_;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_, "valid");
	_tmp4_ = self->_set;
	_tmp5_ = _tmp4_->priv->_cmp;
	_tmp5__target = _tmp4_->priv->_cmp_target;
	_tmp6_ = self->_curr;
	_tmp7_ = gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp5_, _tmp5__target, &self->_prev, _tmp6_);
	if (_tmp7_) {
		GeeConcurrentSet* _tmp8_;
		_tmp8_ = self->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp8_->priv->_size));
	}
	self->_removed = TRUE;
	_gee_hazard_pointer_context_free0 (ctx);
}

static gboolean
gee_concurrent_set_iterator_real_get_valid (GeeIterator* base)
{
	gboolean result;
	GeeConcurrentSetIterator* self;
	gboolean _tmp0_ = FALSE;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	self = (GeeConcurrentSetIterator*) base;
	_tmp1_ = self->_prev;
	_tmp2_ = _tmp1_._iter[0];
	if (_tmp2_ != NULL) {
		_tmp0_ = !self->_removed;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}

static gboolean
gee_concurrent_set_iterator_real_get_read_only (GeeIterator* base)
{
	gboolean result;
	GeeConcurrentSetIterator* self;
	self = (GeeConcurrentSetIterator*) base;
	result = TRUE;
	return result;
}

static void
gee_concurrent_set_iterator_class_init (GeeConcurrentSetIteratorClass * klass,
                                        gpointer klass_data)
{
	gee_concurrent_set_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeConcurrentSetIterator_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_iterator_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_iterator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_VALID_PROPERTY, gee_concurrent_set_iterator_properties[GEE_CONCURRENT_SET_ITERATOR_VALID_PROPERTY] = g_param_spec_boolean ("valid", "valid", "valid", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_READ_ONLY_PROPERTY, gee_concurrent_set_iterator_properties[GEE_CONCURRENT_SET_ITERATOR_READ_ONLY_PROPERTY] = g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static GType
gee_concurrent_set_iterator_gee_traversable_get_g_type (GeeConcurrentSetIterator* self)
{
	return self->priv->g_type;
}

static GBoxedCopyFunc
gee_concurrent_set_iterator_gee_traversable_get_g_dup_func (GeeConcurrentSetIterator* self)
{
	return self->priv->g_dup_func;
}

static GDestroyNotify
gee_concurrent_set_iterator_gee_traversable_get_g_destroy_func (GeeConcurrentSetIterator* self)
{
	return self->priv->g_destroy_func;
}

static void
gee_concurrent_set_iterator_gee_traversable_interface_init (GeeTraversableIface * iface,
                                                            gpointer iface_data)
{
	gee_concurrent_set_iterator_gee_traversable_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach = (gboolean (*) (GeeTraversable*, GeeForallFunc, gpointer)) gee_concurrent_set_iterator_real_foreach;
	iface->tee = (GeeIterator** (*) (GeeTraversable*, guint, gint*)) gee_concurrent_set_iterator_real_tee;
	iface->get_g_type = (GType (*) (GeeTraversable *)) gee_concurrent_set_iterator_gee_traversable_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc (*) (GeeTraversable *)) gee_concurrent_set_iterator_gee_traversable_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify (*) (GeeTraversable *)) gee_concurrent_set_iterator_gee_traversable_get_g_destroy_func;
}

static void
gee_concurrent_set_iterator_gee_iterator_interface_init (GeeIteratorIface * iface,
                                                         gpointer iface_data)
{
	gee_concurrent_set_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->next = (gboolean (*) (GeeIterator*)) gee_concurrent_set_iterator_real_next;
	iface->has_next = (gboolean (*) (GeeIterator*)) gee_concurrent_set_iterator_real_has_next;
	iface->get = (gpointer (*) (GeeIterator*)) gee_concurrent_set_iterator_real_get;
	iface->remove = (void (*) (GeeIterator*)) gee_concurrent_set_iterator_real_remove;
	iface->get_valid = gee_concurrent_set_iterator_real_get_valid;
	iface->get_read_only = gee_concurrent_set_iterator_real_get_read_only;
}

static void
gee_concurrent_set_iterator_instance_init (GeeConcurrentSetIterator * self,
                                           gpointer klass)
{
	self->priv = gee_concurrent_set_iterator_get_instance_private (self);
	self->_removed = FALSE;
}

static void
gee_concurrent_set_iterator_finalize (GObject * obj)
{
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	_g_object_unref0 (self->_set);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	G_OBJECT_CLASS (gee_concurrent_set_iterator_parent_class)->finalize (obj);
}

static GType
gee_concurrent_set_iterator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetIterator), 0, (GInstanceInitFunc) gee_concurrent_set_iterator_instance_init, NULL };
	static const GInterfaceInfo gee_traversable_info = { (GInterfaceInitFunc) gee_concurrent_set_iterator_gee_traversable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_concurrent_set_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType gee_concurrent_set_iterator_type_id;
	gee_concurrent_set_iterator_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeConcurrentSetIterator", &g_define_type_info, 0);
	g_type_add_interface_static (gee_concurrent_set_iterator_type_id, GEE_TYPE_TRAVERSABLE, &gee_traversable_info);
	g_type_add_interface_static (gee_concurrent_set_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
	GeeConcurrentSetIterator_private_offset = g_type_add_instance_private (gee_concurrent_set_iterator_type_id, sizeof (GeeConcurrentSetIteratorPrivate));
	return gee_concurrent_set_iterator_type_id;
}

static GType
gee_concurrent_set_iterator_get_type (void)
{
	static volatile gsize gee_concurrent_set_iterator_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_iterator_type_id__once)) {
		GType gee_concurrent_set_iterator_type_id;
		gee_concurrent_set_iterator_type_id = gee_concurrent_set_iterator_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_iterator_type_id__once, gee_concurrent_set_iterator_type_id);
	}
	return gee_concurrent_set_iterator_type_id__once;
}

static void
_vala_gee_concurrent_set_iterator_get_property (GObject * object,
                                                guint property_id,
                                                GValue * value,
                                                GParamSpec * pspec)
{
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_ITERATOR_VALID_PROPERTY:
		g_value_set_boolean (value, gee_iterator_get_valid ((GeeIterator*) self));
		break;
		case GEE_CONCURRENT_SET_ITERATOR_READ_ONLY_PROPERTY:
		g_value_set_boolean (value, gee_iterator_get_read_only ((GeeIterator*) self));
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_TYPE:
		g_value_set_gtype (value, self->priv->g_type);
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC:
		g_value_set_pointer (value, self->priv->g_dup_func);
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->g_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_concurrent_set_iterator_set_property (GObject * object,
                                                guint property_id,
                                                const GValue * value,
                                                GParamSpec * pspec)
{
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_ITERATOR_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
gee_concurrent_set_sub_set_get_instance_private (GeeConcurrentSetSubSet* self)
{
	return G_STRUCT_MEMBER_P (self, GeeConcurrentSetSubSet_private_offset);
}

static gpointer
_gee_concurrent_set_range_ref0 (gpointer self)
{
	return self ? gee_concurrent_set_range_ref (self) : NULL;
}

static GeeConcurrentSetSubSet*
gee_concurrent_set_sub_set_construct (GType object_type,
                                      GType g_type,
                                      GBoxedCopyFunc g_dup_func,
                                      GDestroyNotify g_destroy_func,
                                      GeeConcurrentSetRange* range)
{
	GeeConcurrentSetSubSet * self = NULL;
	GeeConcurrentSetRange* _tmp0_;
	g_return_val_if_fail (range != NULL, NULL);
	self = (GeeConcurrentSetSubSet*) gee_abstract_sorted_set_construct (object_type, g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = _gee_concurrent_set_range_ref0 (range);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	self->priv->_range = _tmp0_;
	return self;
}

static GeeConcurrentSetSubSet*
gee_concurrent_set_sub_set_new (GType g_type,
                                GBoxedCopyFunc g_dup_func,
                                GDestroyNotify g_destroy_func,
                                GeeConcurrentSetRange* range)
{
	return gee_concurrent_set_sub_set_construct (GEE_CONCURRENT_SET_TYPE_SUB_SET, g_type, g_dup_func, g_destroy_func, range);
}

static GeeIterator*
gee_concurrent_set_sub_set_real_iterator (GeeAbstractCollection* base)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetSubIterator* _tmp2_;
	GeeIterator* result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	_tmp2_ = gee_concurrent_set_sub_iterator_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp1_);
	result = (GeeIterator*) _tmp2_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gboolean
gee_concurrent_set_sub_set_real_contains (GeeAbstractCollection* base,
                                          gconstpointer item)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetRange* _tmp5_;
	GeeConcurrentSet* _tmp6_;
	GCompareDataFunc _tmp7_;
	gpointer _tmp7__target;
	gboolean _tmp8_;
	gboolean result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	if (!gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, item)) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp3_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_, NULL, &_tmp4_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp4_;
	_tmp5_ = self->priv->_range;
	_tmp6_ = _tmp5_->_set;
	_tmp7_ = _tmp6_->priv->_cmp;
	_tmp7__target = _tmp6_->priv->_cmp_target;
	_tmp8_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp7_, _tmp7__target, item, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	result = _tmp8_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gboolean
gee_concurrent_set_sub_set_real_add (GeeAbstractCollection* base,
                                     gconstpointer key)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GRand* rnd = NULL;
	GPrivate* _tmp5_;
	void* _tmp6_;
	GRand* _tmp7_;
	guint32 rand_int = 0U;
	GRand* _tmp11_;
	guint8 height = 0U;
	GeeConcurrentSetRange* _tmp12_;
	GeeConcurrentSet* _tmp13_;
	GCompareDataFunc _tmp14_;
	gpointer _tmp14__target;
	gboolean _tmp15_;
	GeeConcurrentSetTower* _result_ = NULL;
	GeeConcurrentSetRange* _tmp21_;
	GeeConcurrentSet* _tmp22_;
	GCompareDataFunc _tmp23_;
	gpointer _tmp23__target;
	GeeConcurrentSetTower* _tmp24_;
	GeeConcurrentSetTower* _tmp25_;
	GeeConcurrentSetTower* _tmp28_;
	gboolean result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	if (!gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, key)) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp3_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_, NULL, &_tmp4_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp4_;
	_tmp5_ = gee_concurrent_set_rand;
	_tmp6_ = g_private_get (_tmp5_);
	rnd = _tmp6_;
	_tmp7_ = rnd;
	if (_tmp7_ == NULL) {
		GPrivate* _tmp8_;
		GRand* _tmp9_;
		GRand* _tmp10_;
		_tmp8_ = gee_concurrent_set_rand;
		_tmp9_ = g_rand_new ();
		rnd = _tmp9_;
		_tmp10_ = rnd;
		g_private_set (_tmp8_, _tmp10_);
	}
	_tmp11_ = rnd;
	rand_int = (guint32) g_rand_int_range (_tmp11_, (gint32) 0, G_MAXINT32);
	height = (guint8) (1 + ((guint8) g_bit_nth_lsf ((gulong) (~rand_int), -1)));
	_tmp12_ = self->priv->_range;
	_tmp13_ = _tmp12_->_set;
	_tmp14_ = _tmp13_->priv->_cmp;
	_tmp14__target = _tmp13_->priv->_cmp_target;
	_tmp15_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp14_, _tmp14__target, key, &prev, NULL, (guint8) (height - 1), (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	if (_tmp15_) {
		result = FALSE;
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	{
		gint i = 0;
		i = height - 2;
		{
			gboolean _tmp16_ = FALSE;
			_tmp16_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTowerIter _tmp18_;
				GeeConcurrentSetTower* _tmp19_;
				GeeConcurrentSetTower* _tmp20_;
				if (!_tmp16_) {
					gint _tmp17_;
					_tmp17_ = i;
					i = _tmp17_ - 1;
				}
				_tmp16_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				_tmp18_ = prev;
				_tmp19_ = _tmp18_._iter[height - 1];
				_tmp20_ = _gee_concurrent_set_tower_ref0 (_tmp19_);
				_gee_concurrent_set_tower_unref0 (prev._iter[i]);
				prev._iter[i] = _tmp20_;
			}
		}
	}
	_tmp21_ = self->priv->_range;
	_tmp22_ = _tmp21_->_set;
	_tmp23_ = _tmp22_->priv->_cmp;
	_tmp23__target = _tmp22_->priv->_cmp_target;
	_tmp24_ = gee_concurrent_set_tower_insert (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp23_, _tmp23__target, &prev, key, (guint8) (height - 1));
	_result_ = _tmp24_;
	_tmp25_ = _result_;
	if (_tmp25_ != NULL) {
		GeeConcurrentSetRange* _tmp26_;
		GeeConcurrentSet* _tmp27_;
		_tmp26_ = self->priv->_range;
		_tmp27_ = _tmp26_->_set;
		g_atomic_int_inc ((volatile gint *) (&_tmp27_->priv->_size));
	}
	_tmp28_ = _result_;
	result = _tmp28_ != NULL;
	_gee_concurrent_set_tower_unref0 (_result_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gboolean
gee_concurrent_set_sub_set_real_remove (GeeAbstractCollection* base,
                                        gconstpointer key)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	gboolean _result_ = FALSE;
	GeeConcurrentSetRange* _tmp5_;
	GeeConcurrentSet* _tmp6_;
	GCompareDataFunc _tmp7_;
	gpointer _tmp7__target;
	gboolean _tmp8_;
	gboolean result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	if (!gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, key)) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp3_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_, NULL, &_tmp4_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp4_;
	_tmp5_ = self->priv->_range;
	_tmp6_ = _tmp5_->_set;
	_tmp7_ = _tmp6_->priv->_cmp;
	_tmp7__target = _tmp6_->priv->_cmp_target;
	_tmp8_ = gee_concurrent_set_tower_remove_key (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, key, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_result_ = _tmp8_;
	if (_result_) {
		GeeConcurrentSetRange* _tmp9_;
		GeeConcurrentSet* _tmp10_;
		_tmp9_ = self->priv->_range;
		_tmp10_ = _tmp9_->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp10_->priv->_size));
	}
	result = _result_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static void
gee_concurrent_set_sub_set_real_clear (GeeAbstractCollection* base)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTower* first = NULL;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, &_tmp3_, &_tmp4_);
	_gee_concurrent_set_tower_unref0 (first);
	first = _tmp3_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp4_;
	while (TRUE) {
		GeeConcurrentSetTower* _tmp5_;
		GeeConcurrentSetRange* _tmp6_;
		GeeConcurrentSet* _tmp7_;
		GCompareDataFunc _tmp8_;
		gpointer _tmp8__target;
		GeeConcurrentSetTower* _tmp9_;
		GeeConcurrentSetRange* _tmp10_;
		GeeConcurrentSetTower* _tmp11_ = NULL;
		GeeConcurrentSetTowerIter _tmp12_ = {0};
		_tmp5_ = first;
		if (!(_tmp5_ != NULL)) {
			break;
		}
		_tmp6_ = self->priv->_range;
		_tmp7_ = _tmp6_->_set;
		_tmp8_ = _tmp7_->priv->_cmp;
		_tmp8__target = _tmp7_->priv->_cmp_target;
		_tmp9_ = first;
		gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp8_, _tmp8__target, &prev, _tmp9_);
		_tmp10_ = self->priv->_range;
		gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp10_, &_tmp11_, &_tmp12_);
		_gee_concurrent_set_tower_unref0 (first);
		first = _tmp11_;
		gee_concurrent_set_tower_iter_destroy (&prev);
		prev = _tmp12_;
	}
	_gee_concurrent_set_tower_unref0 (first);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
}

static gpointer
gee_concurrent_set_sub_set_real_first (GeeAbstractSortedSet* base)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* first = NULL;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* _tmp4_;
	GeeConcurrentSetTower* _tmp5_;
	gconstpointer _tmp6_;
	gpointer _tmp7_;
	gpointer result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, &_tmp3_, NULL);
	_gee_concurrent_set_tower_unref0 (first);
	first = _tmp3_;
	_tmp4_ = first;
	if (_tmp4_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (first);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp5_ = first;
	_tmp6_ = _tmp5_->_data;
	_tmp7_ = ((_tmp6_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp6_) : ((gpointer) _tmp6_);
	result = _tmp7_;
	_gee_concurrent_set_tower_unref0 (first);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gpointer
gee_concurrent_set_sub_set_real_last (GeeAbstractSortedSet* base)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTowerIter _tmp3_ = {0};
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp21_;
	GeeConcurrentSetTower* _tmp22_;
	gconstpointer _tmp23_;
	gpointer _tmp24_;
	gpointer result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, NULL, &_tmp3_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp3_;
	curr = NULL;
	{
		gint i = 0;
		i = GEE_CONCURRENT_SET__MAX_HEIGHT - 1;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTower* _tmp6_;
				gboolean improved = FALSE;
				gboolean _tmp17_ = FALSE;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp4_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				_tmp6_ = curr;
				if (_tmp6_ == NULL) {
					GeeConcurrentSetTowerIter _tmp7_;
					GeeConcurrentSetTower* _tmp8_;
					GeeConcurrentSetTower* _tmp9_;
					gboolean _tmp10_ = FALSE;
					GeeConcurrentSetTower* _tmp11_;
					_tmp7_ = prev;
					_tmp8_ = _tmp7_._iter[i];
					_tmp9_ = gee_concurrent_set_tower_get_next (_tmp8_, (guint8) i);
					_gee_concurrent_set_tower_unref0 (curr);
					curr = _tmp9_;
					_tmp11_ = curr;
					if (_tmp11_ == NULL) {
						_tmp10_ = TRUE;
					} else {
						GeeConcurrentSetRange* _tmp12_;
						GeeConcurrentSetTower* _tmp13_;
						gconstpointer _tmp14_;
						_tmp12_ = self->priv->_range;
						_tmp13_ = curr;
						_tmp14_ = _tmp13_->_data;
						_tmp10_ = !gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp12_, _tmp14_);
					}
					if (_tmp10_) {
						_gee_concurrent_set_tower_unref0 (curr);
						curr = NULL;
						continue;
					}
				}
				improved = FALSE;
				while (TRUE) {
					GeeConcurrentSetRange* _tmp15_;
					gboolean _tmp16_;
					_tmp15_ = self->priv->_range;
					_tmp16_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp15_, &prev._iter[i], &curr, (guint8) i);
					if (!_tmp16_) {
						break;
					}
					improved = TRUE;
				}
				if (improved) {
					_tmp17_ = i > 0;
				} else {
					_tmp17_ = FALSE;
				}
				if (_tmp17_) {
					GeeConcurrentSetTowerIter _tmp18_;
					GeeConcurrentSetTower* _tmp19_;
					GeeConcurrentSetTower* _tmp20_;
					_tmp18_ = prev;
					_tmp19_ = _tmp18_._iter[i];
					_tmp20_ = _gee_concurrent_set_tower_ref0 (_tmp19_);
					_gee_concurrent_set_tower_unref0 (prev._iter[i - 1]);
					prev._iter[i - 1] = _tmp20_;
				}
			}
		}
	}
	_tmp21_ = curr;
	if (_tmp21_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp22_ = curr;
	_tmp23_ = _tmp22_->_data;
	_tmp24_ = ((_tmp23_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp23_) : ((gpointer) _tmp23_);
	result = _tmp24_;
	_gee_concurrent_set_tower_unref0 (curr);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeIterator*
gee_concurrent_set_sub_set_real_iterator_at (GeeAbstractSortedSet* base,
                                             gconstpointer element)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTowerIter next = {0};
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetRange* _tmp5_;
	GeeConcurrentSet* _tmp6_;
	GCompareDataFunc _tmp7_;
	gpointer _tmp7__target;
	GeeConcurrentSetTowerIter _tmp8_ = {0};
	gboolean _tmp9_;
	GeeConcurrentSetRange* _tmp10_;
	GeeConcurrentSetTowerIter _tmp11_;
	GeeConcurrentSetTower* _tmp12_;
	GeeConcurrentSetTower* _tmp13_;
	GeeConcurrentSetSubIterator* _tmp14_;
	GeeIterator* result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	if (!gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, element)) {
		result = NULL;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp3_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_, NULL, &_tmp4_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp4_;
	_tmp5_ = self->priv->_range;
	_tmp6_ = _tmp5_->_set;
	_tmp7_ = _tmp6_->priv->_cmp;
	_tmp7__target = _tmp6_->priv->_cmp_target;
	_tmp9_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp7_, _tmp7__target, element, &prev, &_tmp8_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	gee_concurrent_set_tower_iter_destroy (&next);
	next = _tmp8_;
	if (!_tmp9_) {
		result = NULL;
		gee_concurrent_set_tower_iter_destroy (&next);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp10_ = self->priv->_range;
	_tmp11_ = next;
	_tmp12_ = _tmp11_._iter[0];
	_tmp13_ = _gee_concurrent_set_tower_ref0 (_tmp12_);
	_tmp14_ = gee_concurrent_set_sub_iterator_new_point_at (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp10_, &prev, _tmp13_);
	result = (GeeIterator*) _tmp14_;
	gee_concurrent_set_tower_iter_destroy (&next);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gpointer
gee_concurrent_set_sub_set_real_lower (GeeAbstractSortedSet* base,
                                       gconstpointer element)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	gpointer result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	switch (gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, element)) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp3_;
			GeeConcurrentSetTowerIter _tmp4_ = {0};
			GeeConcurrentSetRange* _tmp5_;
			GeeConcurrentSet* _tmp6_;
			GCompareDataFunc _tmp7_;
			gpointer _tmp7__target;
			gboolean _tmp8_ = FALSE;
			GeeConcurrentSetTowerIter _tmp9_;
			GeeConcurrentSetTower* _tmp10_;
			GeeConcurrentSetRange* _tmp11_;
			GeeConcurrentSet* _tmp12_;
			GeeConcurrentSetTower* _tmp13_;
			GeeConcurrentSetTowerIter _tmp18_;
			GeeConcurrentSetTower* _tmp19_;
			gconstpointer _tmp20_;
			gpointer _tmp21_;
			_tmp3_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_, NULL, &_tmp4_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp4_;
			_tmp5_ = self->priv->_range;
			_tmp6_ = _tmp5_->_set;
			_tmp7_ = _tmp6_->priv->_cmp;
			_tmp7__target = _tmp6_->priv->_cmp_target;
			gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp7_, _tmp7__target, element, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			_tmp9_ = prev;
			_tmp10_ = _tmp9_._iter[0];
			_tmp11_ = self->priv->_range;
			_tmp12_ = _tmp11_->_set;
			_tmp13_ = _tmp12_->priv->_head;
			if (_tmp10_ == _tmp13_) {
				_tmp8_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp14_;
				GeeConcurrentSetTowerIter _tmp15_;
				GeeConcurrentSetTower* _tmp16_;
				gconstpointer _tmp17_;
				_tmp14_ = self->priv->_range;
				_tmp15_ = prev;
				_tmp16_ = _tmp15_._iter[0];
				_tmp17_ = _tmp16_->_data;
				_tmp8_ = !gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp14_, _tmp17_);
			}
			if (_tmp8_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp18_ = prev;
			_tmp19_ = _tmp18_._iter[0];
			_tmp20_ = _tmp19_->_data;
			_tmp21_ = ((_tmp20_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp20_) : ((gpointer) _tmp20_);
			result = _tmp21_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		{
			gpointer _tmp22_;
			_tmp22_ = gee_abstract_sorted_set_last ((GeeAbstractSortedSet*) self);
			result = _tmp22_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}

static gpointer
gee_concurrent_set_sub_set_real_higher (GeeAbstractSortedSet* base,
                                        gconstpointer element)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	gpointer result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	switch (gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, element)) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		{
			gpointer _tmp3_;
			_tmp3_ = gee_abstract_sorted_set_first ((GeeAbstractSortedSet*) self);
			result = _tmp3_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetRange* _tmp4_;
			GeeConcurrentSetTowerIter _tmp5_ = {0};
			GeeConcurrentSetRange* _tmp6_;
			GeeConcurrentSet* _tmp7_;
			GCompareDataFunc _tmp8_;
			gpointer _tmp8__target;
			GeeConcurrentSetTowerIter _tmp9_ = {0};
			gboolean _tmp10_;
			gboolean _tmp15_ = FALSE;
			GeeConcurrentSetTowerIter _tmp16_;
			GeeConcurrentSetTower* _tmp17_;
			GeeConcurrentSetTowerIter _tmp22_;
			GeeConcurrentSetTower* _tmp23_;
			gconstpointer _tmp24_;
			gpointer _tmp25_;
			_tmp4_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp4_, NULL, &_tmp5_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp5_;
			_tmp6_ = self->priv->_range;
			_tmp7_ = _tmp6_->_set;
			_tmp8_ = _tmp7_->priv->_cmp;
			_tmp8__target = _tmp7_->priv->_cmp_target;
			_tmp10_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp8_, _tmp8__target, element, &prev, &_tmp9_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp9_;
			if (_tmp10_) {
				GeeConcurrentSetRange* _tmp11_;
				GeeConcurrentSet* _tmp12_;
				GCompareDataFunc _tmp13_;
				gpointer _tmp13__target;
				gboolean _tmp14_;
				_tmp11_ = self->priv->_range;
				_tmp12_ = _tmp11_->_set;
				_tmp13_ = _tmp12_->priv->_cmp;
				_tmp13__target = _tmp12_->priv->_cmp_target;
				_tmp14_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp13_, _tmp13__target, &prev._iter[0], &curr._iter[0], (guint8) 0, FALSE);
				if (!_tmp14_) {
					result = NULL;
					gee_concurrent_set_tower_iter_destroy (&curr);
					gee_concurrent_set_tower_iter_destroy (&prev);
					_gee_hazard_pointer_context_free0 (ctx);
					return result;
				}
			}
			_tmp16_ = curr;
			_tmp17_ = _tmp16_._iter[0];
			if (_tmp17_ == NULL) {
				_tmp15_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp18_;
				GeeConcurrentSetTowerIter _tmp19_;
				GeeConcurrentSetTower* _tmp20_;
				gconstpointer _tmp21_;
				_tmp18_ = self->priv->_range;
				_tmp19_ = curr;
				_tmp20_ = _tmp19_._iter[0];
				_tmp21_ = _tmp20_->_data;
				_tmp15_ = !gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp18_, _tmp21_);
			}
			if (_tmp15_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&curr);
				gee_concurrent_set_tower_iter_destroy (&prev);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp22_ = curr;
			_tmp23_ = _tmp22_._iter[0];
			_tmp24_ = _tmp23_->_data;
			_tmp25_ = ((_tmp24_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp24_) : ((gpointer) _tmp24_);
			result = _tmp25_;
			gee_concurrent_set_tower_iter_destroy (&curr);
			gee_concurrent_set_tower_iter_destroy (&prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}

static gpointer
gee_concurrent_set_sub_set_real_floor (GeeAbstractSortedSet* base,
                                       gconstpointer element)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	gpointer result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	switch (gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, element)) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp3_;
			GeeConcurrentSetTowerIter _tmp4_ = {0};
			GeeConcurrentSetRange* _tmp5_;
			GeeConcurrentSet* _tmp6_;
			GCompareDataFunc _tmp7_;
			gpointer _tmp7__target;
			GeeConcurrentSetTowerIter _tmp8_ = {0};
			gboolean _tmp9_;
			gboolean _tmp11_ = FALSE;
			gboolean _tmp12_ = FALSE;
			GeeConcurrentSetTowerIter _tmp13_;
			GeeConcurrentSetTower* _tmp14_;
			GeeConcurrentSetTowerIter _tmp21_;
			GeeConcurrentSetTower* _tmp22_;
			gconstpointer _tmp23_;
			gpointer _tmp24_;
			_tmp3_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_, NULL, &_tmp4_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp4_;
			_tmp5_ = self->priv->_range;
			_tmp6_ = _tmp5_->_set;
			_tmp7_ = _tmp6_->priv->_cmp;
			_tmp7__target = _tmp6_->priv->_cmp_target;
			_tmp9_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp7_, _tmp7__target, element, &prev, &_tmp8_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp8_;
			if (!_tmp9_) {
				GeeConcurrentSetTower* _tmp10_;
				_tmp10_ = prev._iter[0];
				prev._iter[0] = NULL;
				_gee_concurrent_set_tower_unref0 (curr._iter[0]);
				curr._iter[0] = _tmp10_;
			}
			_tmp13_ = curr;
			_tmp14_ = _tmp13_._iter[0];
			if (_tmp14_ == NULL) {
				_tmp12_ = TRUE;
			} else {
				GeeConcurrentSetTowerIter _tmp15_;
				GeeConcurrentSetTower* _tmp16_;
				_tmp15_ = curr;
				_tmp16_ = _tmp15_._iter[0];
				_tmp12_ = gee_concurrent_set_tower_is_head (_tmp16_);
			}
			if (_tmp12_) {
				_tmp11_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp17_;
				GeeConcurrentSetTowerIter _tmp18_;
				GeeConcurrentSetTower* _tmp19_;
				gconstpointer _tmp20_;
				_tmp17_ = self->priv->_range;
				_tmp18_ = curr;
				_tmp19_ = _tmp18_._iter[0];
				_tmp20_ = _tmp19_->_data;
				_tmp11_ = !gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp17_, _tmp20_);
			}
			if (_tmp11_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				gee_concurrent_set_tower_iter_destroy (&curr);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp21_ = curr;
			_tmp22_ = _tmp21_._iter[0];
			_tmp23_ = _tmp22_->_data;
			_tmp24_ = ((_tmp23_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp23_) : ((gpointer) _tmp23_);
			result = _tmp24_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			gee_concurrent_set_tower_iter_destroy (&curr);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		{
			gpointer _tmp25_;
			_tmp25_ = gee_abstract_sorted_set_last ((GeeAbstractSortedSet*) self);
			result = _tmp25_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}

static gpointer
gee_concurrent_set_sub_set_real_ceil (GeeAbstractSortedSet* base,
                                      gconstpointer element)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	gpointer result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	switch (gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, element)) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		{
			gpointer _tmp3_;
			_tmp3_ = gee_abstract_sorted_set_first ((GeeAbstractSortedSet*) self);
			result = _tmp3_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp4_;
			GeeConcurrentSetTowerIter _tmp5_ = {0};
			GeeConcurrentSetRange* _tmp6_;
			GeeConcurrentSet* _tmp7_;
			GCompareDataFunc _tmp8_;
			gpointer _tmp8__target;
			GeeConcurrentSetTowerIter _tmp9_ = {0};
			gboolean _tmp10_ = FALSE;
			GeeConcurrentSetTowerIter _tmp11_;
			GeeConcurrentSetTower* _tmp12_;
			GeeConcurrentSetTowerIter _tmp17_;
			GeeConcurrentSetTower* _tmp18_;
			gconstpointer _tmp19_;
			gpointer _tmp20_;
			_tmp4_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp4_, NULL, &_tmp5_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp5_;
			_tmp6_ = self->priv->_range;
			_tmp7_ = _tmp6_->_set;
			_tmp8_ = _tmp7_->priv->_cmp;
			_tmp8__target = _tmp7_->priv->_cmp_target;
			gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp8_, _tmp8__target, element, &prev, &_tmp9_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp9_;
			_tmp11_ = curr;
			_tmp12_ = _tmp11_._iter[0];
			if (_tmp12_ == NULL) {
				_tmp10_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp13_;
				GeeConcurrentSetTowerIter _tmp14_;
				GeeConcurrentSetTower* _tmp15_;
				gconstpointer _tmp16_;
				_tmp13_ = self->priv->_range;
				_tmp14_ = curr;
				_tmp15_ = _tmp14_._iter[0];
				_tmp16_ = _tmp15_->_data;
				_tmp10_ = !gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp13_, _tmp16_);
			}
			if (_tmp10_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				gee_concurrent_set_tower_iter_destroy (&curr);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp17_ = curr;
			_tmp18_ = _tmp17_._iter[0];
			_tmp19_ = _tmp18_->_data;
			_tmp20_ = ((_tmp19_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp19_) : ((gpointer) _tmp19_);
			result = _tmp20_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			gee_concurrent_set_tower_iter_destroy (&curr);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}

static GeeSortedSet*
gee_concurrent_set_sub_set_real_head_set (GeeAbstractSortedSet* base,
                                          gconstpointer before)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetSubSet* _tmp4_;
	GeeSortedSet* _tmp5_;
	GeeSortedSet* result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	_tmp2_ = gee_concurrent_set_range_cut_tail (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp1_, before);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_);
	_tmp5_ = (GeeSortedSet*) _tmp4_;
	_gee_concurrent_set_range_unref0 (_tmp3_);
	result = _tmp5_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeSortedSet*
gee_concurrent_set_sub_set_real_tail_set (GeeAbstractSortedSet* base,
                                          gconstpointer after)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetSubSet* _tmp4_;
	GeeSortedSet* _tmp5_;
	GeeSortedSet* result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	_tmp2_ = gee_concurrent_set_range_cut_head (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp1_, after);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_);
	_tmp5_ = (GeeSortedSet*) _tmp4_;
	_gee_concurrent_set_range_unref0 (_tmp3_);
	result = _tmp5_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeSortedSet*
gee_concurrent_set_sub_set_real_sub_set (GeeAbstractSortedSet* base,
                                         gconstpointer from,
                                         gconstpointer to)
{
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetSubSet* _tmp4_;
	GeeSortedSet* _tmp5_;
	GeeSortedSet* result;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	_tmp2_ = gee_concurrent_set_range_cut (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp1_, from, to);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp3_);
	_tmp5_ = (GeeSortedSet*) _tmp4_;
	_gee_concurrent_set_range_unref0 (_tmp3_);
	result = _tmp5_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gint
gee_concurrent_set_sub_set_real_get_size (GeeAbstractCollection* base)
{
	gint result;
	GeeConcurrentSetSubSet* self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* _tmp4_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, &_tmp3_, NULL);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp3_;
	_tmp4_ = curr;
	if (_tmp4_ != NULL) {
		gint acc = 0;
		GeeConcurrentSetTower* prev = NULL;
		GeeConcurrentSetRange* _tmp5_;
		gpointer _tmp6_;
		acc = 1;
		_tmp5_ = self->priv->_range;
		_tmp6_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &_tmp5_->_bookmark._iter[0], (gsize) 0, NULL);
		prev = (GeeConcurrentSetTower*) _tmp6_;
		while (TRUE) {
			GeeConcurrentSetRange* _tmp7_;
			gboolean _tmp8_;
			gint _tmp9_;
			_tmp7_ = self->priv->_range;
			_tmp8_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp7_, &prev, &curr, (guint8) 0);
			if (!_tmp8_) {
				break;
			}
			_tmp9_ = acc;
			acc = _tmp9_ + 1;
		}
		result = acc;
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		result = 0;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
}

static gboolean
gee_concurrent_set_sub_set_get_is_empty (GeeConcurrentSetSubSet* self)
{
	gboolean result;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp1_, &_tmp2_, NULL);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp2_;
	result = curr != NULL;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static gboolean
gee_concurrent_set_sub_set_real_get_read_only (GeeAbstractCollection* base)
{
	gboolean result;
	GeeConcurrentSetSubSet* self;
	self = (GeeConcurrentSetSubSet*) base;
	result = FALSE;
	return result;
}

static void
gee_concurrent_set_sub_set_class_init (GeeConcurrentSetSubSetClass * klass,
                                       gpointer klass_data)
{
	gee_concurrent_set_sub_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeConcurrentSetSubSet_private_offset);
	((GeeAbstractCollectionClass *) klass)->iterator = (GeeIterator* (*) (GeeAbstractCollection*)) gee_concurrent_set_sub_set_real_iterator;
	((GeeAbstractCollectionClass *) klass)->contains = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_concurrent_set_sub_set_real_contains;
	((GeeAbstractCollectionClass *) klass)->add = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_concurrent_set_sub_set_real_add;
	((GeeAbstractCollectionClass *) klass)->remove = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_concurrent_set_sub_set_real_remove;
	((GeeAbstractCollectionClass *) klass)->clear = (void (*) (GeeAbstractCollection*)) gee_concurrent_set_sub_set_real_clear;
	((GeeAbstractSortedSetClass *) klass)->first = (gpointer (*) (GeeAbstractSortedSet*)) gee_concurrent_set_sub_set_real_first;
	((GeeAbstractSortedSetClass *) klass)->last = (gpointer (*) (GeeAbstractSortedSet*)) gee_concurrent_set_sub_set_real_last;
	((GeeAbstractSortedSetClass *) klass)->iterator_at = (GeeIterator* (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_sub_set_real_iterator_at;
	((GeeAbstractSortedSetClass *) klass)->lower = (gpointer (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_sub_set_real_lower;
	((GeeAbstractSortedSetClass *) klass)->higher = (gpointer (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_sub_set_real_higher;
	((GeeAbstractSortedSetClass *) klass)->floor = (gpointer (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_sub_set_real_floor;
	((GeeAbstractSortedSetClass *) klass)->ceil = (gpointer (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_sub_set_real_ceil;
	((GeeAbstractSortedSetClass *) klass)->head_set = (GeeSortedSet* (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_sub_set_real_head_set;
	((GeeAbstractSortedSetClass *) klass)->tail_set = (GeeSortedSet* (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_sub_set_real_tail_set;
	((GeeAbstractSortedSetClass *) klass)->sub_set = (GeeSortedSet* (*) (GeeAbstractSortedSet*, gconstpointer, gconstpointer)) gee_concurrent_set_sub_set_real_sub_set;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_concurrent_set_sub_set_real_get_size;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_read_only = gee_concurrent_set_sub_set_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_sub_set_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_sub_set_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_sub_set_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_SIZE_PROPERTY, gee_concurrent_set_sub_set_properties[GEE_CONCURRENT_SET_SUB_SET_SIZE_PROPERTY] = g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY_PROPERTY, gee_concurrent_set_sub_set_properties[GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY_PROPERTY] = g_param_spec_boolean ("is-empty", "is-empty", "is-empty", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_READ_ONLY_PROPERTY, gee_concurrent_set_sub_set_properties[GEE_CONCURRENT_SET_SUB_SET_READ_ONLY_PROPERTY] = g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
gee_concurrent_set_sub_set_instance_init (GeeConcurrentSetSubSet * self,
                                          gpointer klass)
{
	self->priv = gee_concurrent_set_sub_set_get_instance_private (self);
}

static void
gee_concurrent_set_sub_set_finalize (GObject * obj)
{
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	G_OBJECT_CLASS (gee_concurrent_set_sub_set_parent_class)->finalize (obj);
}

static GType
gee_concurrent_set_sub_set_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetSubSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_sub_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetSubSet), 0, (GInstanceInitFunc) gee_concurrent_set_sub_set_instance_init, NULL };
	GType gee_concurrent_set_sub_set_type_id;
	gee_concurrent_set_sub_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_SORTED_SET, "GeeConcurrentSetSubSet", &g_define_type_info, 0);
	GeeConcurrentSetSubSet_private_offset = g_type_add_instance_private (gee_concurrent_set_sub_set_type_id, sizeof (GeeConcurrentSetSubSetPrivate));
	return gee_concurrent_set_sub_set_type_id;
}

static GType
gee_concurrent_set_sub_set_get_type (void)
{
	static volatile gsize gee_concurrent_set_sub_set_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_sub_set_type_id__once)) {
		GType gee_concurrent_set_sub_set_type_id;
		gee_concurrent_set_sub_set_type_id = gee_concurrent_set_sub_set_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_sub_set_type_id__once, gee_concurrent_set_sub_set_type_id);
	}
	return gee_concurrent_set_sub_set_type_id__once;
}

static void
_vala_gee_concurrent_set_sub_set_get_property (GObject * object,
                                               guint property_id,
                                               GValue * value,
                                               GParamSpec * pspec)
{
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_SET_SIZE_PROPERTY:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		case GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY_PROPERTY:
		g_value_set_boolean (value, gee_concurrent_set_sub_set_get_is_empty (self));
		break;
		case GEE_CONCURRENT_SET_SUB_SET_READ_ONLY_PROPERTY:
		g_value_set_boolean (value, gee_abstract_collection_get_read_only ((GeeAbstractCollection*) self));
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_TYPE:
		g_value_set_gtype (value, self->priv->g_type);
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC:
		g_value_set_pointer (value, self->priv->g_dup_func);
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->g_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_concurrent_set_sub_set_set_property (GObject * object,
                                               guint property_id,
                                               const GValue * value,
                                               GParamSpec * pspec)
{
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_SET_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
gee_concurrent_set_sub_iterator_get_instance_private (GeeConcurrentSetSubIterator* self)
{
	return G_STRUCT_MEMBER_P (self, GeeConcurrentSetSubIterator_private_offset);
}

static GeeConcurrentSetSubIterator*
gee_concurrent_set_sub_iterator_construct (GType object_type,
                                           GType g_type,
                                           GBoxedCopyFunc g_dup_func,
                                           GDestroyNotify g_destroy_func,
                                           GeeConcurrentSetRange* range)
{
	GeeConcurrentSetSubIterator * self = NULL;
	GeeConcurrentSetRange* _tmp0_;
	g_return_val_if_fail (range != NULL, NULL);
	self = (GeeConcurrentSetSubIterator*) g_object_new (object_type, "g-type", g_type, "g-dup-func", g_dup_func, "g-destroy-func", g_destroy_func, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, range, NULL, NULL);
	_tmp0_ = _gee_concurrent_set_range_ref0 (range);
	_gee_concurrent_set_range_unref0 (self->_range);
	self->_range = _tmp0_;
	return self;
}

static GeeConcurrentSetSubIterator*
gee_concurrent_set_sub_iterator_new (GType g_type,
                                     GBoxedCopyFunc g_dup_func,
                                     GDestroyNotify g_destroy_func,
                                     GeeConcurrentSetRange* range)
{
	return gee_concurrent_set_sub_iterator_construct (GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, g_type, g_dup_func, g_destroy_func, range);
}

static GeeConcurrentSetSubIterator*
gee_concurrent_set_sub_iterator_construct_point_at (GType object_type,
                                                    GType g_type,
                                                    GBoxedCopyFunc g_dup_func,
                                                    GDestroyNotify g_destroy_func,
                                                    GeeConcurrentSetRange* range,
                                                    GeeConcurrentSetTowerIter* prev,
                                                    GeeConcurrentSetTower* curr)
{
	GeeConcurrentSetSubIterator * self = NULL;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTowerIter _tmp2_;
	GeeConcurrentSetTowerIter _tmp3_ = {0};
	GeeConcurrentSetTower* _tmp4_;
	g_return_val_if_fail (range != NULL, NULL);
	g_return_val_if_fail (prev != NULL, NULL);
	g_return_val_if_fail (curr != NULL, NULL);
	self = (GeeConcurrentSetSubIterator*) g_object_new (object_type, "g-type", g_type, "g-dup-func", g_dup_func, "g-destroy-func", g_destroy_func, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, range, NULL, NULL);
	_tmp0_ = _gee_concurrent_set_range_ref0 (range);
	_gee_concurrent_set_range_unref0 (self->_range);
	self->_range = _tmp0_;
	_tmp1_ = *prev;
	_tmp2_ = _tmp1_;
	gee_concurrent_set_tower_iter_copy (&_tmp2_, &_tmp3_);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp3_;
	_tmp4_ = _gee_concurrent_set_tower_ref0 (curr);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp4_;
	_gee_concurrent_set_tower_unref0 (curr);
	return self;
}

static GeeConcurrentSetSubIterator*
gee_concurrent_set_sub_iterator_new_point_at (GType g_type,
                                              GBoxedCopyFunc g_dup_func,
                                              GDestroyNotify g_destroy_func,
                                              GeeConcurrentSetRange* range,
                                              GeeConcurrentSetTowerIter* prev,
                                              GeeConcurrentSetTower* curr)
{
	return gee_concurrent_set_sub_iterator_construct_point_at (GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, g_type, g_dup_func, g_destroy_func, range, prev, curr);
}

static GeeConcurrentSetSubIterator*
gee_concurrent_set_sub_iterator_construct_from_iterator (GType object_type,
                                                         GType g_type,
                                                         GBoxedCopyFunc g_dup_func,
                                                         GDestroyNotify g_destroy_func,
                                                         GeeConcurrentSetSubIterator* iter)
{
	GeeConcurrentSetSubIterator * self = NULL;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTowerIter _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_;
	GeeConcurrentSetTowerIter _tmp5_ = {0};
	GeeConcurrentSetTower* _tmp6_;
	GeeConcurrentSetTower* _tmp7_;
	g_return_val_if_fail (iter != NULL, NULL);
	self = (GeeConcurrentSetSubIterator*) g_object_new (object_type, "g-type", g_type, "g-dup-func", g_dup_func, "g-destroy-func", g_destroy_func, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = iter->_range;
	gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp0_, NULL, NULL);
	_tmp1_ = iter->_range;
	_tmp2_ = _gee_concurrent_set_range_ref0 (_tmp1_);
	_gee_concurrent_set_range_unref0 (self->_range);
	self->_range = _tmp2_;
	_tmp3_ = iter->_prev;
	_tmp4_ = _tmp3_;
	gee_concurrent_set_tower_iter_copy (&_tmp4_, &_tmp5_);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp5_;
	_tmp6_ = iter->_curr;
	_tmp7_ = _gee_concurrent_set_tower_ref0 (_tmp6_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp7_;
	self->_removed = iter->_removed;
	return self;
}

static GeeConcurrentSetSubIterator*
gee_concurrent_set_sub_iterator_new_from_iterator (GType g_type,
                                                   GBoxedCopyFunc g_dup_func,
                                                   GDestroyNotify g_destroy_func,
                                                   GeeConcurrentSetSubIterator* iter)
{
	return gee_concurrent_set_sub_iterator_construct_from_iterator (GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, g_type, g_dup_func, g_destroy_func, iter);
}

static gboolean
gee_concurrent_set_sub_iterator_real_foreach (GeeTraversable* base,
                                              GeeForallFunc f,
                                              gpointer f_target)
{
	GeeConcurrentSetSubIterator * self;
	GeeConcurrentSetTower* _tmp0_;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp1_;
	GeeHazardPointerContext* _tmp2_;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetTowerIter _tmp4_;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* new_prev = NULL;
	GeeConcurrentSetTowerIter _tmp10_;
	GeeConcurrentSetTower* _tmp11_;
	GeeConcurrentSetTower* _tmp12_;
	GeeConcurrentSetTower* new_curr = NULL;
	GeeConcurrentSetTower* _tmp13_;
	GeeConcurrentSetTower* _tmp14_;
	GeeConcurrentSetTower* _tmp31_;
	gboolean result;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = self->_curr;
	_vala_assert (_tmp0_ != NULL, "_curr != null");
	_tmp1_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp1_;
	_tmp2_ = ctx;
	gee_utils_misc_unused (_tmp2_);
	if (!gee_concurrent_set_sub_iterator_begin (self)) {
		result = TRUE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp4_ = self->_prev;
	_tmp5_ = _tmp4_._iter[0];
	if (_tmp5_ != NULL) {
		_tmp3_ = !self->_removed;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		GeeConcurrentSetTower* _tmp6_;
		gconstpointer _tmp7_;
		gpointer _tmp8_;
		_tmp6_ = self->_curr;
		_tmp7_ = _tmp6_->_data;
		_tmp8_ = ((_tmp7_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp7_) : ((gpointer) _tmp7_);
		if (!f (_tmp8_, f_target)) {
			GeeConcurrentSetTower* _tmp9_;
			_tmp9_ = self->_curr;
			_vala_assert (_tmp9_ != NULL, "_curr != null");
			result = FALSE;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp10_ = self->_prev;
	_tmp11_ = _tmp10_._iter[0];
	_tmp12_ = _gee_concurrent_set_tower_ref0 (_tmp11_);
	new_prev = _tmp12_;
	_tmp13_ = self->_curr;
	_tmp14_ = _gee_concurrent_set_tower_ref0 (_tmp13_);
	new_curr = _tmp14_;
	while (TRUE) {
		GeeConcurrentSetRange* _tmp15_;
		gboolean _tmp16_;
		GeeConcurrentSetTower* _tmp17_;
		GeeConcurrentSetTower* _tmp18_;
		gconstpointer _tmp19_;
		gpointer _tmp20_;
		GeeConcurrentSetTower* _tmp30_;
		_tmp15_ = self->_range;
		_tmp16_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp15_, &new_prev, &new_curr, (guint8) 0);
		if (!_tmp16_) {
			break;
		}
		_tmp17_ = self->_curr;
		_vala_assert (_tmp17_ != NULL, "_curr != null");
		_tmp18_ = self->_curr;
		_tmp19_ = _tmp18_->_data;
		_tmp20_ = ((_tmp19_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp19_) : ((gpointer) _tmp19_);
		if (!f (_tmp20_, f_target)) {
			GeeConcurrentSetTower* _tmp21_;
			_tmp21_ = self->_curr;
			_vala_assert (_tmp21_ != NULL, "_curr != null");
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		if (!self->_removed) {
			GeeConcurrentSetTower* _tmp22_;
			gint prev_height = 0;
			GeeConcurrentSetTowerIter _tmp23_;
			GeeConcurrentSetTower* _tmp24_;
			_tmp22_ = new_prev;
			new_prev = NULL;
			_gee_concurrent_set_tower_unref0 (self->_prev._iter[0]);
			self->_prev._iter[0] = _tmp22_;
			_tmp23_ = self->_prev;
			_tmp24_ = _tmp23_._iter[0];
			prev_height = gee_concurrent_set_tower_get_height (_tmp24_);
			{
				gint i = 0;
				i = 1;
				{
					gboolean _tmp25_ = FALSE;
					_tmp25_ = TRUE;
					while (TRUE) {
						GeeConcurrentSetTowerIter _tmp27_;
						GeeConcurrentSetTower* _tmp28_;
						GeeConcurrentSetTower* _tmp29_;
						if (!_tmp25_) {
							gint _tmp26_;
							_tmp26_ = i;
							i = _tmp26_ + 1;
						}
						_tmp25_ = FALSE;
						if (!(i < prev_height)) {
							break;
						}
						_tmp27_ = self->_prev;
						_tmp28_ = _tmp27_._iter[0];
						_tmp29_ = _gee_concurrent_set_tower_ref0 (_tmp28_);
						_gee_concurrent_set_tower_unref0 (self->_prev._iter[i]);
						self->_prev._iter[i] = _tmp29_;
					}
				}
			}
		}
		_tmp30_ = new_curr;
		new_curr = NULL;
		_gee_concurrent_set_tower_unref0 (self->_curr);
		self->_curr = _tmp30_;
		self->_removed = FALSE;
	}
	_tmp31_ = self->_curr;
	_vala_assert (_tmp31_ != NULL, "_curr != null");
	result = TRUE;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}

static GeeIterator**
gee_concurrent_set_sub_iterator_real_tee (GeeTraversable* base,
                                          guint forks,
                                          gint* result_length1)
{
	GeeConcurrentSetSubIterator * self;
	GeeIterator** result;
	self = (GeeConcurrentSetSubIterator*) base;
	if (forks == ((guint) 0)) {
		GeeIterator** _tmp0_;
		GeeIterator** _tmp1_;
		gint _tmp1__length1;
		_tmp0_ = g_new0 (GeeIterator*, 0 + 1);
		_tmp1_ = _tmp0_;
		_tmp1__length1 = 0;
		if (result_length1) {
			*result_length1 = _tmp1__length1;
		}
		result = _tmp1_;
		return result;
	} else {
		GeeIterator** _result_ = NULL;
		GeeIterator** _tmp2_;
		gint _result__length1;
		gint __result__size_;
		GeeIterator** _tmp3_;
		gint _tmp3__length1;
		GeeIterator* _tmp4_;
		GeeIterator** _tmp9_;
		gint _tmp9__length1;
		_tmp2_ = g_new0 (GeeIterator*, forks + 1);
		_result_ = _tmp2_;
		_result__length1 = forks;
		__result__size_ = _result__length1;
		_tmp3_ = _result_;
		_tmp3__length1 = _result__length1;
		_tmp4_ = _g_object_ref0 ((GeeIterator*) self);
		_g_object_unref0 (_tmp3_[0]);
		_tmp3_[0] = _tmp4_;
		{
			guint i = 0U;
			i = (guint) 1;
			{
				gboolean _tmp5_ = FALSE;
				_tmp5_ = TRUE;
				while (TRUE) {
					GeeIterator** _tmp7_;
					gint _tmp7__length1;
					GeeConcurrentSetSubIterator* _tmp8_;
					if (!_tmp5_) {
						guint _tmp6_;
						_tmp6_ = i;
						i = _tmp6_ + 1;
					}
					_tmp5_ = FALSE;
					if (!(i < forks)) {
						break;
					}
					_tmp7_ = _result_;
					_tmp7__length1 = _result__length1;
					_tmp8_ = gee_concurrent_set_sub_iterator_new_from_iterator (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, self);
					_g_object_unref0 (_tmp7_[i]);
					_tmp7_[i] = (GeeIterator*) _tmp8_;
				}
			}
		}
		_tmp9_ = _result_;
		_tmp9__length1 = _result__length1;
		if (result_length1) {
			*result_length1 = _tmp9__length1;
		}
		result = _tmp9_;
		return result;
	}
}

static gboolean
gee_concurrent_set_sub_iterator_real_next (GeeIterator* base)
{
	GeeConcurrentSetSubIterator * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTowerIter _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	gboolean result;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->_prev;
	_tmp3_ = _tmp2_._iter[0];
	if (_tmp3_ == NULL) {
		result = gee_concurrent_set_sub_iterator_begin (self);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTower* new_prev = NULL;
		GeeConcurrentSetTowerIter _tmp4_;
		GeeConcurrentSetTower* _tmp5_;
		GeeConcurrentSetTower* _tmp6_;
		GeeConcurrentSetTower* new_curr = NULL;
		GeeConcurrentSetTower* _tmp7_;
		GeeConcurrentSetTower* _tmp8_;
		GeeConcurrentSetRange* _tmp9_;
		gboolean _tmp10_;
		_tmp4_ = self->_prev;
		_tmp5_ = _tmp4_._iter[0];
		_tmp6_ = _gee_concurrent_set_tower_ref0 (_tmp5_);
		new_prev = _tmp6_;
		_tmp7_ = self->_curr;
		_tmp8_ = _gee_concurrent_set_tower_ref0 (_tmp7_);
		new_curr = _tmp8_;
		_tmp9_ = self->_range;
		_tmp10_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp9_, &new_prev, &new_curr, (guint8) 0);
		if (_tmp10_) {
			GeeConcurrentSetTower* _tmp19_;
			if (!self->_removed) {
				GeeConcurrentSetTower* _tmp11_;
				gint prev_height = 0;
				GeeConcurrentSetTowerIter _tmp12_;
				GeeConcurrentSetTower* _tmp13_;
				_tmp11_ = new_prev;
				new_prev = NULL;
				_gee_concurrent_set_tower_unref0 (self->_prev._iter[0]);
				self->_prev._iter[0] = _tmp11_;
				_tmp12_ = self->_prev;
				_tmp13_ = _tmp12_._iter[0];
				prev_height = gee_concurrent_set_tower_get_height (_tmp13_);
				{
					gint i = 0;
					i = 1;
					{
						gboolean _tmp14_ = FALSE;
						_tmp14_ = TRUE;
						while (TRUE) {
							GeeConcurrentSetTowerIter _tmp16_;
							GeeConcurrentSetTower* _tmp17_;
							GeeConcurrentSetTower* _tmp18_;
							if (!_tmp14_) {
								gint _tmp15_;
								_tmp15_ = i;
								i = _tmp15_ + 1;
							}
							_tmp14_ = FALSE;
							if (!(i < prev_height)) {
								break;
							}
							_tmp16_ = self->_prev;
							_tmp17_ = _tmp16_._iter[0];
							_tmp18_ = _gee_concurrent_set_tower_ref0 (_tmp17_);
							_gee_concurrent_set_tower_unref0 (self->_prev._iter[i]);
							self->_prev._iter[i] = _tmp18_;
						}
					}
				}
			}
			_tmp19_ = new_curr;
			new_curr = NULL;
			_gee_concurrent_set_tower_unref0 (self->_curr);
			self->_curr = _tmp19_;
			self->_removed = FALSE;
			result = TRUE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		} else {
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		_gee_concurrent_set_tower_unref0 (new_curr);
		_gee_concurrent_set_tower_unref0 (new_prev);
	}
}

static gboolean
gee_concurrent_set_sub_iterator_real_has_next (GeeIterator* base)
{
	GeeConcurrentSetSubIterator * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeConcurrentSetTowerIter _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	gboolean result;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->_prev;
	_tmp3_ = _tmp2_._iter[0];
	if (_tmp3_ == NULL) {
		GeeConcurrentSetTower* next = NULL;
		GeeConcurrentSetRange* _tmp4_;
		GeeConcurrentSetTower* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		GeeConcurrentSetTower* _tmp7_;
		GeeConcurrentSetTower* _tmp10_;
		_tmp4_ = self->_range;
		gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp4_, &_tmp5_, NULL);
		_gee_concurrent_set_tower_unref0 (next);
		next = _tmp5_;
		_tmp7_ = next;
		if (_tmp7_ != NULL) {
			GeeConcurrentSetRange* _tmp8_;
			GeeConcurrentSetTower* _tmp9_;
			_tmp8_ = self->_range;
			_tmp9_ = next;
			_tmp6_ = gee_concurrent_set_range_beyond (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp8_, _tmp9_);
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			_gee_concurrent_set_tower_unref0 (next);
			next = NULL;
		}
		_tmp10_ = next;
		result = _tmp10_ != NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTower* new_prev = NULL;
		GeeConcurrentSetTowerIter _tmp11_;
		GeeConcurrentSetTower* _tmp12_;
		GeeConcurrentSetTower* _tmp13_;
		GeeConcurrentSetTower* new_curr = NULL;
		GeeConcurrentSetTower* _tmp14_;
		GeeConcurrentSetTower* _tmp15_;
		GeeConcurrentSetRange* _tmp16_;
		gboolean _tmp17_;
		_tmp11_ = self->_prev;
		_tmp12_ = _tmp11_._iter[0];
		_tmp13_ = _gee_concurrent_set_tower_ref0 (_tmp12_);
		new_prev = _tmp13_;
		_tmp14_ = self->_curr;
		_tmp15_ = _gee_concurrent_set_tower_ref0 (_tmp14_);
		new_curr = _tmp15_;
		_tmp16_ = self->_range;
		_tmp17_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp16_, &new_prev, &new_curr, (guint8) 0);
		result = _tmp17_;
		_gee_concurrent_set_tower_unref0 (new_curr);
		_gee_concurrent_set_tower_unref0 (new_prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
}

static gpointer
gee_concurrent_set_sub_iterator_real_get (GeeIterator* base)
{
	GeeConcurrentSetSubIterator * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	gconstpointer _tmp3_;
	gpointer _tmp4_;
	gpointer result;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = self->_curr;
	_tmp3_ = _tmp2_->_data;
	_tmp4_ = ((_tmp3_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp3_) : ((gpointer) _tmp3_);
	result = _tmp4_;
	return result;
}

static void
gee_concurrent_set_sub_iterator_real_remove (GeeIterator* base)
{
	GeeConcurrentSetSubIterator * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSet* _tmp5_;
	GCompareDataFunc _tmp6_;
	gpointer _tmp6__target;
	GeeConcurrentSetTower* _tmp7_;
	gboolean _tmp8_;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_, "valid");
	_tmp4_ = self->_range;
	_tmp5_ = _tmp4_->_set;
	_tmp6_ = _tmp5_->priv->_cmp;
	_tmp6__target = _tmp5_->priv->_cmp_target;
	_tmp7_ = self->_curr;
	_tmp8_ = gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp6_, _tmp6__target, &self->_prev, _tmp7_);
	if (_tmp8_) {
		GeeConcurrentSetRange* _tmp9_;
		GeeConcurrentSet* _tmp10_;
		_tmp9_ = self->_range;
		_tmp10_ = _tmp9_->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp10_->priv->_size));
	}
	self->_removed = TRUE;
	_gee_hazard_pointer_context_free0 (ctx);
}

static gboolean
gee_concurrent_set_sub_iterator_begin (GeeConcurrentSetSubIterator* self)
{
	GeeConcurrentSetTowerIter _tmp0_;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* _tmp8_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_prev;
	_tmp1_ = _tmp0_._iter[0];
	if (_tmp1_ != NULL) {
		result = TRUE;
		return result;
	}
	_tmp2_ = self->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, _tmp2_, &_tmp3_, &_tmp4_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp3_;
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp4_;
	_tmp5_ = self->_curr;
	if (_tmp5_ == NULL) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp6_ = FALSE;
				_tmp6_ = TRUE;
				while (TRUE) {
					if (!_tmp6_) {
						gint _tmp7_;
						_tmp7_ = i;
						i = _tmp7_ + 1;
					}
					_tmp6_ = FALSE;
					if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
						break;
					}
					_gee_concurrent_set_tower_unref0 (self->_prev._iter[i]);
					self->_prev._iter[i] = NULL;
				}
			}
		}
	}
	_tmp8_ = self->_curr;
	result = _tmp8_ != NULL;
	return result;
}

static gboolean
gee_concurrent_set_sub_iterator_real_get_valid (GeeIterator* base)
{
	gboolean result;
	GeeConcurrentSetSubIterator* self;
	gboolean _tmp0_ = FALSE;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	gboolean is_valid = FALSE;
	gboolean _tmp3_ = FALSE;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp1_ = self->_prev;
	_tmp2_ = _tmp1_._iter[0];
	if (_tmp2_ != NULL) {
		_tmp0_ = !self->_removed;
	} else {
		_tmp0_ = FALSE;
	}
	is_valid = _tmp0_;
	if (!is_valid) {
		_tmp3_ = TRUE;
	} else {
		GeeConcurrentSetTower* _tmp4_;
		_tmp4_ = self->_curr;
		_tmp3_ = _tmp4_ != NULL;
	}
	_vala_assert (_tmp3_, "!is_valid || _curr != null");
	result = is_valid;
	return result;
}

static gboolean
gee_concurrent_set_sub_iterator_real_get_read_only (GeeIterator* base)
{
	gboolean result;
	GeeConcurrentSetSubIterator* self;
	self = (GeeConcurrentSetSubIterator*) base;
	result = FALSE;
	return result;
}

static void
gee_concurrent_set_sub_iterator_class_init (GeeConcurrentSetSubIteratorClass * klass,
                                            gpointer klass_data)
{
	gee_concurrent_set_sub_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeConcurrentSetSubIterator_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_sub_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_sub_iterator_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_sub_iterator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_VALID_PROPERTY, gee_concurrent_set_sub_iterator_properties[GEE_CONCURRENT_SET_SUB_ITERATOR_VALID_PROPERTY] = g_param_spec_boolean ("valid", "valid", "valid", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY_PROPERTY, gee_concurrent_set_sub_iterator_properties[GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY_PROPERTY] = g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static GType
gee_concurrent_set_sub_iterator_gee_traversable_get_g_type (GeeConcurrentSetSubIterator* self)
{
	return self->priv->g_type;
}

static GBoxedCopyFunc
gee_concurrent_set_sub_iterator_gee_traversable_get_g_dup_func (GeeConcurrentSetSubIterator* self)
{
	return self->priv->g_dup_func;
}

static GDestroyNotify
gee_concurrent_set_sub_iterator_gee_traversable_get_g_destroy_func (GeeConcurrentSetSubIterator* self)
{
	return self->priv->g_destroy_func;
}

static void
gee_concurrent_set_sub_iterator_gee_traversable_interface_init (GeeTraversableIface * iface,
                                                                gpointer iface_data)
{
	gee_concurrent_set_sub_iterator_gee_traversable_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach = (gboolean (*) (GeeTraversable*, GeeForallFunc, gpointer)) gee_concurrent_set_sub_iterator_real_foreach;
	iface->tee = (GeeIterator** (*) (GeeTraversable*, guint, gint*)) gee_concurrent_set_sub_iterator_real_tee;
	iface->get_g_type = (GType (*) (GeeTraversable *)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc (*) (GeeTraversable *)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify (*) (GeeTraversable *)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_destroy_func;
}

static void
gee_concurrent_set_sub_iterator_gee_iterator_interface_init (GeeIteratorIface * iface,
                                                             gpointer iface_data)
{
	gee_concurrent_set_sub_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->next = (gboolean (*) (GeeIterator*)) gee_concurrent_set_sub_iterator_real_next;
	iface->has_next = (gboolean (*) (GeeIterator*)) gee_concurrent_set_sub_iterator_real_has_next;
	iface->get = (gpointer (*) (GeeIterator*)) gee_concurrent_set_sub_iterator_real_get;
	iface->remove = (void (*) (GeeIterator*)) gee_concurrent_set_sub_iterator_real_remove;
	iface->get_valid = gee_concurrent_set_sub_iterator_real_get_valid;
	iface->get_read_only = gee_concurrent_set_sub_iterator_real_get_read_only;
}

static void
gee_concurrent_set_sub_iterator_instance_init (GeeConcurrentSetSubIterator * self,
                                               gpointer klass)
{
	self->priv = gee_concurrent_set_sub_iterator_get_instance_private (self);
	self->_curr = NULL;
	self->_removed = FALSE;
}

static void
gee_concurrent_set_sub_iterator_finalize (GObject * obj)
{
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	_gee_concurrent_set_range_unref0 (self->_range);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	G_OBJECT_CLASS (gee_concurrent_set_sub_iterator_parent_class)->finalize (obj);
}

static GType
gee_concurrent_set_sub_iterator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetSubIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_sub_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetSubIterator), 0, (GInstanceInitFunc) gee_concurrent_set_sub_iterator_instance_init, NULL };
	static const GInterfaceInfo gee_traversable_info = { (GInterfaceInitFunc) gee_concurrent_set_sub_iterator_gee_traversable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_concurrent_set_sub_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType gee_concurrent_set_sub_iterator_type_id;
	gee_concurrent_set_sub_iterator_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeConcurrentSetSubIterator", &g_define_type_info, 0);
	g_type_add_interface_static (gee_concurrent_set_sub_iterator_type_id, GEE_TYPE_TRAVERSABLE, &gee_traversable_info);
	g_type_add_interface_static (gee_concurrent_set_sub_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
	GeeConcurrentSetSubIterator_private_offset = g_type_add_instance_private (gee_concurrent_set_sub_iterator_type_id, sizeof (GeeConcurrentSetSubIteratorPrivate));
	return gee_concurrent_set_sub_iterator_type_id;
}

static GType
gee_concurrent_set_sub_iterator_get_type (void)
{
	static volatile gsize gee_concurrent_set_sub_iterator_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_sub_iterator_type_id__once)) {
		GType gee_concurrent_set_sub_iterator_type_id;
		gee_concurrent_set_sub_iterator_type_id = gee_concurrent_set_sub_iterator_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_sub_iterator_type_id__once, gee_concurrent_set_sub_iterator_type_id);
	}
	return gee_concurrent_set_sub_iterator_type_id__once;
}

static void
_vala_gee_concurrent_set_sub_iterator_get_property (GObject * object,
                                                    guint property_id,
                                                    GValue * value,
                                                    GParamSpec * pspec)
{
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_ITERATOR_VALID_PROPERTY:
		g_value_set_boolean (value, gee_iterator_get_valid ((GeeIterator*) self));
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY_PROPERTY:
		g_value_set_boolean (value, gee_iterator_get_read_only ((GeeIterator*) self));
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE:
		g_value_set_gtype (value, self->priv->g_type);
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC:
		g_value_set_pointer (value, self->priv->g_dup_func);
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->g_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_concurrent_set_sub_iterator_set_property (GObject * object,
                                                    guint property_id,
                                                    const GValue * value,
                                                    GParamSpec * pspec)
{
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
gee_concurrent_set_range_get_instance_private (GeeConcurrentSetRange* self)
{
	return G_STRUCT_MEMBER_P (self, GeeConcurrentSetRange_private_offset);
}

static GType
gee_concurrent_set_range_position_get_type_once (void)
{
	static const GEnumValue values[] = {{GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE, "GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE", "before"}, {GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE, "GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE", "inside"}, {GEE_CONCURRENT_SET_RANGE_POSITION_AFTER, "GEE_CONCURRENT_SET_RANGE_POSITION_AFTER", "after"}, {GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY, "GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY", "empty"}, {0, NULL, NULL}};
	GType gee_concurrent_set_range_position_type_id;
	gee_concurrent_set_range_position_type_id = g_enum_register_static ("GeeConcurrentSetRangePosition", values);
	return gee_concurrent_set_range_position_type_id;
}

static GType
gee_concurrent_set_range_position_get_type (void)
{
	static volatile gsize gee_concurrent_set_range_position_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_position_type_id__once)) {
		GType gee_concurrent_set_range_position_type_id;
		gee_concurrent_set_range_position_type_id = gee_concurrent_set_range_position_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_range_position_type_id__once, gee_concurrent_set_range_position_type_id);
	}
	return gee_concurrent_set_range_position_type_id__once;
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_construct (GType object_type,
                                    GType g_type,
                                    GBoxedCopyFunc g_dup_func,
                                    GDestroyNotify g_destroy_func,
                                    GeeConcurrentSet* cset,
                                    gconstpointer start,
                                    gconstpointer end)
{
	GeeConcurrentSetRange* self = NULL;
	gpointer _tmp0_;
	gpointer _tmp1_;
	GCompareDataFunc _tmp2_;
	gpointer _tmp2__target;
	GeeConcurrentSet* _tmp7_;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = ((start != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) start) : ((gpointer) start);
	((self->_start == NULL) || (g_destroy_func == NULL)) ? NULL : (self->_start = (g_destroy_func (self->_start), NULL));
	self->_start = _tmp0_;
	_tmp1_ = ((end != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) end) : ((gpointer) end);
	((self->_end == NULL) || (g_destroy_func == NULL)) ? NULL : (self->_end = (g_destroy_func (self->_end), NULL));
	self->_end = _tmp1_;
	_tmp2_ = cset->priv->_cmp;
	_tmp2__target = cset->priv->_cmp_target;
	if (_tmp2_ (start, end, _tmp2__target) < 0) {
		self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp3_ = FALSE;
				_tmp3_ = TRUE;
				while (TRUE) {
					GeeConcurrentSetTower* _tmp5_;
					GeeConcurrentSetTower* _tmp6_;
					if (!_tmp3_) {
						gint _tmp4_;
						_tmp4_ = i;
						i = _tmp4_ + 1;
					}
					_tmp3_ = FALSE;
					if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
						break;
					}
					_tmp5_ = cset->priv->_head;
					_tmp6_ = _gee_concurrent_set_tower_ref0 (_tmp5_);
					_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[i]);
					self->_bookmark._iter[i] = _tmp6_;
				}
			}
		}
	} else {
		self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	}
	_tmp7_ = _g_object_ref0 (cset);
	_g_object_unref0 (self->_set);
	self->_set = _tmp7_;
	return self;
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_new (GType g_type,
                              GBoxedCopyFunc g_dup_func,
                              GDestroyNotify g_destroy_func,
                              GeeConcurrentSet* cset,
                              gconstpointer start,
                              gconstpointer end)
{
	return gee_concurrent_set_range_construct (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, start, end);
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_construct_head (GType object_type,
                                         GType g_type,
                                         GBoxedCopyFunc g_dup_func,
                                         GDestroyNotify g_destroy_func,
                                         GeeConcurrentSet* cset,
                                         gconstpointer end)
{
	GeeConcurrentSetRange* self = NULL;
	gpointer _tmp0_;
	GeeConcurrentSet* _tmp5_;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = ((end != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) end) : ((gpointer) end);
	((self->_end == NULL) || (g_destroy_func == NULL)) ? NULL : (self->_end = (g_destroy_func (self->_end), NULL));
	self->_end = _tmp0_;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_HEAD;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTower* _tmp3_;
				GeeConcurrentSetTower* _tmp4_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp3_ = cset->priv->_head;
				_tmp4_ = _gee_concurrent_set_tower_ref0 (_tmp3_);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[i]);
				self->_bookmark._iter[i] = _tmp4_;
			}
		}
	}
	_tmp5_ = _g_object_ref0 (cset);
	_g_object_unref0 (self->_set);
	self->_set = _tmp5_;
	return self;
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_new_head (GType g_type,
                                   GBoxedCopyFunc g_dup_func,
                                   GDestroyNotify g_destroy_func,
                                   GeeConcurrentSet* cset,
                                   gconstpointer end)
{
	return gee_concurrent_set_range_construct_head (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, end);
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_construct_tail (GType object_type,
                                         GType g_type,
                                         GBoxedCopyFunc g_dup_func,
                                         GDestroyNotify g_destroy_func,
                                         GeeConcurrentSet* cset,
                                         gconstpointer start)
{
	GeeConcurrentSetRange* self = NULL;
	gpointer _tmp0_;
	GeeConcurrentSet* _tmp5_;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = ((start != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) start) : ((gpointer) start);
	((self->_start == NULL) || (g_destroy_func == NULL)) ? NULL : (self->_start = (g_destroy_func (self->_start), NULL));
	self->_start = _tmp0_;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_TAIL;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTower* _tmp3_;
				GeeConcurrentSetTower* _tmp4_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp3_ = cset->priv->_head;
				_tmp4_ = _gee_concurrent_set_tower_ref0 (_tmp3_);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[i]);
				self->_bookmark._iter[i] = _tmp4_;
			}
		}
	}
	_tmp5_ = _g_object_ref0 (cset);
	_g_object_unref0 (self->_set);
	self->_set = _tmp5_;
	return self;
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_new_tail (GType g_type,
                                   GBoxedCopyFunc g_dup_func,
                                   GDestroyNotify g_destroy_func,
                                   GeeConcurrentSet* cset,
                                   gconstpointer start)
{
	return gee_concurrent_set_range_construct_tail (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, start);
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_construct_empty (GType object_type,
                                          GType g_type,
                                          GBoxedCopyFunc g_dup_func,
                                          GDestroyNotify g_destroy_func,
                                          GeeConcurrentSet* cset)
{
	GeeConcurrentSetRange* self = NULL;
	GeeConcurrentSet* _tmp0_;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	_tmp0_ = _g_object_ref0 (cset);
	_g_object_unref0 (self->_set);
	self->_set = _tmp0_;
	return self;
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_new_empty (GType g_type,
                                    GBoxedCopyFunc g_dup_func,
                                    GDestroyNotify g_destroy_func,
                                    GeeConcurrentSet* cset)
{
	return gee_concurrent_set_range_construct_empty (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset);
}

static void
gee_concurrent_set_range_copy_bookmark (GeeConcurrentSetRange* self,
                                        GeeConcurrentSetRange* range)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (range != NULL);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gpointer _tmp2_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp2_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &range->_bookmark._iter[i], (gsize) 0, NULL);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[i]);
				self->_bookmark._iter[i] = (GeeConcurrentSetTower*) _tmp2_;
			}
		}
	}
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_cut_head (GType g_type,
                                   GBoxedCopyFunc g_dup_func,
                                   GDestroyNotify g_destroy_func,
                                   GeeConcurrentSetRange* from,
                                   gconstpointer start)
{
	GeeConcurrentSetRange* _result_ = NULL;
	GeeConcurrentSet* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp32_;
	GeeConcurrentSetRange* result;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from->_set;
	_tmp1_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp0_);
	_result_ = _tmp1_;
	switch (from->_type) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSet* _tmp2_;
			GCompareDataFunc _tmp3_;
			gpointer _tmp3__target;
			gconstpointer _tmp4_;
			_tmp2_ = from->_set;
			_tmp3_ = _tmp2_->priv->_cmp;
			_tmp3__target = _tmp2_->priv->_cmp_target;
			_tmp4_ = from->_end;
			if (_tmp3_ (start, _tmp4_, _tmp3__target) < 0) {
				GeeConcurrentSetRange* _tmp5_;
				gpointer _tmp6_;
				GeeConcurrentSetRange* _tmp7_;
				gconstpointer _tmp8_;
				gpointer _tmp9_;
				GeeConcurrentSetRange* _tmp10_;
				_tmp5_ = _result_;
				_tmp6_ = ((start != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) start) : ((gpointer) start);
				((_tmp5_->_start == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp5_->_start = (g_destroy_func (_tmp5_->_start), NULL));
				_tmp5_->_start = _tmp6_;
				_tmp7_ = _result_;
				_tmp8_ = from->_end;
				_tmp9_ = ((_tmp8_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp8_) : ((gpointer) _tmp8_);
				((_tmp7_->_end == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp7_->_end = (g_destroy_func (_tmp7_->_end), NULL));
				_tmp7_->_end = _tmp9_;
				_tmp10_ = _result_;
				_tmp10_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp11_;
				_tmp11_ = _result_;
				_tmp11_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp12_;
			GeeConcurrentSet* _tmp13_;
			gconstpointer _tmp14_;
			gconstpointer _tmp15_;
			gpointer _tmp16_;
			GeeConcurrentSetRange* _tmp17_;
			_tmp12_ = _result_;
			_tmp13_ = from->_set;
			_tmp14_ = from->_start;
			_tmp15_ = gee_concurrent_set_max (_tmp13_, _tmp14_, start, NULL);
			_tmp16_ = ((_tmp15_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp15_) : ((gpointer) _tmp15_);
			((_tmp12_->_start == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp12_->_start = (g_destroy_func (_tmp12_->_start), NULL));
			_tmp12_->_start = _tmp16_;
			_tmp17_ = _result_;
			_tmp17_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_TAIL;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSet* _tmp18_;
			GCompareDataFunc _tmp19_;
			gpointer _tmp19__target;
			gconstpointer _tmp20_;
			_tmp18_ = from->_set;
			_tmp19_ = _tmp18_->priv->_cmp;
			_tmp19__target = _tmp18_->priv->_cmp_target;
			_tmp20_ = from->_start;
			if (_tmp19_ (_tmp20_, start, _tmp19__target) < 0) {
				GeeConcurrentSetRange* _tmp21_;
				GeeConcurrentSet* _tmp22_;
				gconstpointer _tmp23_;
				gconstpointer _tmp24_;
				gpointer _tmp25_;
				GeeConcurrentSetRange* _tmp26_;
				gconstpointer _tmp27_;
				gpointer _tmp28_;
				GeeConcurrentSetRange* _tmp29_;
				_tmp21_ = _result_;
				_tmp22_ = from->_set;
				_tmp23_ = from->_start;
				_tmp24_ = gee_concurrent_set_max (_tmp22_, _tmp23_, start, NULL);
				_tmp25_ = ((_tmp24_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp24_) : ((gpointer) _tmp24_);
				((_tmp21_->_start == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp21_->_start = (g_destroy_func (_tmp21_->_start), NULL));
				_tmp21_->_start = _tmp25_;
				_tmp26_ = _result_;
				_tmp27_ = from->_end;
				_tmp28_ = ((_tmp27_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp27_) : ((gpointer) _tmp27_);
				((_tmp26_->_end == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp26_->_end = (g_destroy_func (_tmp26_->_end), NULL));
				_tmp26_->_end = _tmp28_;
				_tmp29_ = _result_;
				_tmp29_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp30_;
				_tmp30_ = _result_;
				_tmp30_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp31_;
			_tmp31_ = _result_;
			_tmp31_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp32_ = _result_;
	if (_tmp32_->_type != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp33_;
		GeeConcurrentSetRange* _tmp34_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, from, NULL, NULL);
		_tmp33_ = _result_;
		gee_concurrent_set_range_copy_bookmark (_tmp33_, from);
		_tmp34_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp34_, NULL, NULL);
	}
	result = _result_;
	return result;
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_cut_tail (GType g_type,
                                   GBoxedCopyFunc g_dup_func,
                                   GDestroyNotify g_destroy_func,
                                   GeeConcurrentSetRange* from,
                                   gconstpointer end)
{
	GeeConcurrentSetRange* _result_ = NULL;
	GeeConcurrentSet* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp32_;
	GeeConcurrentSetRange* result;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from->_set;
	_tmp1_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp0_);
	_result_ = _tmp1_;
	switch (from->_type) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp2_;
			GeeConcurrentSet* _tmp3_;
			gconstpointer _tmp4_;
			gconstpointer _tmp5_;
			gpointer _tmp6_;
			GeeConcurrentSetRange* _tmp7_;
			_tmp2_ = _result_;
			_tmp3_ = from->_set;
			_tmp4_ = from->_end;
			_tmp5_ = gee_concurrent_set_min (_tmp3_, _tmp4_, end, NULL);
			_tmp6_ = ((_tmp5_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp5_) : ((gpointer) _tmp5_);
			((_tmp2_->_end == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp2_->_end = (g_destroy_func (_tmp2_->_end), NULL));
			_tmp2_->_end = _tmp6_;
			_tmp7_ = _result_;
			_tmp7_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_HEAD;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSet* _tmp8_;
			GCompareDataFunc _tmp9_;
			gpointer _tmp9__target;
			gconstpointer _tmp10_;
			_tmp8_ = from->_set;
			_tmp9_ = _tmp8_->priv->_cmp;
			_tmp9__target = _tmp8_->priv->_cmp_target;
			_tmp10_ = from->_start;
			if (_tmp9_ (_tmp10_, end, _tmp9__target) < 0) {
				GeeConcurrentSetRange* _tmp11_;
				gconstpointer _tmp12_;
				gpointer _tmp13_;
				GeeConcurrentSetRange* _tmp14_;
				gpointer _tmp15_;
				GeeConcurrentSetRange* _tmp16_;
				_tmp11_ = _result_;
				_tmp12_ = from->_start;
				_tmp13_ = ((_tmp12_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp12_) : ((gpointer) _tmp12_);
				((_tmp11_->_start == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp11_->_start = (g_destroy_func (_tmp11_->_start), NULL));
				_tmp11_->_start = _tmp13_;
				_tmp14_ = _result_;
				_tmp15_ = ((end != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) end) : ((gpointer) end);
				((_tmp14_->_end == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp14_->_end = (g_destroy_func (_tmp14_->_end), NULL));
				_tmp14_->_end = _tmp15_;
				_tmp16_ = _result_;
				_tmp16_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp17_;
				_tmp17_ = _result_;
				_tmp17_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSet* _tmp18_;
			GCompareDataFunc _tmp19_;
			gpointer _tmp19__target;
			gconstpointer _tmp20_;
			_tmp18_ = from->_set;
			_tmp19_ = _tmp18_->priv->_cmp;
			_tmp19__target = _tmp18_->priv->_cmp_target;
			_tmp20_ = from->_start;
			if (_tmp19_ (_tmp20_, end, _tmp19__target) < 0) {
				GeeConcurrentSetRange* _tmp21_;
				gconstpointer _tmp22_;
				gpointer _tmp23_;
				GeeConcurrentSetRange* _tmp24_;
				GeeConcurrentSet* _tmp25_;
				gconstpointer _tmp26_;
				gconstpointer _tmp27_;
				gpointer _tmp28_;
				GeeConcurrentSetRange* _tmp29_;
				_tmp21_ = _result_;
				_tmp22_ = from->_start;
				_tmp23_ = ((_tmp22_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp22_) : ((gpointer) _tmp22_);
				((_tmp21_->_start == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp21_->_start = (g_destroy_func (_tmp21_->_start), NULL));
				_tmp21_->_start = _tmp23_;
				_tmp24_ = _result_;
				_tmp25_ = from->_set;
				_tmp26_ = from->_end;
				_tmp27_ = gee_concurrent_set_min (_tmp25_, _tmp26_, end, NULL);
				_tmp28_ = ((_tmp27_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp27_) : ((gpointer) _tmp27_);
				((_tmp24_->_end == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp24_->_end = (g_destroy_func (_tmp24_->_end), NULL));
				_tmp24_->_end = _tmp28_;
				_tmp29_ = _result_;
				_tmp29_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp30_;
				_tmp30_ = _result_;
				_tmp30_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp31_;
			_tmp31_ = _result_;
			_tmp31_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp32_ = _result_;
	if (_tmp32_->_type != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp33_;
		GeeConcurrentSetRange* _tmp34_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, from, NULL, NULL);
		_tmp33_ = _result_;
		gee_concurrent_set_range_copy_bookmark (_tmp33_, from);
		_tmp34_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp34_, NULL, NULL);
	}
	result = _result_;
	return result;
}

static GeeConcurrentSetRange*
gee_concurrent_set_range_cut (GType g_type,
                              GBoxedCopyFunc g_dup_func,
                              GDestroyNotify g_destroy_func,
                              GeeConcurrentSetRange* from,
                              gconstpointer start,
                              gconstpointer end)
{
	GeeConcurrentSetRange* _result_ = NULL;
	GeeConcurrentSet* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	gboolean _tmp16_ = FALSE;
	GeeConcurrentSetRange* _tmp17_;
	GeeConcurrentSetRange* _tmp26_;
	GeeConcurrentSetRange* result;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from->_set;
	_tmp1_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp0_);
	_result_ = _tmp1_;
	_tmp2_ = _result_;
	_tmp2_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
	switch (from->_type) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSet* _tmp3_;
			gconstpointer _tmp4_;
			gconstpointer _tmp5_;
			_tmp3_ = from->_set;
			_tmp4_ = from->_end;
			_tmp5_ = gee_concurrent_set_min (_tmp3_, _tmp4_, end, NULL);
			end = _tmp5_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSet* _tmp6_;
			gconstpointer _tmp7_;
			gconstpointer _tmp8_;
			_tmp6_ = from->_set;
			_tmp7_ = from->_start;
			_tmp8_ = gee_concurrent_set_max (_tmp6_, _tmp7_, start, NULL);
			start = _tmp8_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSet* _tmp9_;
			gconstpointer _tmp10_;
			gconstpointer _tmp11_;
			GeeConcurrentSet* _tmp12_;
			gconstpointer _tmp13_;
			gconstpointer _tmp14_;
			_tmp9_ = from->_set;
			_tmp10_ = from->_start;
			_tmp11_ = gee_concurrent_set_max (_tmp9_, _tmp10_, start, NULL);
			start = _tmp11_;
			_tmp12_ = from->_set;
			_tmp13_ = from->_end;
			_tmp14_ = gee_concurrent_set_min (_tmp12_, _tmp13_, end, NULL);
			end = _tmp14_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp15_;
			_tmp15_ = _result_;
			_tmp15_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp17_ = _result_;
	if (_tmp17_->_type != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSet* _tmp18_;
		GCompareDataFunc _tmp19_;
		gpointer _tmp19__target;
		_tmp18_ = from->_set;
		_tmp19_ = _tmp18_->priv->_cmp;
		_tmp19__target = _tmp18_->priv->_cmp_target;
		_tmp16_ = _tmp19_ (start, end, _tmp19__target) < 0;
	} else {
		_tmp16_ = FALSE;
	}
	if (_tmp16_) {
		GeeConcurrentSetRange* _tmp20_;
		gpointer _tmp21_;
		GeeConcurrentSetRange* _tmp22_;
		gpointer _tmp23_;
		GeeConcurrentSetRange* _tmp24_;
		_tmp20_ = _result_;
		_tmp21_ = ((start != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) start) : ((gpointer) start);
		((_tmp20_->_start == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp20_->_start = (g_destroy_func (_tmp20_->_start), NULL));
		_tmp20_->_start = _tmp21_;
		_tmp22_ = _result_;
		_tmp23_ = ((end != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) end) : ((gpointer) end);
		((_tmp22_->_end == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp22_->_end = (g_destroy_func (_tmp22_->_end), NULL));
		_tmp22_->_end = _tmp23_;
		_tmp24_ = _result_;
		_tmp24_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
	} else {
		GeeConcurrentSetRange* _tmp25_;
		_tmp25_ = _result_;
		_tmp25_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	}
	_tmp26_ = _result_;
	if (_tmp26_->_type != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp27_;
		GeeConcurrentSetRange* _tmp28_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, from, NULL, NULL);
		_tmp27_ = _result_;
		gee_concurrent_set_range_copy_bookmark (_tmp27_, from);
		_tmp28_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp28_, NULL, NULL);
	}
	result = _result_;
	return result;
}

static void
gee_concurrent_set_range_improve_bookmark (GType g_type,
                                           GBoxedCopyFunc g_dup_func,
                                           GDestroyNotify g_destroy_func,
                                           GeeConcurrentSetRange* range,
                                           GeeConcurrentSetTower** out_curr,
                                           GeeConcurrentSetTowerIter* prev)
{
	GeeConcurrentSetTower* _vala_out_curr = NULL;
	GeeConcurrentSetTowerIter _vala_prev = {0};
	gboolean _tmp65_ = FALSE;
	gboolean _tmp66_ = FALSE;
	g_return_if_fail (range != NULL);
	gee_concurrent_set_tower_iter_destroy (&_vala_prev);
	memset (&_vala_prev, 0, sizeof (GeeConcurrentSetTowerIter));
	_gee_concurrent_set_tower_unref0 (_vala_out_curr);
	_vala_out_curr = NULL;
	switch (range->_type) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			if ((&_vala_out_curr) != NULL) {
				gpointer _tmp0_;
				_tmp0_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &range->_bookmark._iter[0], (gsize) 0, NULL);
				_gee_concurrent_set_tower_unref0 (_vala_out_curr);
				_vala_out_curr = (GeeConcurrentSetTower*) _tmp0_;
				if ((&_vala_prev) != NULL) {
					GeeConcurrentSetTower* _tmp1_;
					GeeConcurrentSetTowerIter _tmp2_;
					GeeConcurrentSetTower* _tmp3_;
					GeeConcurrentSetTower* _tmp4_;
					_tmp1_ = _vala_out_curr;
					_vala_out_curr = NULL;
					_gee_concurrent_set_tower_unref0 (_vala_prev._iter[0]);
					_vala_prev._iter[0] = _tmp1_;
					_tmp2_ = _vala_prev;
					_tmp3_ = _tmp2_._iter[0];
					_tmp4_ = gee_concurrent_set_tower_get_next (_tmp3_, (guint8) 0);
					_gee_concurrent_set_tower_unref0 (_vala_out_curr);
					_vala_out_curr = _tmp4_;
				} else {
					GeeConcurrentSetTower* _tmp5_;
					GeeConcurrentSetTower* _tmp6_;
					_tmp5_ = _vala_out_curr;
					_tmp6_ = gee_concurrent_set_tower_get_next (_tmp5_, (guint8) 0);
					_gee_concurrent_set_tower_unref0 (_vala_out_curr);
					_vala_out_curr = _tmp6_;
				}
			}
			if ((&_vala_prev) != NULL) {
				{
					gint _tmp7_ = 0;
					gint i = 0;
					if ((&_vala_out_curr) != NULL) {
						_tmp7_ = 1;
					} else {
						_tmp7_ = 0;
					}
					i = _tmp7_;
					{
						gboolean _tmp8_ = FALSE;
						_tmp8_ = TRUE;
						while (TRUE) {
							gpointer _tmp10_;
							if (!_tmp8_) {
								gint _tmp9_;
								_tmp9_ = i;
								i = _tmp9_ + 1;
							}
							_tmp8_ = FALSE;
							if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
								break;
							}
							_tmp10_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &range->_bookmark._iter[i], (gsize) 0, NULL);
							_gee_concurrent_set_tower_unref0 (_vala_prev._iter[i]);
							_vala_prev._iter[i] = (GeeConcurrentSetTower*) _tmp10_;
						}
					}
				}
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			_gee_concurrent_set_tower_unref0 (_vala_out_curr);
			_vala_out_curr = NULL;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetTower* last_best = NULL;
			last_best = NULL;
			{
				gint i = 0;
				i = GEE_CONCURRENT_SET__MAX_HEIGHT - 1;
				{
					gboolean _tmp11_ = FALSE;
					_tmp11_ = TRUE;
					while (TRUE) {
						GeeConcurrentSetTower* curr = NULL;
						gpointer _tmp13_;
						GeeConcurrentSetTower* curr_old = NULL;
						GeeConcurrentSetTower* _tmp14_;
						GeeConcurrentSetTower* _tmp15_;
						GeeConcurrentSetTower* _tmp16_;
						gboolean _tmp17_ = FALSE;
						gboolean _tmp18_ = FALSE;
						GeeConcurrentSetTower* _tmp19_;
						GeeConcurrentSetTower* _tmp28_;
						GeeConcurrentSetTower* _tmp29_;
						GeeConcurrentSetTower* next = NULL;
						GeeConcurrentSetTower* _tmp34_;
						GeeConcurrentSetTower* _tmp35_;
						gboolean _tmp36_ = FALSE;
						GeeConcurrentSetTower* _tmp64_;
						if (!_tmp11_) {
							gint _tmp12_;
							_tmp12_ = i;
							i = _tmp12_ - 1;
						}
						_tmp11_ = FALSE;
						if (!(i >= 0)) {
							break;
						}
						_tmp13_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &range->_bookmark._iter[i], (gsize) 0, NULL);
						curr = (GeeConcurrentSetTower*) _tmp13_;
						_tmp14_ = curr;
						_tmp15_ = _gee_concurrent_set_tower_ref0 (_tmp14_);
						curr_old = _tmp15_;
						_tmp16_ = curr;
						_vala_assert (_tmp16_ != NULL, "curr != null");
						gee_concurrent_set_tower_backtrace (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, &curr, (guint8) i);
						_tmp19_ = last_best;
						if (_tmp19_ != NULL) {
							GeeConcurrentSetTower* _tmp20_;
							GeeConcurrentSetTower* _tmp21_;
							_tmp20_ = last_best;
							_tmp21_ = curr;
							_tmp18_ = _tmp20_ != _tmp21_;
						} else {
							_tmp18_ = FALSE;
						}
						if (_tmp18_) {
							GeeConcurrentSet* _tmp22_;
							GCompareDataFunc _tmp23_;
							gpointer _tmp23__target;
							GeeConcurrentSetTower* _tmp24_;
							GeeConcurrentSetTower* _tmp25_;
							_tmp22_ = range->_set;
							_tmp23_ = _tmp22_->priv->_cmp;
							_tmp23__target = _tmp22_->priv->_cmp_target;
							_tmp24_ = curr;
							_tmp25_ = last_best;
							_tmp17_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp23_, _tmp23__target, _tmp24_, _tmp25_) < 0;
						} else {
							_tmp17_ = FALSE;
						}
						if (_tmp17_) {
							GeeConcurrentSetTower* _tmp26_;
							GeeConcurrentSetTower* _tmp27_;
							_tmp26_ = last_best;
							_tmp27_ = _gee_concurrent_set_tower_ref0 (_tmp26_);
							_gee_concurrent_set_tower_unref0 (curr);
							curr = _tmp27_;
						}
						_tmp28_ = curr;
						_tmp29_ = curr_old;
						if (_tmp28_ != _tmp29_) {
							GeeConcurrentSetTower* _tmp30_;
							GeeConcurrentSetTower* _tmp31_;
							GeeConcurrentSetTower* _tmp32_;
							_tmp30_ = curr_old;
							_tmp31_ = curr;
							_tmp32_ = _gee_concurrent_set_tower_ref0 (_tmp31_);
							if (!gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &range->_bookmark._iter[i], _tmp30_, _tmp32_, (gsize) 0, (gsize) 0, (gsize) 0)) {
								gpointer _tmp33_;
								_tmp33_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &range->_bookmark._iter[i], (gsize) 0, NULL);
								_gee_concurrent_set_tower_unref0 (curr);
								curr = (GeeConcurrentSetTower*) _tmp33_;
							}
						}
						_tmp34_ = curr;
						_tmp35_ = gee_concurrent_set_tower_get_next (_tmp34_, (guint8) i);
						next = _tmp35_;
						if ((&_vala_out_curr) != NULL) {
							_tmp36_ = i == 0;
						} else {
							_tmp36_ = FALSE;
						}
						if (_tmp36_) {
							GeeConcurrentSetTower* _tmp37_;
							GeeConcurrentSetTower* _tmp38_;
							_tmp37_ = next;
							_tmp38_ = _gee_concurrent_set_tower_ref0 (_tmp37_);
							_gee_concurrent_set_tower_unref0 (_vala_out_curr);
							_vala_out_curr = _tmp38_;
						}
						while (TRUE) {
							gboolean _tmp39_ = FALSE;
							GeeConcurrentSetTower* _tmp40_;
							GeeConcurrentSet* _tmp45_;
							GCompareDataFunc _tmp46_;
							gpointer _tmp46__target;
							gboolean _tmp47_ = FALSE;
							gboolean _tmp48_ = FALSE;
							GeeConcurrentSet* _tmp52_;
							GCompareDataFunc _tmp53_;
							gpointer _tmp53__target;
							GeeConcurrentSetTower* _tmp54_;
							gconstpointer _tmp55_;
							_tmp40_ = next;
							if (_tmp40_ != NULL) {
								GeeConcurrentSet* _tmp41_;
								GCompareDataFunc _tmp42_;
								gpointer _tmp42__target;
								GeeConcurrentSetTower* _tmp43_;
								gconstpointer _tmp44_;
								_tmp41_ = range->_set;
								_tmp42_ = _tmp41_->priv->_cmp;
								_tmp42__target = _tmp41_->priv->_cmp_target;
								_tmp43_ = next;
								_tmp44_ = range->_start;
								_tmp39_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp42_, _tmp42__target, _tmp43_, _tmp44_) < 0;
							} else {
								_tmp39_ = FALSE;
							}
							if (!_tmp39_) {
								break;
							}
							_tmp45_ = range->_set;
							_tmp46_ = _tmp45_->priv->_cmp;
							_tmp46__target = _tmp45_->priv->_cmp_target;
							gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp46_, _tmp46__target, &curr, &next, (guint8) i, TRUE);
							if ((&curr) != NULL) {
								_tmp48_ = i == 0;
							} else {
								_tmp48_ = FALSE;
							}
							if (_tmp48_) {
								GeeConcurrentSetTower* _tmp49_;
								_tmp49_ = next;
								_tmp47_ = _tmp49_ != NULL;
							} else {
								_tmp47_ = FALSE;
							}
							if (_tmp47_) {
								GeeConcurrentSetTower* _tmp50_;
								GeeConcurrentSetTower* _tmp51_;
								_tmp50_ = next;
								_tmp51_ = _gee_concurrent_set_tower_ref0 (_tmp50_);
								_gee_concurrent_set_tower_unref0 (_vala_out_curr);
								_vala_out_curr = _tmp51_;
							}
							_tmp52_ = range->_set;
							_tmp53_ = _tmp52_->priv->_cmp;
							_tmp53__target = _tmp52_->priv->_cmp_target;
							_tmp54_ = curr;
							_tmp55_ = range->_start;
							if (gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp53_, _tmp53__target, _tmp54_, _tmp55_) < 0) {
								GeeConcurrentSetTower* _tmp56_;
								GeeConcurrentSetTower* _tmp57_;
								GeeConcurrentSetTower* _tmp58_;
								GeeConcurrentSetTower* _tmp60_;
								GeeConcurrentSetTower* _tmp61_;
								_tmp56_ = curr_old;
								_tmp57_ = curr;
								_tmp58_ = _gee_concurrent_set_tower_ref0 (_tmp57_);
								if (!gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &range->_bookmark._iter[i], _tmp56_, _tmp58_, (gsize) 0, (gsize) 0, (gsize) 0)) {
									gpointer _tmp59_;
									_tmp59_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &range->_bookmark._iter[i], (gsize) 0, NULL);
									_gee_concurrent_set_tower_unref0 (curr);
									curr = (GeeConcurrentSetTower*) _tmp59_;
								}
								_tmp60_ = curr;
								_tmp61_ = _gee_concurrent_set_tower_ref0 (_tmp60_);
								_gee_concurrent_set_tower_unref0 (curr_old);
								curr_old = _tmp61_;
							} else {
								break;
							}
						}
						if ((&_vala_prev) != NULL) {
							GeeConcurrentSetTower* _tmp62_;
							GeeConcurrentSetTower* _tmp63_;
							_tmp62_ = curr;
							_tmp63_ = _gee_concurrent_set_tower_ref0 (_tmp62_);
							_gee_concurrent_set_tower_unref0 (_vala_prev._iter[i]);
							_vala_prev._iter[i] = _tmp63_;
						}
						_tmp64_ = curr;
						curr = NULL;
						_gee_concurrent_set_tower_unref0 (last_best);
						last_best = _tmp64_;
						_gee_concurrent_set_tower_unref0 (next);
						_gee_concurrent_set_tower_unref0 (curr_old);
						_gee_concurrent_set_tower_unref0 (curr);
					}
				}
			}
			_gee_concurrent_set_tower_unref0 (last_best);
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	if ((&_vala_out_curr) != NULL) {
		GeeConcurrentSetTower* _tmp67_;
		_tmp67_ = _vala_out_curr;
		_tmp66_ = _tmp67_ != NULL;
	} else {
		_tmp66_ = FALSE;
	}
	if (_tmp66_) {
		GeeConcurrentSetTower* _tmp68_;
		_tmp68_ = _vala_out_curr;
		_tmp65_ = gee_concurrent_set_range_beyond (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, range, _tmp68_);
	} else {
		_tmp65_ = FALSE;
	}
	if (_tmp65_) {
		_gee_concurrent_set_tower_unref0 (_vala_out_curr);
		_vala_out_curr = NULL;
	}
	if (out_curr) {
		*out_curr = _vala_out_curr;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_out_curr);
	}
	if (prev) {
		*prev = _vala_prev;
	} else {
		gee_concurrent_set_tower_iter_destroy (&_vala_prev);
	}
}

static gboolean
gee_concurrent_set_range_proceed (GType g_type,
                                  GBoxedCopyFunc g_dup_func,
                                  GDestroyNotify g_destroy_func,
                                  GeeConcurrentSetRange* range,
                                  GeeConcurrentSetTower** prev,
                                  GeeConcurrentSetTower** curr,
                                  guint8 level)
{
	gboolean result;
	g_return_val_if_fail (range != NULL, FALSE);
	g_return_val_if_fail (*curr != NULL, FALSE);
	switch (range->_type) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = FALSE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSet* _tmp0_;
			GCompareDataFunc _tmp1_;
			gpointer _tmp1__target;
			gboolean _tmp2_;
			_tmp0_ = range->_set;
			_tmp1_ = _tmp0_->priv->_cmp;
			_tmp1__target = _tmp0_->priv->_cmp_target;
			_tmp2_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp1_, _tmp1__target, prev, curr, level, FALSE);
			result = _tmp2_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetTower* tmp_prev = NULL;
			GeeConcurrentSetTower* _tmp3_;
			GeeConcurrentSetTower* tmp_curr = NULL;
			GeeConcurrentSetTower* _tmp4_;
			GeeConcurrentSet* _tmp5_;
			GCompareDataFunc _tmp6_;
			gpointer _tmp6__target;
			gboolean _tmp7_;
			_tmp3_ = _gee_concurrent_set_tower_ref0 (*prev);
			tmp_prev = _tmp3_;
			_tmp4_ = _gee_concurrent_set_tower_ref0 (*curr);
			tmp_curr = _tmp4_;
			_tmp5_ = range->_set;
			_tmp6_ = _tmp5_->priv->_cmp;
			_tmp6__target = _tmp5_->priv->_cmp_target;
			_tmp7_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp6_, _tmp6__target, &tmp_prev, &tmp_curr, level, FALSE);
			if (!_tmp7_) {
				result = FALSE;
				_gee_concurrent_set_tower_unref0 (tmp_curr);
				_gee_concurrent_set_tower_unref0 (tmp_prev);
				return result;
			} else {
				GeeConcurrentSet* _tmp8_;
				GCompareDataFunc _tmp9_;
				gpointer _tmp9__target;
				GeeConcurrentSetTower* _tmp10_;
				gconstpointer _tmp11_;
				_tmp8_ = range->_set;
				_tmp9_ = _tmp8_->priv->_cmp;
				_tmp9__target = _tmp8_->priv->_cmp_target;
				_tmp10_ = tmp_curr;
				_tmp11_ = range->_end;
				if (gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, _tmp11_) >= 0) {
					result = FALSE;
					_gee_concurrent_set_tower_unref0 (tmp_curr);
					_gee_concurrent_set_tower_unref0 (tmp_prev);
					return result;
				} else {
					GeeConcurrentSetTower* _tmp12_;
					GeeConcurrentSetTower* _tmp13_;
					_tmp12_ = tmp_prev;
					tmp_prev = NULL;
					_gee_concurrent_set_tower_unref0 (*prev);
					*prev = _tmp12_;
					_tmp13_ = tmp_curr;
					tmp_curr = NULL;
					_gee_concurrent_set_tower_unref0 (*curr);
					*curr = _tmp13_;
					result = TRUE;
					_gee_concurrent_set_tower_unref0 (tmp_curr);
					_gee_concurrent_set_tower_unref0 (tmp_prev);
					return result;
				}
			}
			_gee_concurrent_set_tower_unref0 (tmp_curr);
			_gee_concurrent_set_tower_unref0 (tmp_prev);
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}

static gboolean
gee_concurrent_set_range_inside (GType g_type,
                                 GBoxedCopyFunc g_dup_func,
                                 GDestroyNotify g_destroy_func,
                                 GeeConcurrentSetRange* range,
                                 gconstpointer val)
{
	gboolean result;
	g_return_val_if_fail (range != NULL, FALSE);
	switch (range->_type) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSet* _tmp0_;
			GCompareDataFunc _tmp1_;
			gpointer _tmp1__target;
			gconstpointer _tmp2_;
			_tmp0_ = range->_set;
			_tmp1_ = _tmp0_->priv->_cmp;
			_tmp1__target = _tmp0_->priv->_cmp_target;
			_tmp2_ = range->_end;
			result = _tmp1_ (val, _tmp2_, _tmp1__target) < 0;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSet* _tmp3_;
			GCompareDataFunc _tmp4_;
			gpointer _tmp4__target;
			gconstpointer _tmp5_;
			_tmp3_ = range->_set;
			_tmp4_ = _tmp3_->priv->_cmp;
			_tmp4__target = _tmp3_->priv->_cmp_target;
			_tmp5_ = range->_start;
			result = _tmp4_ (val, _tmp5_, _tmp4__target) >= 0;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			gboolean _tmp6_ = FALSE;
			GeeConcurrentSet* _tmp7_;
			GCompareDataFunc _tmp8_;
			gpointer _tmp8__target;
			gconstpointer _tmp9_;
			_tmp7_ = range->_set;
			_tmp8_ = _tmp7_->priv->_cmp;
			_tmp8__target = _tmp7_->priv->_cmp_target;
			_tmp9_ = range->_start;
			if (_tmp8_ (val, _tmp9_, _tmp8__target) >= 0) {
				GeeConcurrentSet* _tmp10_;
				GCompareDataFunc _tmp11_;
				gpointer _tmp11__target;
				gconstpointer _tmp12_;
				_tmp10_ = range->_set;
				_tmp11_ = _tmp10_->priv->_cmp;
				_tmp11__target = _tmp10_->priv->_cmp_target;
				_tmp12_ = range->_end;
				_tmp6_ = _tmp11_ (val, _tmp12_, _tmp11__target) < 0;
			} else {
				_tmp6_ = FALSE;
			}
			result = _tmp6_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = FALSE;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}

static gboolean
gee_concurrent_set_range_beyond (GType g_type,
                                 GBoxedCopyFunc g_dup_func,
                                 GDestroyNotify g_destroy_func,
                                 GeeConcurrentSetRange* range,
                                 GeeConcurrentSetTower* tw)
{
	gboolean result;
	g_return_val_if_fail (range != NULL, FALSE);
	g_return_val_if_fail (tw != NULL, FALSE);
	switch (range->_type) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = TRUE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			result = FALSE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSet* _tmp0_;
			GCompareDataFunc _tmp1_;
			gpointer _tmp1__target;
			gconstpointer _tmp2_;
			_tmp0_ = range->_set;
			_tmp1_ = _tmp0_->priv->_cmp;
			_tmp1__target = _tmp0_->priv->_cmp_target;
			_tmp2_ = range->_end;
			result = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, _tmp1_, _tmp1__target, tw, _tmp2_) >= 0;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}

static gint
gee_concurrent_set_range_cmp (GType g_type,
                              GBoxedCopyFunc g_dup_func,
                              GDestroyNotify g_destroy_func,
                              GeeConcurrentSetRange* range,
                              gconstpointer val)
{
	gint result;
	g_return_val_if_fail (range != NULL, 0);
	switch (range->_type) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRangePosition _tmp0_ = 0;
			GeeConcurrentSet* _tmp1_;
			GCompareDataFunc _tmp2_;
			gpointer _tmp2__target;
			gconstpointer _tmp3_;
			_tmp1_ = range->_set;
			_tmp2_ = _tmp1_->priv->_cmp;
			_tmp2__target = _tmp1_->priv->_cmp_target;
			_tmp3_ = range->_end;
			if (_tmp2_ (val, _tmp3_, _tmp2__target) < 0) {
				_tmp0_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
			} else {
				_tmp0_ = GEE_CONCURRENT_SET_RANGE_POSITION_AFTER;
			}
			result = (gint) _tmp0_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRangePosition _tmp4_ = 0;
			GeeConcurrentSet* _tmp5_;
			GCompareDataFunc _tmp6_;
			gpointer _tmp6__target;
			gconstpointer _tmp7_;
			_tmp5_ = range->_set;
			_tmp6_ = _tmp5_->priv->_cmp;
			_tmp6__target = _tmp5_->priv->_cmp_target;
			_tmp7_ = range->_start;
			if (_tmp6_ (val, _tmp7_, _tmp6__target) >= 0) {
				_tmp4_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
			} else {
				_tmp4_ = GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE;
			}
			result = (gint) _tmp4_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRangePosition _tmp8_ = 0;
			GeeConcurrentSet* _tmp9_;
			GCompareDataFunc _tmp10_;
			gpointer _tmp10__target;
			gconstpointer _tmp11_;
			_tmp9_ = range->_set;
			_tmp10_ = _tmp9_->priv->_cmp;
			_tmp10__target = _tmp9_->priv->_cmp_target;
			_tmp11_ = range->_start;
			if (_tmp10_ (val, _tmp11_, _tmp10__target) >= 0) {
				GeeConcurrentSetRangePosition _tmp12_ = 0;
				GeeConcurrentSet* _tmp13_;
				GCompareDataFunc _tmp14_;
				gpointer _tmp14__target;
				gconstpointer _tmp15_;
				_tmp13_ = range->_set;
				_tmp14_ = _tmp13_->priv->_cmp;
				_tmp14__target = _tmp13_->priv->_cmp_target;
				_tmp15_ = range->_end;
				if (_tmp14_ (val, _tmp15_, _tmp14__target) < 0) {
					_tmp12_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
				} else {
					_tmp12_ = GEE_CONCURRENT_SET_RANGE_POSITION_AFTER;
				}
				_tmp8_ = _tmp12_;
			} else {
				_tmp8_ = GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE;
			}
			result = (gint) _tmp8_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = (gint) GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}

static void
gee_concurrent_set_value_range_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
gee_concurrent_set_value_range_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		gee_concurrent_set_range_unref (value->data[0].v_pointer);
	}
}

static void
gee_concurrent_set_value_range_copy_value (const GValue* src_value,
                                           GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gee_concurrent_set_range_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
gee_concurrent_set_value_range_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
gee_concurrent_set_value_range_collect_value (GValue* value,
                                              guint n_collect_values,
                                              GTypeCValue* collect_values,
                                              guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		GeeConcurrentSetRange * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gee_concurrent_set_range_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
gee_concurrent_set_value_range_lcopy_value (const GValue* value,
                                            guint n_collect_values,
                                            GTypeCValue* collect_values,
                                            guint collect_flags)
{
	GeeConcurrentSetRange ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gee_concurrent_set_range_ref (value->data[0].v_pointer);
	}
	return NULL;
}

static GParamSpec*
gee_concurrent_set_param_spec_range (const gchar* name,
                                     const gchar* nick,
                                     const gchar* blurb,
                                     GType object_type,
                                     GParamFlags flags)
{
	GeeConcurrentSetParamSpecRange* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GEE_CONCURRENT_SET_TYPE_RANGE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

static gpointer
gee_concurrent_set_value_get_range (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE), NULL);
	return value->data[0].v_pointer;
}

static void
gee_concurrent_set_value_set_range (GValue* value,
                                    gpointer v_object)
{
	GeeConcurrentSetRange * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gee_concurrent_set_range_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_range_unref (old);
	}
}

static void
gee_concurrent_set_value_take_range (GValue* value,
                                     gpointer v_object)
{
	GeeConcurrentSetRange * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_range_unref (old);
	}
}

static void
gee_concurrent_set_range_class_init (GeeConcurrentSetRangeClass * klass,
                                     gpointer klass_data)
{
	gee_concurrent_set_range_parent_class = g_type_class_peek_parent (klass);
	((GeeConcurrentSetRangeClass *) klass)->finalize = gee_concurrent_set_range_finalize;
	g_type_class_adjust_private_offset (klass, &GeeConcurrentSetRange_private_offset);
}

static void
gee_concurrent_set_range_instance_init (GeeConcurrentSetRange * self,
                                        gpointer klass)
{
	self->priv = gee_concurrent_set_range_get_instance_private (self);
	self->ref_count = 1;
}

static void
gee_concurrent_set_range_finalize (GeeConcurrentSetRange * obj)
{
	GeeConcurrentSetRange * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRange);
	g_signal_handlers_destroy (self);
	((self->_start == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_start = (self->priv->g_destroy_func (self->_start), NULL));
	((self->_end == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_end = (self->priv->g_destroy_func (self->_end), NULL));
	gee_concurrent_set_tower_iter_destroy (&self->_bookmark);
	_g_object_unref0 (self->_set);
}

static GType
gee_concurrent_set_range_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { gee_concurrent_set_value_range_init, gee_concurrent_set_value_range_free_value, gee_concurrent_set_value_range_copy_value, gee_concurrent_set_value_range_peek_pointer, "p", gee_concurrent_set_value_range_collect_value, "p", gee_concurrent_set_value_range_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetRangeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_range_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetRange), 0, (GInstanceInitFunc) gee_concurrent_set_range_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType gee_concurrent_set_range_type_id;
	gee_concurrent_set_range_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GeeConcurrentSetRange", &g_define_type_info, &g_define_type_fundamental_info, 0);
	GeeConcurrentSetRange_private_offset = g_type_add_instance_private (gee_concurrent_set_range_type_id, sizeof (GeeConcurrentSetRangePrivate));
	return gee_concurrent_set_range_type_id;
}

static GType
gee_concurrent_set_range_get_type (void)
{
	static volatile gsize gee_concurrent_set_range_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_type_id__once)) {
		GType gee_concurrent_set_range_type_id;
		gee_concurrent_set_range_type_id = gee_concurrent_set_range_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_range_type_id__once, gee_concurrent_set_range_type_id);
	}
	return gee_concurrent_set_range_type_id__once;
}

static gpointer
gee_concurrent_set_range_ref (gpointer instance)
{
	GeeConcurrentSetRange * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

static void
gee_concurrent_set_range_unref (gpointer instance)
{
	GeeConcurrentSetRange * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GEE_CONCURRENT_SET_RANGE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
gee_concurrent_set_tower_get_instance_private (GeeConcurrentSetTower* self)
{
	return G_STRUCT_MEMBER_P (self, GeeConcurrentSetTower_private_offset);
}

static GeeConcurrentSetTower*
gee_concurrent_set_tower_construct (GType object_type,
                                    GType g_type,
                                    GBoxedCopyFunc g_dup_func,
                                    GDestroyNotify g_destroy_func,
                                    gconstpointer data,
                                    guint8 height)
{
	GeeConcurrentSetTower* self = NULL;
	GeeConcurrentSetTowerNode* _tmp0_;
	gpointer _tmp1_;
	GeeConcurrentSetTowerNode* _tmp2_;
	gint _tmp2__length1;
	self = (GeeConcurrentSetTower*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = g_new0 (GeeConcurrentSetTowerNode, height);
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = _tmp0_;
	_tmp1_ = ((data != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) data) : ((gpointer) data);
	((self->_data == NULL) || (g_destroy_func == NULL)) ? NULL : (self->_data = (g_destroy_func (self->_data), NULL));
	self->_data = _tmp1_;
	self->_height = 0;
	_tmp2_ = self->_nodes;
	_tmp2__length1 = -1;
	g_atomic_pointer_set ((volatile gpointer *) (&_tmp2_[0]._backlink), NULL);
	return self;
}

static GeeConcurrentSetTower*
gee_concurrent_set_tower_new (GType g_type,
                              GBoxedCopyFunc g_dup_func,
                              GDestroyNotify g_destroy_func,
                              gconstpointer data,
                              guint8 height)
{
	return gee_concurrent_set_tower_construct (GEE_CONCURRENT_SET_TYPE_TOWER, g_type, g_dup_func, g_destroy_func, data, height);
}

static GeeConcurrentSetTower*
gee_concurrent_set_tower_construct_head (GType object_type,
                                         GType g_type,
                                         GBoxedCopyFunc g_dup_func,
                                         GDestroyNotify g_destroy_func)
{
	GeeConcurrentSetTower* self = NULL;
	GeeConcurrentSetTowerNode* _tmp0_;
	self = (GeeConcurrentSetTower*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = g_new0 (GeeConcurrentSetTowerNode, GEE_CONCURRENT_SET__MAX_HEIGHT);
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = _tmp0_;
	self->_height = -1;
	return self;
}

static GeeConcurrentSetTower*
gee_concurrent_set_tower_new_head (GType g_type,
                                   GBoxedCopyFunc g_dup_func,
                                   GDestroyNotify g_destroy_func)
{
	return gee_concurrent_set_tower_construct_head (GEE_CONCURRENT_SET_TYPE_TOWER, g_type, g_dup_func, g_destroy_func);
}

static inline gboolean
gee_concurrent_set_tower_search (GType g_type,
                                 GBoxedCopyFunc g_dup_func,
                                 GDestroyNotify g_destroy_func,
                                 GCompareDataFunc cmp,
                                 gpointer cmp_target,
                                 gconstpointer key,
                                 GeeConcurrentSetTower** prev,
                                 GeeConcurrentSetTower** next,
                                 guint8 to_level,
                                 guint8 from_level)
{
	GeeConcurrentSetTower* _vala_next = NULL;
	gboolean res = FALSE;
	gboolean result;
	g_return_val_if_fail (*prev != NULL, FALSE);
	_vala_assert (from_level >= to_level, "from_level >= to_level");
	res = FALSE;
	_gee_concurrent_set_tower_unref0 (_vala_next);
	_vala_next = NULL;
	{
		gint i = 0;
		i = (gint) from_level;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTower* _tmp2_ = NULL;
				gboolean _tmp3_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ - 1;
				}
				_tmp0_ = FALSE;
				if (!(i >= ((gint) to_level))) {
					break;
				}
				_tmp3_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, key, prev, &_tmp2_, (guint8) i);
				_gee_concurrent_set_tower_unref0 (_vala_next);
				_vala_next = _tmp2_;
				res = _tmp3_;
			}
		}
	}
	result = res;
	if (next) {
		*next = _vala_next;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_next);
	}
	return result;
}

static inline gboolean
gee_concurrent_set_tower_search_from_bookmark (GType g_type,
                                               GBoxedCopyFunc g_dup_func,
                                               GDestroyNotify g_destroy_func,
                                               GCompareDataFunc cmp,
                                               gpointer cmp_target,
                                               gconstpointer key,
                                               GeeConcurrentSetTowerIter* prev,
                                               GeeConcurrentSetTowerIter* next,
                                               guint8 to_level,
                                               guint8 from_level)
{
	GeeConcurrentSetTowerIter _vala_next = {0};
	gboolean res = FALSE;
	gboolean result;
	g_return_val_if_fail (prev != NULL, FALSE);
	_vala_assert (from_level >= to_level, "from_level >= to_level");
	gee_concurrent_set_tower_iter_destroy (&_vala_next);
	memset (&_vala_next, 0, sizeof (GeeConcurrentSetTowerIter));
	res = FALSE;
	{
		gint i = 0;
		i = (gint) from_level;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTower* tmp_prev = NULL;
				GeeConcurrentSetTowerIter _tmp2_;
				GeeConcurrentSetTower* _tmp3_;
				GeeConcurrentSetTower* tmp_next = NULL;
				GeeConcurrentSetTower* _tmp4_ = NULL;
				gboolean _tmp5_;
				GeeConcurrentSetTowerIter _tmp7_;
				GeeConcurrentSetTower* _tmp8_;
				GeeConcurrentSetTower* _tmp9_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ - 1;
				}
				_tmp0_ = FALSE;
				if (!(i >= ((gint) to_level))) {
					break;
				}
				_tmp2_ = *prev;
				_tmp3_ = _tmp2_._iter[i];
				tmp_prev = _tmp3_;
				_tmp5_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, key, &(*prev)._iter[i], &_tmp4_, (guint8) i);
				_gee_concurrent_set_tower_unref0 (tmp_next);
				tmp_next = _tmp4_;
				res = _tmp5_;
				if ((&_vala_next) != NULL) {
					GeeConcurrentSetTower* _tmp6_;
					_tmp6_ = tmp_next;
					tmp_next = NULL;
					_gee_concurrent_set_tower_unref0 (_vala_next._iter[i]);
					_vala_next._iter[i] = _tmp6_;
				}
				_tmp7_ = *prev;
				_tmp8_ = _tmp7_._iter[i];
				_tmp9_ = tmp_prev;
				if (_tmp8_ != _tmp9_) {
					GeeConcurrentSetTowerIter _tmp10_;
					GeeConcurrentSetTower* _tmp11_;
					GeeConcurrentSetTower* _tmp12_;
					gboolean _tmp13_ = FALSE;
					_tmp10_ = *prev;
					_tmp11_ = _tmp10_._iter[i];
					_tmp12_ = _gee_concurrent_set_tower_ref0 (_tmp11_);
					_gee_concurrent_set_tower_unref0 ((*prev)._iter[i]);
					(*prev)._iter[i] = _tmp12_;
					if (i > ((gint) to_level)) {
						GeeConcurrentSetTowerIter _tmp14_;
						GeeConcurrentSetTower* _tmp15_;
						GeeConcurrentSetTowerIter _tmp16_;
						GeeConcurrentSetTower* _tmp17_;
						_tmp14_ = *prev;
						_tmp15_ = _tmp14_._iter[i - 1];
						_tmp16_ = *prev;
						_tmp17_ = _tmp16_._iter[i];
						_tmp13_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, _tmp15_, _tmp17_) <= 0;
					} else {
						_tmp13_ = FALSE;
					}
					if (_tmp13_) {
						GeeConcurrentSetTowerIter _tmp18_;
						GeeConcurrentSetTower* _tmp19_;
						GeeConcurrentSetTower* _tmp20_;
						_tmp18_ = *prev;
						_tmp19_ = _tmp18_._iter[i];
						_tmp20_ = _gee_concurrent_set_tower_ref0 (_tmp19_);
						_gee_concurrent_set_tower_unref0 ((*prev)._iter[i - 1]);
						(*prev)._iter[i - 1] = _tmp20_;
					}
				}
				_gee_concurrent_set_tower_unref0 (tmp_next);
			}
		}
	}
	result = res;
	if (next) {
		*next = _vala_next;
	} else {
		gee_concurrent_set_tower_iter_destroy (&_vala_next);
	}
	return result;
}

static inline gboolean
gee_concurrent_set_tower_search_helper (GType g_type,
                                        GBoxedCopyFunc g_dup_func,
                                        GDestroyNotify g_destroy_func,
                                        GCompareDataFunc cmp,
                                        gpointer cmp_target,
                                        gconstpointer key,
                                        GeeConcurrentSetTower** prev,
                                        GeeConcurrentSetTower** next,
                                        guint8 level)
{
	GeeConcurrentSetTower* _vala_next = NULL;
	GeeConcurrentSetTower* _tmp0_;
	gboolean _tmp6_ = FALSE;
	GeeConcurrentSetTower* _tmp7_;
	gboolean result;
	_tmp0_ = gee_concurrent_set_tower_get_next (*prev, level);
	_gee_concurrent_set_tower_unref0 (_vala_next);
	_vala_next = _tmp0_;
	while (TRUE) {
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		GeeConcurrentSetTower* _tmp3_;
		_tmp3_ = _vala_next;
		if (_tmp3_ != NULL) {
			GeeConcurrentSetTower* _tmp4_;
			_tmp4_ = _vala_next;
			_tmp2_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, _tmp4_, key) < 0;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			gboolean _tmp5_;
			_tmp5_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, prev, &_vala_next, level, TRUE);
			_tmp1_ = _tmp5_;
		} else {
			_tmp1_ = FALSE;
		}
		if (!_tmp1_) {
			break;
		}
	}
	_tmp7_ = _vala_next;
	if (_tmp7_ != NULL) {
		GeeConcurrentSetTower* _tmp8_;
		gconstpointer _tmp9_;
		_tmp8_ = _vala_next;
		_tmp9_ = _tmp8_->_data;
		_tmp6_ = cmp (key, _tmp9_, cmp_target) == 0;
	} else {
		_tmp6_ = FALSE;
	}
	result = _tmp6_;
	if (next) {
		*next = _vala_next;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_next);
	}
	return result;
}

static inline GeeConcurrentSetTower*
gee_concurrent_set_tower_insert (GType g_type,
                                 GBoxedCopyFunc g_dup_func,
                                 GDestroyNotify g_destroy_func,
                                 GCompareDataFunc cmp,
                                 gpointer cmp_target,
                                 GeeConcurrentSetTowerIter* prev,
                                 gconstpointer key,
                                 guint8 chosen_level)
{
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetTower* result;
	g_return_val_if_fail (prev != NULL, NULL);
	_tmp0_ = gee_concurrent_set_tower_insert_helper (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, prev, key, chosen_level, chosen_level);
	result = _tmp0_;
	return result;
}

static inline GeeConcurrentSetTower*
gee_concurrent_set_tower_insert_helper (GType g_type,
                                        GBoxedCopyFunc g_dup_func,
                                        GDestroyNotify g_destroy_func,
                                        GCompareDataFunc cmp,
                                        gpointer cmp_target,
                                        GeeConcurrentSetTowerIter* prev,
                                        gconstpointer key,
                                        guint8 chosen_level,
                                        guint8 level)
{
	GeeConcurrentSetTower* new_tower = NULL;
	GeeConcurrentSetTower* next = NULL;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	gboolean _tmp1_;
	GeeConcurrentSetTower* _tmp11_;
	GeeConcurrentSetTower* _tmp33_;
	GeeConcurrentSetTower* _tmp34_;
	GeeConcurrentSetTower* result;
	g_return_val_if_fail (prev != NULL, NULL);
	_tmp1_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, key, &(*prev)._iter[level], &_tmp0_, level);
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp0_;
	if (_tmp1_) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	if (((gint) level) > 0) {
		GeeConcurrentSetTowerIter _tmp2_;
		GeeConcurrentSetTower* _tmp3_;
		GeeConcurrentSetTowerIter _tmp4_;
		GeeConcurrentSetTower* _tmp5_;
		GeeConcurrentSetTower* _tmp9_;
		_tmp2_ = *prev;
		_tmp3_ = _tmp2_._iter[level];
		_tmp4_ = *prev;
		_tmp5_ = _tmp4_._iter[level - 1];
		if (gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, _tmp3_, _tmp5_) >= 0) {
			GeeConcurrentSetTowerIter _tmp6_;
			GeeConcurrentSetTower* _tmp7_;
			GeeConcurrentSetTower* _tmp8_;
			_tmp6_ = *prev;
			_tmp7_ = _tmp6_._iter[level];
			_tmp8_ = _gee_concurrent_set_tower_ref0 (_tmp7_);
			_gee_concurrent_set_tower_unref0 ((*prev)._iter[level - 1]);
			(*prev)._iter[level - 1] = _tmp8_;
		}
		_tmp9_ = gee_concurrent_set_tower_insert_helper (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, prev, key, chosen_level, (guint8) (level - 1));
		_gee_concurrent_set_tower_unref0 (new_tower);
		new_tower = _tmp9_;
	} else {
		GeeConcurrentSetTower* _tmp10_;
		_tmp10_ = gee_concurrent_set_tower_new (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, key, (guint8) (chosen_level + 1));
		_gee_concurrent_set_tower_unref0 (new_tower);
		new_tower = _tmp10_;
	}
	_tmp11_ = new_tower;
	if (_tmp11_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	while (TRUE) {
		GeeConcurrentSetState prev_state = 0;
		GeeConcurrentSetTower* prev_next = NULL;
		GeeConcurrentSetTowerIter _tmp12_;
		GeeConcurrentSetTower* _tmp13_;
		GeeConcurrentSetState _tmp14_ = 0;
		GeeConcurrentSetTower* _tmp15_;
		gboolean _tmp32_;
		_tmp12_ = *prev;
		_tmp13_ = _tmp12_._iter[level];
		_tmp15_ = gee_concurrent_set_tower_get_succ (_tmp13_, &_tmp14_, level);
		prev_state = _tmp14_;
		prev_next = _tmp15_;
		if (prev_state == GEE_CONCURRENT_SET_STATE_FLAGGED) {
			GeeConcurrentSetTower* _tmp16_;
			GeeConcurrentSetTowerIter _tmp17_;
			GeeConcurrentSetTower* _tmp18_;
			_tmp16_ = prev_next;
			_tmp17_ = *prev;
			_tmp18_ = _tmp17_._iter[level];
			gee_concurrent_set_tower_help_flagged (_tmp16_, _tmp18_, level);
		} else {
			GeeConcurrentSetTower* _tmp19_;
			GeeConcurrentSetTower* _tmp20_;
			gboolean _result_ = FALSE;
			GeeConcurrentSetTowerIter _tmp21_;
			GeeConcurrentSetTower* _tmp22_;
			GeeConcurrentSetTower* _tmp23_;
			GeeConcurrentSetTower* _tmp24_;
			GeeConcurrentSetTowerIter _tmp25_;
			GeeConcurrentSetTower* _tmp26_;
			GeeConcurrentSetState _tmp27_ = 0;
			GeeConcurrentSetTower* _tmp28_;
			_tmp19_ = new_tower;
			_tmp20_ = next;
			gee_concurrent_set_tower_set_succ (_tmp19_, _tmp20_, GEE_CONCURRENT_SET_STATE_NONE, level);
			_tmp21_ = *prev;
			_tmp22_ = _tmp21_._iter[level];
			_tmp23_ = next;
			_tmp24_ = new_tower;
			_result_ = gee_concurrent_set_tower_compare_and_exchange (_tmp22_, _tmp23_, GEE_CONCURRENT_SET_STATE_NONE, _tmp24_, GEE_CONCURRENT_SET_STATE_NONE, level);
			if (_result_) {
				_gee_concurrent_set_tower_unref0 (prev_next);
				break;
			}
			_tmp25_ = *prev;
			_tmp26_ = _tmp25_._iter[level];
			_tmp28_ = gee_concurrent_set_tower_get_succ (_tmp26_, &_tmp27_, level);
			prev_state = _tmp27_;
			_gee_concurrent_set_tower_unref0 (prev_next);
			prev_next = _tmp28_;
			if (prev_state == GEE_CONCURRENT_SET_STATE_FLAGGED) {
				GeeConcurrentSetTower* _tmp29_;
				GeeConcurrentSetTowerIter _tmp30_;
				GeeConcurrentSetTower* _tmp31_;
				_tmp29_ = prev_next;
				_tmp30_ = *prev;
				_tmp31_ = _tmp30_._iter[level];
				gee_concurrent_set_tower_help_flagged (_tmp29_, _tmp31_, level);
			}
			gee_concurrent_set_tower_backtrace (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, &(*prev)._iter[level], level);
		}
		_tmp32_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, key, &(*prev)._iter[level], NULL, level);
		if (_tmp32_) {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (prev_next);
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (new_tower);
			return result;
		}
		_gee_concurrent_set_tower_unref0 (prev_next);
	}
	_tmp33_ = new_tower;
	g_atomic_int_inc ((volatile gint *) (&_tmp33_->_height));
	_tmp34_ = new_tower;
	if (gee_concurrent_set_tower_get_state (_tmp34_, (guint8) 0) == GEE_CONCURRENT_SET_STATE_MARKED) {
		GeeConcurrentSetTower* _tmp35_;
		_tmp35_ = new_tower;
		gee_concurrent_set_tower_remove_level (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, &(*prev)._iter[level], _tmp35_, level);
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	result = new_tower;
	_gee_concurrent_set_tower_unref0 (next);
	return result;
}

static inline gboolean
gee_concurrent_set_tower_remove_key (GType g_type,
                                     GBoxedCopyFunc g_dup_func,
                                     GDestroyNotify g_destroy_func,
                                     GCompareDataFunc cmp,
                                     gpointer cmp_target,
                                     GeeConcurrentSetTowerIter* prev,
                                     gconstpointer key,
                                     guint8 from_level)
{
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp10_ = NULL;
	gboolean _tmp11_;
	gboolean result;
	g_return_val_if_fail (prev != NULL, FALSE);
	{
		gint i = 0;
		i = (gint) from_level;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				GeeConcurrentSetTower* next = NULL;
				GeeConcurrentSetTower* _tmp2_ = NULL;
				GeeConcurrentSetTowerIter _tmp3_;
				GeeConcurrentSetTower* _tmp4_;
				GeeConcurrentSetTowerIter _tmp5_;
				GeeConcurrentSetTower* _tmp6_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ - 1;
				}
				_tmp0_ = FALSE;
				if (!(i >= 1)) {
					break;
				}
				gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, key, &(*prev)._iter[i], &_tmp2_, (guint8) i);
				_gee_concurrent_set_tower_unref0 (next);
				next = _tmp2_;
				_tmp3_ = *prev;
				_tmp4_ = _tmp3_._iter[i - 1];
				_tmp5_ = *prev;
				_tmp6_ = _tmp5_._iter[i];
				if (gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, _tmp4_, _tmp6_) < 0) {
					GeeConcurrentSetTowerIter _tmp7_;
					GeeConcurrentSetTower* _tmp8_;
					GeeConcurrentSetTower* _tmp9_;
					_tmp7_ = *prev;
					_tmp8_ = _tmp7_._iter[i];
					_tmp9_ = _gee_concurrent_set_tower_ref0 (_tmp8_);
					_gee_concurrent_set_tower_unref0 ((*prev)._iter[i - 1]);
					(*prev)._iter[i - 1] = _tmp9_;
				}
				_gee_concurrent_set_tower_unref0 (next);
			}
		}
	}
	_tmp11_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, key, &(*prev)._iter[0], &_tmp10_, (guint8) 0);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp10_;
	if (_tmp11_) {
		GeeConcurrentSetTower* _tmp12_;
		gboolean _tmp13_;
		_tmp12_ = curr;
		_tmp13_ = gee_concurrent_set_tower_remove (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, prev, _tmp12_);
		result = _tmp13_;
		_gee_concurrent_set_tower_unref0 (curr);
		return result;
	} else {
		result = FALSE;
		_gee_concurrent_set_tower_unref0 (curr);
		return result;
	}
}

static inline gboolean
gee_concurrent_set_tower_remove (GType g_type,
                                 GBoxedCopyFunc g_dup_func,
                                 GDestroyNotify g_destroy_func,
                                 GCompareDataFunc cmp,
                                 gpointer cmp_target,
                                 GeeConcurrentSetTowerIter* prev,
                                 GeeConcurrentSetTower* curr)
{
	gboolean removed = FALSE;
	gboolean _tmp0_;
	gboolean result;
	g_return_val_if_fail (prev != NULL, FALSE);
	g_return_val_if_fail (curr != NULL, FALSE);
	_tmp0_ = gee_concurrent_set_tower_remove_level (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, &(*prev)._iter[0], curr, (guint8) 0);
	removed = _tmp0_;
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				if (!(i < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				gee_concurrent_set_tower_remove_level (g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func, cmp, cmp_target, &(*prev)._iter[i], curr, (guint8) i);
			}
		}
	}
	result = removed;
	return result;
}

static inline gboolean
gee_concurrent_set_tower_remove_level (GType g_type,
                                       GBoxedCopyFunc g_dup_func,
                                       GDestroyNotify g_destroy_func,
                                       GCompareDataFunc cmp,
                                       gpointer cmp_target,
                                       GeeConcurrentSetTower** prev,
                                       GeeConcurrentSetTower* curr,
                                       guint8 level)
{
	gboolean status = FALSE;
	gboolean flagged = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean result;
	g_return_val_if_fail (*prev != NULL, FALSE);
	g_return_val_if_fail (curr != NULL, FALSE);
	_tmp1_ = gee_concurrent_set_tower_try_flag (curr, cmp, cmp_target, prev, &_tmp0_, level);
	status = _tmp0_;
	flagged = _tmp1_;
	if (status) {
		gee_concurrent_set_tower_help_flagged (curr, *prev, level);
	}
	result = flagged;
	return result;
}

static inline gboolean
gee_concurrent_set_tower_proceed (GType g_type,
                                  GBoxedCopyFunc g_dup_func,
                                  GDestroyNotify g_destroy_func,
                                  GCompareDataFunc cmp,
                                  gpointer cmp_target,
                                  GeeConcurrentSetTower** arg_prev,
                                  GeeConcurrentSetTower** arg_curr,
                                  guint8 level,
                                  gboolean force)
{
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetTower* next = NULL;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	gboolean success = FALSE;
	GeeConcurrentSetTower* _tmp13_;
	gboolean _tmp14_ = FALSE;
	gboolean result;
	g_return_val_if_fail (*arg_curr != NULL, FALSE);
	_tmp0_ = _gee_concurrent_set_tower_ref0 (*arg_curr);
	curr = _tmp0_;
	_tmp1_ = curr;
	_tmp2_ = gee_concurrent_set_tower_get_next (_tmp1_, level);
	next = _tmp2_;
	_tmp3_ = next;
	if (_tmp3_ != NULL) {
		while (TRUE) {
			gboolean _tmp4_ = FALSE;
			GeeConcurrentSetTower* _tmp5_;
			gboolean status = FALSE;
			GeeConcurrentSetTower* _tmp7_;
			gboolean _tmp8_ = FALSE;
			GeeConcurrentSetTower* _tmp11_;
			GeeConcurrentSetTower* _tmp12_;
			_tmp5_ = next;
			if (_tmp5_ != NULL) {
				GeeConcurrentSetTower* _tmp6_;
				_tmp6_ = next;
				_tmp4_ = gee_concurrent_set_tower_get_state (_tmp6_, (guint8) 0) == GEE_CONCURRENT_SET_STATE_MARKED;
			} else {
				_tmp4_ = FALSE;
			}
			if (!_tmp4_) {
				break;
			}
			_tmp7_ = next;
			gee_concurrent_set_tower_try_flag (_tmp7_, cmp, cmp_target, &curr, &_tmp8_, level);
			status = _tmp8_;
			if (status) {
				GeeConcurrentSetTower* _tmp9_;
				GeeConcurrentSetTower* _tmp10_;
				_tmp9_ = next;
				_tmp10_ = curr;
				gee_concurrent_set_tower_help_flagged (_tmp9_, _tmp10_, level);
			}
			_tmp11_ = curr;
			_tmp12_ = gee_concurrent_set_tower_get_next (_tmp11_, level);
			_gee_concurrent_set_tower_unref0 (next);
			next = _tmp12_;
		}
	}
	_tmp13_ = next;
	success = _tmp13_ != NULL;
	if (success) {
		_tmp14_ = TRUE;
	} else {
		_tmp14_ = force;
	}
	if (_tmp14_) {
		GeeConcurrentSetTower* _tmp15_;
		GeeConcurrentSetTower* _tmp16_;
		_tmp15_ = curr;
		curr = NULL;
		_gee_concurrent_set_tower_unref0 (*arg_prev);
		*arg_prev = _tmp15_;
		_tmp16_ = next;
		next = NULL;
		_gee_concurrent_set_tower_unref0 (*arg_curr);
		*arg_curr = _tmp16_;
	}
	result = success;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (curr);
	return result;
}

static inline void
gee_concurrent_set_tower_help_marked (GeeConcurrentSetTower* self,
                                      GeeConcurrentSetTower* prev_tower,
                                      guint8 level)
{
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetTower* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prev_tower != NULL);
	_tmp0_ = gee_concurrent_set_tower_get_next (self, level);
	_tmp1_ = _tmp0_;
	gee_concurrent_set_tower_compare_and_exchange (prev_tower, self, GEE_CONCURRENT_SET_STATE_FLAGGED, _tmp1_, GEE_CONCURRENT_SET_STATE_NONE, level);
	_gee_concurrent_set_tower_unref0 (_tmp1_);
}

static inline void
gee_concurrent_set_tower_help_flagged (GeeConcurrentSetTower* self,
                                       GeeConcurrentSetTower* prev,
                                       guint8 level)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (prev != NULL);
	gee_concurrent_set_tower_set_backlink (self, prev, level);
	if (gee_concurrent_set_tower_get_state (self, level) != GEE_CONCURRENT_SET_STATE_MARKED) {
		gee_concurrent_set_tower_try_mark (self, level);
	}
	gee_concurrent_set_tower_help_marked (self, prev, level);
}

static inline void
gee_concurrent_set_tower_try_mark (GeeConcurrentSetTower* self,
                                   guint8 level)
{
	g_return_if_fail (self != NULL);
	{
		gboolean _tmp0_ = FALSE;
		_tmp0_ = TRUE;
		while (TRUE) {
			GeeConcurrentSetTower* next_tower = NULL;
			GeeConcurrentSetTower* _tmp1_;
			gboolean _result_ = FALSE;
			GeeConcurrentSetTower* _tmp2_;
			GeeConcurrentSetTower* _tmp3_;
			if (!_tmp0_) {
				if (!(gee_concurrent_set_tower_get_state (self, level) != GEE_CONCURRENT_SET_STATE_MARKED)) {
					break;
				}
			}
			_tmp0_ = FALSE;
			_tmp1_ = gee_concurrent_set_tower_get_next (self, level);
			next_tower = _tmp1_;
			_tmp2_ = next_tower;
			_tmp3_ = next_tower;
			_result_ = gee_concurrent_set_tower_compare_and_exchange (self, _tmp2_, GEE_CONCURRENT_SET_STATE_NONE, _tmp3_, GEE_CONCURRENT_SET_STATE_MARKED, level);
			if (!_result_) {
				GeeConcurrentSetState state = 0;
				GeeConcurrentSetState _tmp4_ = 0;
				GeeConcurrentSetTower* _tmp5_;
				_tmp5_ = gee_concurrent_set_tower_get_succ (self, &_tmp4_, level);
				state = _tmp4_;
				_gee_concurrent_set_tower_unref0 (next_tower);
				next_tower = _tmp5_;
				if (state == GEE_CONCURRENT_SET_STATE_FLAGGED) {
					GeeConcurrentSetTower* _tmp6_;
					_tmp6_ = next_tower;
					gee_concurrent_set_tower_help_flagged (self, _tmp6_, level);
				}
			}
			_gee_concurrent_set_tower_unref0 (next_tower);
		}
	}
}

static inline gboolean
gee_concurrent_set_tower_try_flag (GeeConcurrentSetTower* self,
                                   GCompareDataFunc cmp,
                                   gpointer cmp_target,
                                   GeeConcurrentSetTower** prev_tower,
                                   gboolean* status,
                                   guint8 level)
{
	gboolean _vala_status = FALSE;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (*prev_tower != NULL, FALSE);
	while (TRUE) {
		gboolean _result_ = FALSE;
		GeeConcurrentSetState result_state = 0;
		GeeConcurrentSetTower* result_tower = NULL;
		GeeConcurrentSetState _tmp0_ = 0;
		GeeConcurrentSetTower* _tmp1_;
		gboolean _tmp2_ = FALSE;
		GeeConcurrentSetTower* _tmp3_;
		gconstpointer _tmp4_;
		gboolean _tmp5_;
		if (gee_concurrent_set_tower_compare_succ (*prev_tower, self, GEE_CONCURRENT_SET_STATE_FLAGGED, level)) {
			_vala_status = TRUE;
			result = FALSE;
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_result_ = gee_concurrent_set_tower_compare_and_exchange (*prev_tower, self, GEE_CONCURRENT_SET_STATE_NONE, self, GEE_CONCURRENT_SET_STATE_FLAGGED, level);
		if (_result_) {
			_vala_status = TRUE;
			result = TRUE;
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_tmp1_ = gee_concurrent_set_tower_get_succ (*prev_tower, &_tmp0_, level);
		result_state = _tmp0_;
		result_tower = _tmp1_;
		_tmp3_ = result_tower;
		if (_tmp3_ == self) {
			_tmp2_ = result_state == GEE_CONCURRENT_SET_STATE_FLAGGED;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			_vala_status = TRUE;
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (result_tower);
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		gee_concurrent_set_tower_backtrace (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, prev_tower, level);
		_tmp4_ = self->_data;
		_tmp5_ = gee_concurrent_set_tower_search_helper (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, cmp, cmp_target, _tmp4_, prev_tower, NULL, level);
		if (!_tmp5_) {
			_vala_status = FALSE;
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (result_tower);
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_gee_concurrent_set_tower_unref0 (result_tower);
	}
}

static inline void
gee_concurrent_set_tower_backtrace (GType g_type,
                                    GBoxedCopyFunc g_dup_func,
                                    GDestroyNotify g_destroy_func,
                                    GeeConcurrentSetTower** curr,
                                    guint8 level)
{
	while (TRUE) {
		GeeConcurrentSetTower* _tmp0_;
		if (!(gee_concurrent_set_tower_get_state (*curr, level) == GEE_CONCURRENT_SET_STATE_MARKED)) {
			break;
		}
		_tmp0_ = gee_concurrent_set_tower_get_backlink (*curr, level);
		_gee_concurrent_set_tower_unref0 (*curr);
		*curr = _tmp0_;
	}
}

static inline gboolean
gee_concurrent_set_tower_compare_and_exchange (GeeConcurrentSetTower* self,
                                               GeeConcurrentSetTower* old_tower,
                                               GeeConcurrentSetState old_state,
                                               GeeConcurrentSetTower* new_tower,
                                               GeeConcurrentSetState new_state,
                                               guint8 level)
{
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	GeeConcurrentSetTower* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (new_tower);
	result = gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &_tmp0_[level]._succ, old_tower, _tmp1_, (gsize) 3, (gsize) old_state, (gsize) new_state);
	return result;
}

static inline gboolean
gee_concurrent_set_tower_compare_succ (GeeConcurrentSetTower* self,
                                       GeeConcurrentSetTower* next,
                                       GeeConcurrentSetState state,
                                       guint8 level)
{
	gsize cur = 0UL;
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	void* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = g_atomic_pointer_get ((volatile gpointer *) (&_tmp0_[level]._succ));
	cur = (gsize) _tmp1_;
	result = cur == (((gsize) next) | ((gsize) state));
	return result;
}

static inline GeeConcurrentSetTower*
gee_concurrent_set_tower_get_next (GeeConcurrentSetTower* self,
                                   guint8 level)
{
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetTower* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_concurrent_set_tower_get_succ (self, NULL, level);
	result = _tmp0_;
	return result;
}

static inline GeeConcurrentSetState
gee_concurrent_set_tower_get_state (GeeConcurrentSetTower* self,
                                    guint8 level)
{
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	void* _tmp1_;
	GeeConcurrentSetState result;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = g_atomic_pointer_get ((volatile gpointer *) (&_tmp0_[level]._succ));
	result = (GeeConcurrentSetState) (((gsize) _tmp1_) & 3);
	return result;
}

static inline GeeConcurrentSetTower*
gee_concurrent_set_tower_get_succ (GeeConcurrentSetTower* self,
                                   GeeConcurrentSetState* state,
                                   guint8 level)
{
	GeeConcurrentSetState _vala_state = 0;
	gsize rstate = 0UL;
	GeeConcurrentSetTower* succ = NULL;
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	gsize _tmp1_ = 0UL;
	gpointer _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp2_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &_tmp0_[level]._succ, (gsize) 3, &_tmp1_);
	rstate = _tmp1_;
	succ = (GeeConcurrentSetTower*) _tmp2_;
	_vala_state = (GeeConcurrentSetState) rstate;
	_tmp3_ = succ;
	succ = NULL;
	result = _tmp3_;
	_gee_concurrent_set_tower_unref0 (succ);
	if (state) {
		*state = _vala_state;
	}
	return result;
}

static inline void
gee_concurrent_set_tower_set_succ (GeeConcurrentSetTower* self,
                                   GeeConcurrentSetTower* next,
                                   GeeConcurrentSetState state,
                                   guint8 level)
{
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	GeeConcurrentSetTower* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (next);
	gee_hazard_pointer_set_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &_tmp0_[level]._succ, _tmp1_, (gsize) 3, (gsize) state);
}

static inline GeeConcurrentSetTower*
gee_concurrent_set_tower_get_backlink (GeeConcurrentSetTower* self,
                                       guint8 level)
{
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	gpointer _tmp1_;
	GeeConcurrentSetTower* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &_tmp0_[level]._backlink, (gsize) 0, NULL);
	result = (GeeConcurrentSetTower*) _tmp1_;
	return result;
}

static inline void
gee_concurrent_set_tower_set_backlink (GeeConcurrentSetTower* self,
                                       GeeConcurrentSetTower* backlink,
                                       guint8 level)
{
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	GeeConcurrentSetTower* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (backlink);
	gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, (GDestroyNotify) gee_concurrent_set_tower_unref, &_tmp0_[level]._backlink, NULL, _tmp1_, (gsize) 0, (gsize) 0, (gsize) 0);
}

static inline gint
gee_concurrent_set_tower_get_height (GeeConcurrentSetTower* self)
{
	gint height = 0;
	gint _tmp0_;
	gint _tmp1_ = 0;
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->_height));
	height = _tmp0_;
	if (height != -1) {
		_tmp1_ = height;
	} else {
		_tmp1_ = GEE_CONCURRENT_SET__MAX_HEIGHT;
	}
	result = _tmp1_;
	return result;
}

static inline gboolean
gee_concurrent_set_tower_is_head (GeeConcurrentSetTower* self)
{
	gint height = 0;
	gint _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->_height));
	height = _tmp0_;
	result = height == -1;
	return result;
}

static inline gint
gee_concurrent_set_tower_compare (GType g_type,
                                  GBoxedCopyFunc g_dup_func,
                                  GDestroyNotify g_destroy_func,
                                  GCompareDataFunc cmp,
                                  gpointer cmp_target,
                                  GeeConcurrentSetTower* a,
                                  GeeConcurrentSetTower* b)
{
	gboolean ah = FALSE;
	gint _tmp0_;
	gboolean bh = FALSE;
	gint _tmp1_;
	gint _tmp2_ = 0;
	gint result;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&a->_height));
	ah = _tmp0_ == -1;
	_tmp1_ = g_atomic_int_get ((volatile gint *) (&b->_height));
	bh = _tmp1_ == -1;
	if (ah) {
		gint _tmp3_ = 0;
		if (bh) {
			_tmp3_ = 0;
		} else {
			_tmp3_ = -1;
		}
		_tmp2_ = _tmp3_;
	} else {
		gint _tmp4_ = 0;
		if (bh) {
			_tmp4_ = 1;
		} else {
			gconstpointer _tmp5_;
			gconstpointer _tmp6_;
			_tmp5_ = a->_data;
			_tmp6_ = b->_data;
			_tmp4_ = cmp (_tmp5_, _tmp6_, cmp_target);
		}
		_tmp2_ = _tmp4_;
	}
	result = _tmp2_;
	return result;
}

static inline gint
gee_concurrent_set_tower_compare_data (GType g_type,
                                       GBoxedCopyFunc g_dup_func,
                                       GDestroyNotify g_destroy_func,
                                       GCompareDataFunc cmp,
                                       gpointer cmp_target,
                                       GeeConcurrentSetTower* a,
                                       gconstpointer b)
{
	gboolean ah = FALSE;
	gint _tmp0_;
	gint _tmp1_ = 0;
	gint result;
	g_return_val_if_fail (a != NULL, 0);
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&a->_height));
	ah = _tmp0_ == -1;
	if (ah) {
		_tmp1_ = -1;
	} else {
		gconstpointer _tmp2_;
		_tmp2_ = a->_data;
		_tmp1_ = cmp (_tmp2_, b, cmp_target);
	}
	result = _tmp1_;
	return result;
}

static void
gee_concurrent_set_value_tower_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
gee_concurrent_set_value_tower_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		gee_concurrent_set_tower_unref (value->data[0].v_pointer);
	}
}

static void
gee_concurrent_set_value_tower_copy_value (const GValue* src_value,
                                           GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gee_concurrent_set_tower_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
gee_concurrent_set_value_tower_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
gee_concurrent_set_value_tower_collect_value (GValue* value,
                                              guint n_collect_values,
                                              GTypeCValue* collect_values,
                                              guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		GeeConcurrentSetTower * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gee_concurrent_set_tower_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
gee_concurrent_set_value_tower_lcopy_value (const GValue* value,
                                            guint n_collect_values,
                                            GTypeCValue* collect_values,
                                            guint collect_flags)
{
	GeeConcurrentSetTower ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gee_concurrent_set_tower_ref (value->data[0].v_pointer);
	}
	return NULL;
}

static GParamSpec*
gee_concurrent_set_param_spec_tower (const gchar* name,
                                     const gchar* nick,
                                     const gchar* blurb,
                                     GType object_type,
                                     GParamFlags flags)
{
	GeeConcurrentSetParamSpecTower* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GEE_CONCURRENT_SET_TYPE_TOWER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

static gpointer
gee_concurrent_set_value_get_tower (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER), NULL);
	return value->data[0].v_pointer;
}

static void
gee_concurrent_set_value_set_tower (GValue* value,
                                    gpointer v_object)
{
	GeeConcurrentSetTower * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_TOWER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gee_concurrent_set_tower_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_tower_unref (old);
	}
}

static void
gee_concurrent_set_value_take_tower (GValue* value,
                                     gpointer v_object)
{
	GeeConcurrentSetTower * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_TOWER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_tower_unref (old);
	}
}

static void
gee_concurrent_set_tower_class_init (GeeConcurrentSetTowerClass * klass,
                                     gpointer klass_data)
{
	gee_concurrent_set_tower_parent_class = g_type_class_peek_parent (klass);
	((GeeConcurrentSetTowerClass *) klass)->finalize = gee_concurrent_set_tower_finalize;
	g_type_class_adjust_private_offset (klass, &GeeConcurrentSetTower_private_offset);
}

static void
gee_concurrent_set_tower_instance_init (GeeConcurrentSetTower * self,
                                        gpointer klass)
{
	self->priv = gee_concurrent_set_tower_get_instance_private (self);
	self->ref_count = 1;
}

static void
gee_concurrent_set_tower_finalize (GeeConcurrentSetTower * obj)
{
	GeeConcurrentSetTower * self;
	gint height = 0;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTower);
	g_signal_handlers_destroy (self);
	height = gee_concurrent_set_tower_get_height (self);
	{
		guint8 i = 0U;
		i = (guint8) 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					guint8 _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(((gint) i) < height)) {
					break;
				}
				gee_concurrent_set_tower_set_succ (self, NULL, GEE_CONCURRENT_SET_STATE_NONE, i);
				gee_concurrent_set_tower_set_backlink (self, NULL, i);
			}
		}
	}
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = NULL;
	self->_nodes = (g_free (self->_nodes), NULL);
	((self->_data == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_data = (self->priv->g_destroy_func (self->_data), NULL));
}

static GType
gee_concurrent_set_tower_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { gee_concurrent_set_value_tower_init, gee_concurrent_set_value_tower_free_value, gee_concurrent_set_value_tower_copy_value, gee_concurrent_set_value_tower_peek_pointer, "p", gee_concurrent_set_value_tower_collect_value, "p", gee_concurrent_set_value_tower_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetTowerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_tower_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetTower), 0, (GInstanceInitFunc) gee_concurrent_set_tower_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType gee_concurrent_set_tower_type_id;
	gee_concurrent_set_tower_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GeeConcurrentSetTower", &g_define_type_info, &g_define_type_fundamental_info, 0);
	GeeConcurrentSetTower_private_offset = g_type_add_instance_private (gee_concurrent_set_tower_type_id, sizeof (GeeConcurrentSetTowerPrivate));
	return gee_concurrent_set_tower_type_id;
}

static GType
gee_concurrent_set_tower_get_type (void)
{
	static volatile gsize gee_concurrent_set_tower_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_type_id__once)) {
		GType gee_concurrent_set_tower_type_id;
		gee_concurrent_set_tower_type_id = gee_concurrent_set_tower_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_tower_type_id__once, gee_concurrent_set_tower_type_id);
	}
	return gee_concurrent_set_tower_type_id__once;
}

static gpointer
gee_concurrent_set_tower_ref (gpointer instance)
{
	GeeConcurrentSetTower * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

static void
gee_concurrent_set_tower_unref (gpointer instance)
{
	GeeConcurrentSetTower * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GEE_CONCURRENT_SET_TOWER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static GeeConcurrentSetTowerNode*
gee_concurrent_set_tower_node_dup (const GeeConcurrentSetTowerNode* self)
{
	GeeConcurrentSetTowerNode* dup;
	dup = g_new0 (GeeConcurrentSetTowerNode, 1);
	memcpy (dup, self, sizeof (GeeConcurrentSetTowerNode));
	return dup;
}

static void
gee_concurrent_set_tower_node_free (GeeConcurrentSetTowerNode* self)
{
	g_free (self);
}

static GType
gee_concurrent_set_tower_node_get_type_once (void)
{
	GType gee_concurrent_set_tower_node_type_id;
	gee_concurrent_set_tower_node_type_id = g_boxed_type_register_static ("GeeConcurrentSetTowerNode", (GBoxedCopyFunc) gee_concurrent_set_tower_node_dup, (GBoxedFreeFunc) gee_concurrent_set_tower_node_free);
	return gee_concurrent_set_tower_node_type_id;
}

static GType
gee_concurrent_set_tower_node_get_type (void)
{
	static volatile gsize gee_concurrent_set_tower_node_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_node_type_id__once)) {
		GType gee_concurrent_set_tower_node_type_id;
		gee_concurrent_set_tower_node_type_id = gee_concurrent_set_tower_node_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_tower_node_type_id__once, gee_concurrent_set_tower_node_type_id);
	}
	return gee_concurrent_set_tower_node_type_id__once;
}

static void
_vala_array_copy1 (GeeConcurrentSetTower* * self,
                   GeeConcurrentSetTower* * dest)
{
	gint i;
	for (i = 0; i < 31; i++) {
		GeeConcurrentSetTower* _tmp0_;
		_tmp0_ = _gee_concurrent_set_tower_ref0 (self[i]);
		dest[i] = _tmp0_;
	}
}

static void
gee_concurrent_set_tower_iter_copy (const GeeConcurrentSetTowerIter* self,
                                    GeeConcurrentSetTowerIter* dest)
{
	GeeConcurrentSetTower* _tmp0_[31];
	gint _tmp0__length1;
	_vala_array_copy1 ((*self)._iter, _tmp0_);
	_vala_array_destroy ((*dest)._iter, 31, (GDestroyNotify) gee_concurrent_set_tower_unref);
	memcpy ((*dest)._iter, _tmp0_, 31 * sizeof (GeeConcurrentSetTower*));
}

static void
gee_concurrent_set_tower_iter_destroy (GeeConcurrentSetTowerIter* self)
{
	_vala_array_destroy ((*self)._iter, 31, (GDestroyNotify) gee_concurrent_set_tower_unref);
}

static GeeConcurrentSetTowerIter*
gee_concurrent_set_tower_iter_dup (const GeeConcurrentSetTowerIter* self)
{
	GeeConcurrentSetTowerIter* dup;
	dup = g_new0 (GeeConcurrentSetTowerIter, 1);
	gee_concurrent_set_tower_iter_copy (self, dup);
	return dup;
}

static void
gee_concurrent_set_tower_iter_free (GeeConcurrentSetTowerIter* self)
{
	gee_concurrent_set_tower_iter_destroy (self);
	g_free (self);
}

static GType
gee_concurrent_set_tower_iter_get_type_once (void)
{
	GType gee_concurrent_set_tower_iter_type_id;
	gee_concurrent_set_tower_iter_type_id = g_boxed_type_register_static ("GeeConcurrentSetTowerIter", (GBoxedCopyFunc) gee_concurrent_set_tower_iter_dup, (GBoxedFreeFunc) gee_concurrent_set_tower_iter_free);
	return gee_concurrent_set_tower_iter_type_id;
}

static GType
gee_concurrent_set_tower_iter_get_type (void)
{
	static volatile gsize gee_concurrent_set_tower_iter_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_iter_type_id__once)) {
		GType gee_concurrent_set_tower_iter_type_id;
		gee_concurrent_set_tower_iter_type_id = gee_concurrent_set_tower_iter_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_tower_iter_type_id__once, gee_concurrent_set_tower_iter_type_id);
	}
	return gee_concurrent_set_tower_iter_type_id__once;
}

static void
gee_concurrent_set_class_init (GeeConcurrentSetClass * klass,
                               gpointer klass_data)
{
	GPrivate* _tmp0_;
	gee_concurrent_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeConcurrentSet_private_offset);
	((GeeAbstractCollectionClass *) klass)->iterator = (GeeIterator* (*) (GeeAbstractCollection*)) gee_concurrent_set_real_iterator;
	((GeeAbstractCollectionClass *) klass)->contains = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_concurrent_set_real_contains;
	((GeeAbstractCollectionClass *) klass)->add = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_concurrent_set_real_add;
	((GeeAbstractCollectionClass *) klass)->remove = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_concurrent_set_real_remove;
	((GeeAbstractCollectionClass *) klass)->clear = (void (*) (GeeAbstractCollection*)) gee_concurrent_set_real_clear;
	((GeeAbstractSortedSetClass *) klass)->first = (gpointer (*) (GeeAbstractSortedSet*)) gee_concurrent_set_real_first;
	((GeeAbstractSortedSetClass *) klass)->last = (gpointer (*) (GeeAbstractSortedSet*)) gee_concurrent_set_real_last;
	((GeeAbstractSortedSetClass *) klass)->iterator_at = (GeeIterator* (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_real_iterator_at;
	((GeeAbstractSortedSetClass *) klass)->lower = (gpointer (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_real_lower;
	((GeeAbstractSortedSetClass *) klass)->higher = (gpointer (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_real_higher;
	((GeeAbstractSortedSetClass *) klass)->floor = (gpointer (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_real_floor;
	((GeeAbstractSortedSetClass *) klass)->ceil = (gpointer (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_real_ceil;
	((GeeAbstractSortedSetClass *) klass)->head_set = (GeeSortedSet* (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_real_head_set;
	((GeeAbstractSortedSetClass *) klass)->tail_set = (GeeSortedSet* (*) (GeeAbstractSortedSet*, gconstpointer)) gee_concurrent_set_real_tail_set;
	((GeeAbstractSortedSetClass *) klass)->sub_set = (GeeSortedSet* (*) (GeeAbstractSortedSet*, gconstpointer, gconstpointer)) gee_concurrent_set_real_sub_set;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_concurrent_set_real_get_size;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_read_only = gee_concurrent_set_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SIZE_PROPERTY, gee_concurrent_set_properties[GEE_CONCURRENT_SET_SIZE_PROPERTY] = g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_READ_ONLY_PROPERTY, gee_concurrent_set_properties[GEE_CONCURRENT_SET_READ_ONLY_PROPERTY] = g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	_tmp0_ = g_private_new (__gee_concurrent_set_rand_lambda57__gdestroy_notify);
	gee_concurrent_set_rand = _tmp0_;
}

static void
gee_concurrent_set_instance_init (GeeConcurrentSet * self,
                                  gpointer klass)
{
	self->priv = gee_concurrent_set_get_instance_private (self);
	self->priv->_size = 0;
}

static void
gee_concurrent_set_finalize (GObject * obj)
{
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_gee_concurrent_set_tower_unref0 (self->priv->_head);
	self->priv->_head = NULL;
	_gee_hazard_pointer_context_free0 (ctx);
	_gee_concurrent_set_tower_unref0 (self->priv->_head);
	(self->priv->_cmp_target_destroy_notify == NULL) ? NULL : (self->priv->_cmp_target_destroy_notify (self->priv->_cmp_target), NULL);
	self->priv->_cmp = NULL;
	self->priv->_cmp_target = NULL;
	self->priv->_cmp_target_destroy_notify = NULL;
	G_OBJECT_CLASS (gee_concurrent_set_parent_class)->finalize (obj);
}

/**
 * A skip-linked list. This implementation is based on
 * [[http://www.cse.yorku.ca/~ruppert/Mikhail.pdf|Mikhail Fomitchev Master Thesis]].
 *
 * Many threads are allowed to operate on the same structure as well as modification
 * of structure during iteration is allowed. However the change may not be immediately
 * visible to other threads.
 */
static GType
gee_concurrent_set_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSet), 0, (GInstanceInitFunc) gee_concurrent_set_instance_init, NULL };
	GType gee_concurrent_set_type_id;
	gee_concurrent_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_SORTED_SET, "GeeConcurrentSet", &g_define_type_info, 0);
	GeeConcurrentSet_private_offset = g_type_add_instance_private (gee_concurrent_set_type_id, sizeof (GeeConcurrentSetPrivate));
	return gee_concurrent_set_type_id;
}

GType
gee_concurrent_set_get_type (void)
{
	static volatile gsize gee_concurrent_set_type_id__once = 0;
	if (g_once_init_enter (&gee_concurrent_set_type_id__once)) {
		GType gee_concurrent_set_type_id;
		gee_concurrent_set_type_id = gee_concurrent_set_get_type_once ();
		g_once_init_leave (&gee_concurrent_set_type_id__once, gee_concurrent_set_type_id);
	}
	return gee_concurrent_set_type_id__once;
}

static void
_vala_gee_concurrent_set_get_property (GObject * object,
                                       guint property_id,
                                       GValue * value,
                                       GParamSpec * pspec)
{
	GeeConcurrentSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SIZE_PROPERTY:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		case GEE_CONCURRENT_SET_READ_ONLY_PROPERTY:
		g_value_set_boolean (value, gee_abstract_collection_get_read_only ((GeeAbstractCollection*) self));
		break;
		case GEE_CONCURRENT_SET_G_TYPE:
		g_value_set_gtype (value, self->priv->g_type);
		break;
		case GEE_CONCURRENT_SET_G_DUP_FUNC:
		g_value_set_pointer (value, self->priv->g_dup_func);
		break;
		case GEE_CONCURRENT_SET_G_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->g_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_concurrent_set_set_property (GObject * object,
                                       guint property_id,
                                       const GValue * value,
                                       GParamSpec * pspec)
{
	GeeConcurrentSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

