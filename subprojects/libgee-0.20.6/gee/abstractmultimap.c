/* abstractmultimap.c generated by valac 0.56.3, the Vala compiler
 * generated from abstractmultimap.vala, do not modify */

/* abstractmultimap.vala
 *
 * Copyright (C) 2009  Ali Sabil
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Ali Sabil <ali.sabil@gmail.com>
 * 	Didier 'Ptitjes Villevalois <ptitjes@free.fr>
 */

#include "gee.h"
#include <glib.h>
#include <glib-object.h>

enum  {
	GEE_ABSTRACT_MULTI_MAP_0_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_K_TYPE,
	GEE_ABSTRACT_MULTI_MAP_K_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_K_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_V_TYPE,
	GEE_ABSTRACT_MULTI_MAP_V_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_V_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_SIZE_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_READ_ONLY_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_NUM_PROPERTIES
};
static GParamSpec* gee_abstract_multi_map_properties[GEE_ABSTRACT_MULTI_MAP_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS (gee_abstract_multi_map_all_keys_get_type ())
#define GEE_ABSTRACT_MULTI_MAP_ALL_KEYS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS, GeeAbstractMultiMapAllKeys))
#define GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS, GeeAbstractMultiMapAllKeysClass))
#define GEE_ABSTRACT_MULTI_MAP_IS_ALL_KEYS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS))
#define GEE_ABSTRACT_MULTI_MAP_IS_ALL_KEYS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS))
#define GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS, GeeAbstractMultiMapAllKeysClass))

typedef struct _GeeAbstractMultiMapAllKeys GeeAbstractMultiMapAllKeys;
typedef struct _GeeAbstractMultiMapAllKeysClass GeeAbstractMultiMapAllKeysClass;

#define GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES (gee_abstract_multi_map_values_get_type ())
#define GEE_ABSTRACT_MULTI_MAP_VALUES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES, GeeAbstractMultiMapValues))
#define GEE_ABSTRACT_MULTI_MAP_VALUES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES, GeeAbstractMultiMapValuesClass))
#define GEE_ABSTRACT_MULTI_MAP_IS_VALUES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES))
#define GEE_ABSTRACT_MULTI_MAP_IS_VALUES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES))
#define GEE_ABSTRACT_MULTI_MAP_VALUES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES, GeeAbstractMultiMapValuesClass))

typedef struct _GeeAbstractMultiMapValues GeeAbstractMultiMapValues;
typedef struct _GeeAbstractMultiMapValuesClass GeeAbstractMultiMapValuesClass;

#define GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR (gee_abstract_multi_map_mapping_iterator_get_type ())
#define GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, GeeAbstractMultiMapMappingIterator))
#define GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, GeeAbstractMultiMapMappingIteratorClass))
#define GEE_ABSTRACT_MULTI_MAP_IS_MAPPING_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR))
#define GEE_ABSTRACT_MULTI_MAP_IS_MAPPING_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR))
#define GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, GeeAbstractMultiMapMappingIteratorClass))

typedef struct _GeeAbstractMultiMapMappingIterator GeeAbstractMultiMapMappingIterator;
typedef struct _GeeAbstractMultiMapMappingIteratorClass GeeAbstractMultiMapMappingIteratorClass;

#define GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR (gee_abstract_multi_map_map_iterator_get_type ())
#define GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR, GeeAbstractMultiMapMapIterator))
#define GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR, GeeAbstractMultiMapMapIteratorClass))
#define GEE_ABSTRACT_MULTI_MAP_IS_MAP_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR))
#define GEE_ABSTRACT_MULTI_MAP_IS_MAP_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR))
#define GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR, GeeAbstractMultiMapMapIteratorClass))

typedef struct _GeeAbstractMultiMapMapIterator GeeAbstractMultiMapMapIterator;
typedef struct _GeeAbstractMultiMapMapIteratorClass GeeAbstractMultiMapMapIteratorClass;

#define GEE_TYPE_READ_ONLY_MULTI_MAP (gee_read_only_multi_map_get_type ())
#define GEE_READ_ONLY_MULTI_MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_READ_ONLY_MULTI_MAP, GeeReadOnlyMultiMap))
#define GEE_READ_ONLY_MULTI_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_READ_ONLY_MULTI_MAP, GeeReadOnlyMultiMapClass))
#define GEE_IS_READ_ONLY_MULTI_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_READ_ONLY_MULTI_MAP))
#define GEE_IS_READ_ONLY_MULTI_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_READ_ONLY_MULTI_MAP))
#define GEE_READ_ONLY_MULTI_MAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_READ_ONLY_MULTI_MAP, GeeReadOnlyMultiMapClass))

typedef struct _GeeReadOnlyMultiMap GeeReadOnlyMultiMap;
typedef struct _GeeReadOnlyMultiMapClass GeeReadOnlyMultiMapClass;
typedef struct _GeeAbstractMultiMapAllKeysPrivate GeeAbstractMultiMapAllKeysPrivate;
enum  {
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_0_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_TYPE,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_TYPE,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_SIZE_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_READ_ONLY_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_NUM_PROPERTIES
};
static GParamSpec* gee_abstract_multi_map_all_keys_properties[GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_NUM_PROPERTIES];

#define GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR (gee_abstract_multi_map_key_iterator_get_type ())
#define GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR, GeeAbstractMultiMapKeyIterator))
#define GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR, GeeAbstractMultiMapKeyIteratorClass))
#define GEE_ABSTRACT_MULTI_MAP_IS_KEY_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR))
#define GEE_ABSTRACT_MULTI_MAP_IS_KEY_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR))
#define GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR, GeeAbstractMultiMapKeyIteratorClass))

typedef struct _GeeAbstractMultiMapKeyIterator GeeAbstractMultiMapKeyIterator;
typedef struct _GeeAbstractMultiMapKeyIteratorClass GeeAbstractMultiMapKeyIteratorClass;
typedef struct _GeeAbstractMultiMapValuesPrivate GeeAbstractMultiMapValuesPrivate;
enum  {
	GEE_ABSTRACT_MULTI_MAP_VALUES_0_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_VALUES_K_TYPE,
	GEE_ABSTRACT_MULTI_MAP_VALUES_K_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_VALUES_K_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_VALUES_V_TYPE,
	GEE_ABSTRACT_MULTI_MAP_VALUES_V_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_VALUES_V_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_VALUES_SIZE_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_VALUES_READ_ONLY_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_VALUES_NUM_PROPERTIES
};
static GParamSpec* gee_abstract_multi_map_values_properties[GEE_ABSTRACT_MULTI_MAP_VALUES_NUM_PROPERTIES];

#define GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR (gee_abstract_multi_map_value_iterator_get_type ())
#define GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR, GeeAbstractMultiMapValueIterator))
#define GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR, GeeAbstractMultiMapValueIteratorClass))
#define GEE_ABSTRACT_MULTI_MAP_IS_VALUE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR))
#define GEE_ABSTRACT_MULTI_MAP_IS_VALUE_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR))
#define GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR, GeeAbstractMultiMapValueIteratorClass))

typedef struct _GeeAbstractMultiMapValueIterator GeeAbstractMultiMapValueIterator;
typedef struct _GeeAbstractMultiMapValueIteratorClass GeeAbstractMultiMapValueIteratorClass;
typedef struct _GeeAbstractMultiMapMappingIteratorPrivate GeeAbstractMultiMapMappingIteratorPrivate;
enum  {
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_0_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_TYPE,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_TYPE,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_READ_ONLY_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_VALID_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_NUM_PROPERTIES
};
static GParamSpec* gee_abstract_multi_map_mapping_iterator_properties[GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_NUM_PROPERTIES];
typedef struct _GeeAbstractMultiMapKeyIteratorPrivate GeeAbstractMultiMapKeyIteratorPrivate;
enum  {
	GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_0_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_TYPE,
	GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_TYPE,
	GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_NUM_PROPERTIES
};
static GParamSpec* gee_abstract_multi_map_key_iterator_properties[GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_NUM_PROPERTIES];
typedef struct _Block1Data Block1Data;
typedef struct _Block2Data Block2Data;
typedef struct _Block3Data Block3Data;
typedef struct _GeeAbstractMultiMapValueIteratorPrivate GeeAbstractMultiMapValueIteratorPrivate;
enum  {
	GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_0_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_TYPE,
	GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_TYPE,
	GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_NUM_PROPERTIES
};
static GParamSpec* gee_abstract_multi_map_value_iterator_properties[GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_NUM_PROPERTIES];
typedef struct _Block4Data Block4Data;
typedef struct _GeeAbstractMultiMapMapIteratorPrivate GeeAbstractMultiMapMapIteratorPrivate;
enum  {
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_0_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_TYPE,
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_TYPE,
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_DUP_FUNC,
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_DESTROY_FUNC,
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_MUTABLE_PROPERTY,
	GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_NUM_PROPERTIES
};
static GParamSpec* gee_abstract_multi_map_map_iterator_properties[GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_NUM_PROPERTIES];
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeAbstractMultiMapPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	gint _nitems;
	GWeakRef _read_only_view;
};

struct _GeeAbstractMultiMapAllKeys {
	GeeAbstractCollection parent_instance;
	GeeAbstractMultiMapAllKeysPrivate * priv;
	GeeAbstractMultiMap* _multi_map;
};

struct _GeeAbstractMultiMapAllKeysClass {
	GeeAbstractCollectionClass parent_class;
};

struct _GeeAbstractMultiMapAllKeysPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _GeeAbstractMultiMapValues {
	GeeAbstractCollection parent_instance;
	GeeAbstractMultiMapValuesPrivate * priv;
	GeeAbstractMultiMap* _multi_map;
};

struct _GeeAbstractMultiMapValuesClass {
	GeeAbstractCollectionClass parent_class;
};

struct _GeeAbstractMultiMapValuesPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _GeeAbstractMultiMapMappingIterator {
	GObject parent_instance;
	GeeAbstractMultiMapMappingIteratorPrivate * priv;
	GeeMapIterator* outer;
	GeeIterator* inner;
};

struct _GeeAbstractMultiMapMappingIteratorClass {
	GObjectClass parent_class;
	gboolean (*get_read_only) (GeeAbstractMultiMapMappingIterator* self);
};

struct _GeeAbstractMultiMapMappingIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _GeeAbstractMultiMapKeyIterator {
	GeeAbstractMultiMapMappingIterator parent_instance;
	GeeAbstractMultiMapKeyIteratorPrivate * priv;
};

struct _GeeAbstractMultiMapKeyIteratorClass {
	GeeAbstractMultiMapMappingIteratorClass parent_class;
};

struct _GeeAbstractMultiMapKeyIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _Block1Data {
	int _ref_count_;
	GeeAbstractMultiMapKeyIterator* self;
	GeeForallFunc f;
	gpointer f_target;
};

struct _Block2Data {
	int _ref_count_;
	Block1Data * _data1_;
	gpointer key;
};

struct _Block3Data {
	int _ref_count_;
	Block1Data * _data1_;
	gpointer key;
};

struct _GeeAbstractMultiMapValueIterator {
	GeeAbstractMultiMapMappingIterator parent_instance;
	GeeAbstractMultiMapValueIteratorPrivate * priv;
};

struct _GeeAbstractMultiMapValueIteratorClass {
	GeeAbstractMultiMapMappingIteratorClass parent_class;
};

struct _GeeAbstractMultiMapValueIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _Block4Data {
	int _ref_count_;
	GeeAbstractMultiMapValueIterator* self;
	GeeForallFunc f;
	gpointer f_target;
};

struct _GeeAbstractMultiMapMapIterator {
	GeeAbstractMultiMapMappingIterator parent_instance;
	GeeAbstractMultiMapMapIteratorPrivate * priv;
};

struct _GeeAbstractMultiMapMapIteratorClass {
	GeeAbstractMultiMapMappingIteratorClass parent_class;
};

struct _GeeAbstractMultiMapMapIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

static gint GeeAbstractMultiMap_private_offset;
static gpointer gee_abstract_multi_map_parent_class = NULL;
static gint GeeAbstractMultiMapAllKeys_private_offset;
static gpointer gee_abstract_multi_map_all_keys_parent_class = NULL;
static GeeMultiSetIface * gee_abstract_multi_map_all_keys_gee_multi_set_parent_iface = NULL;
static gint GeeAbstractMultiMapValues_private_offset;
static gpointer gee_abstract_multi_map_values_parent_class = NULL;
static gint GeeAbstractMultiMapMappingIterator_private_offset;
static gpointer gee_abstract_multi_map_mapping_iterator_parent_class = NULL;
static gint GeeAbstractMultiMapKeyIterator_private_offset;
static gpointer gee_abstract_multi_map_key_iterator_parent_class = NULL;
static GeeTraversableIface * gee_abstract_multi_map_key_iterator_gee_traversable_parent_iface = NULL;
static GeeIteratorIface * gee_abstract_multi_map_key_iterator_gee_iterator_parent_iface = NULL;
static gint GeeAbstractMultiMapValueIterator_private_offset;
static gpointer gee_abstract_multi_map_value_iterator_parent_class = NULL;
static GeeTraversableIface * gee_abstract_multi_map_value_iterator_gee_traversable_parent_iface = NULL;
static GeeIteratorIface * gee_abstract_multi_map_value_iterator_gee_iterator_parent_iface = NULL;
static gint GeeAbstractMultiMapMapIterator_private_offset;
static gpointer gee_abstract_multi_map_map_iterator_parent_class = NULL;
static GeeMapIteratorIface * gee_abstract_multi_map_map_iterator_gee_map_iterator_parent_iface = NULL;
static GeeMultiMapIface * gee_abstract_multi_map_gee_multi_map_parent_iface = NULL;

 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved0 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved1 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved2 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved3 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved4 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved5 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved6 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved7 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL void gee_abstract_multi_map_reserved8 (GeeAbstractMultiMap* self);
static GeeSet* gee_abstract_multi_map_real_get_keys (GeeMultiMap* base);
static GeeMultiSet* gee_abstract_multi_map_real_get_all_keys (GeeMultiMap* base);
static GeeAbstractMultiMapAllKeys* gee_abstract_multi_map_all_keys_new (GType k_type,
                                                                 GBoxedCopyFunc k_dup_func,
                                                                 GDestroyNotify k_destroy_func,
                                                                 GType v_type,
                                                                 GBoxedCopyFunc v_dup_func,
                                                                 GDestroyNotify v_destroy_func,
                                                                 GeeAbstractMultiMap* multi_map);
static GeeAbstractMultiMapAllKeys* gee_abstract_multi_map_all_keys_construct (GType object_type,
                                                                       GType k_type,
                                                                       GBoxedCopyFunc k_dup_func,
                                                                       GDestroyNotify k_destroy_func,
                                                                       GType v_type,
                                                                       GBoxedCopyFunc v_dup_func,
                                                                       GDestroyNotify v_destroy_func,
                                                                       GeeAbstractMultiMap* multi_map);
static GType gee_abstract_multi_map_all_keys_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GeeCollection* gee_abstract_multi_map_real_get_values (GeeMultiMap* base);
static GeeAbstractMultiMapValues* gee_abstract_multi_map_values_new (GType k_type,
                                                              GBoxedCopyFunc k_dup_func,
                                                              GDestroyNotify k_destroy_func,
                                                              GType v_type,
                                                              GBoxedCopyFunc v_dup_func,
                                                              GDestroyNotify v_destroy_func,
                                                              GeeAbstractMultiMap* multi_map);
static GeeAbstractMultiMapValues* gee_abstract_multi_map_values_construct (GType object_type,
                                                                    GType k_type,
                                                                    GBoxedCopyFunc k_dup_func,
                                                                    GDestroyNotify k_destroy_func,
                                                                    GType v_type,
                                                                    GBoxedCopyFunc v_dup_func,
                                                                    GDestroyNotify v_destroy_func,
                                                                    GeeAbstractMultiMap* multi_map);
static GType gee_abstract_multi_map_values_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static gboolean gee_abstract_multi_map_real_contains (GeeMultiMap* base,
                                               gconstpointer key);
static GeeCollection* gee_abstract_multi_map_real_get (GeeMultiMap* base,
                                                gconstpointer key);
static void gee_abstract_multi_map_real_set (GeeMultiMap* base,
                                      gconstpointer key,
                                      gconstpointer value);
static gboolean gee_abstract_multi_map_real_remove (GeeMultiMap* base,
                                             gconstpointer key,
                                             gconstpointer value);
static gboolean gee_abstract_multi_map_real_remove_all (GeeMultiMap* base,
                                                 gconstpointer key);
static void gee_abstract_multi_map_real_clear (GeeMultiMap* base);
static GeeMapIterator* gee_abstract_multi_map_real_map_iterator (GeeMultiMap* base);
static GeeAbstractMultiMapMapIterator* gee_abstract_multi_map_map_iterator_new (GType k_type,
                                                                         GBoxedCopyFunc k_dup_func,
                                                                         GDestroyNotify k_destroy_func,
                                                                         GType v_type,
                                                                         GBoxedCopyFunc v_dup_func,
                                                                         GDestroyNotify v_destroy_func,
                                                                         GeeMapIterator* outer);
static GeeAbstractMultiMapMapIterator* gee_abstract_multi_map_map_iterator_construct (GType object_type,
                                                                               GType k_type,
                                                                               GBoxedCopyFunc k_dup_func,
                                                                               GDestroyNotify k_destroy_func,
                                                                               GType v_type,
                                                                               GBoxedCopyFunc v_dup_func,
                                                                               GDestroyNotify v_destroy_func,
                                                                               GeeMapIterator* outer);
static GType gee_abstract_multi_map_mapping_iterator_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GType gee_abstract_multi_map_map_iterator_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GeeCollection* gee_abstract_multi_map_real_create_value_storage (GeeAbstractMultiMap* self);
static GeeMultiSet* gee_abstract_multi_map_real_create_multi_key_set (GeeAbstractMultiMap* self);
static GeeEqualDataFunc gee_abstract_multi_map_real_get_value_equal_func (GeeAbstractMultiMap* self,
                                                                   gpointer* result_target,
                                                                   GDestroyNotify* result_target_destroy_notify);
static void gee_abstract_multi_map_real_reserved0 (GeeAbstractMultiMap* self);
static void gee_abstract_multi_map_real_reserved1 (GeeAbstractMultiMap* self);
static void gee_abstract_multi_map_real_reserved2 (GeeAbstractMultiMap* self);
static void gee_abstract_multi_map_real_reserved3 (GeeAbstractMultiMap* self);
static void gee_abstract_multi_map_real_reserved4 (GeeAbstractMultiMap* self);
static void gee_abstract_multi_map_real_reserved5 (GeeAbstractMultiMap* self);
static void gee_abstract_multi_map_real_reserved6 (GeeAbstractMultiMap* self);
static void gee_abstract_multi_map_real_reserved7 (GeeAbstractMultiMap* self);
static void gee_abstract_multi_map_real_reserved8 (GeeAbstractMultiMap* self);
 G_GNUC_INTERNAL GeeReadOnlyMultiMap* gee_read_only_multi_map_new (GType k_type,
                                                  GBoxedCopyFunc k_dup_func,
                                                  GDestroyNotify k_destroy_func,
                                                  GType v_type,
                                                  GBoxedCopyFunc v_dup_func,
                                                  GDestroyNotify v_destroy_func,
                                                  GeeMultiMap* multimap);
 G_GNUC_INTERNAL GeeReadOnlyMultiMap* gee_read_only_multi_map_construct (GType object_type,
                                                        GType k_type,
                                                        GBoxedCopyFunc k_dup_func,
                                                        GDestroyNotify k_destroy_func,
                                                        GType v_type,
                                                        GBoxedCopyFunc v_dup_func,
                                                        GDestroyNotify v_destroy_func,
                                                        GeeMultiMap* multimap);
 G_GNUC_INTERNAL GType gee_read_only_multi_map_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static GeeIterator* gee_abstract_multi_map_all_keys_real_iterator (GeeAbstractCollection* base);
static GeeAbstractMultiMapKeyIterator* gee_abstract_multi_map_key_iterator_new (GType k_type,
                                                                         GBoxedCopyFunc k_dup_func,
                                                                         GDestroyNotify k_destroy_func,
                                                                         GType v_type,
                                                                         GBoxedCopyFunc v_dup_func,
                                                                         GDestroyNotify v_destroy_func,
                                                                         GeeMapIterator* outer);
static GeeAbstractMultiMapKeyIterator* gee_abstract_multi_map_key_iterator_construct (GType object_type,
                                                                               GType k_type,
                                                                               GBoxedCopyFunc k_dup_func,
                                                                               GDestroyNotify k_destroy_func,
                                                                               GType v_type,
                                                                               GBoxedCopyFunc v_dup_func,
                                                                               GDestroyNotify v_destroy_func,
                                                                               GeeMapIterator* outer);
static GType gee_abstract_multi_map_key_iterator_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static gboolean gee_abstract_multi_map_all_keys_real_contains (GeeAbstractCollection* base,
                                                        gconstpointer key);
static gboolean gee_abstract_multi_map_all_keys_real_add (GeeAbstractCollection* base,
                                                   gconstpointer key);
static gboolean gee_abstract_multi_map_all_keys_real_remove (GeeAbstractCollection* base,
                                                      gconstpointer item);
static void gee_abstract_multi_map_all_keys_real_clear (GeeAbstractCollection* base);
static gint gee_abstract_multi_map_all_keys_real_count (GeeMultiSet* base,
                                                 gconstpointer item);
static void gee_abstract_multi_map_all_keys_finalize (GObject * obj);
static GType gee_abstract_multi_map_all_keys_get_type_once (void);
static void _vala_gee_abstract_multi_map_all_keys_get_property (GObject * object,
                                                         guint property_id,
                                                         GValue * value,
                                                         GParamSpec * pspec);
static void _vala_gee_abstract_multi_map_all_keys_set_property (GObject * object,
                                                         guint property_id,
                                                         const GValue * value,
                                                         GParamSpec * pspec);
static GeeIterator* gee_abstract_multi_map_values_real_iterator (GeeAbstractCollection* base);
static GeeAbstractMultiMapValueIterator* gee_abstract_multi_map_value_iterator_new (GType k_type,
                                                                             GBoxedCopyFunc k_dup_func,
                                                                             GDestroyNotify k_destroy_func,
                                                                             GType v_type,
                                                                             GBoxedCopyFunc v_dup_func,
                                                                             GDestroyNotify v_destroy_func,
                                                                             GeeMapIterator* outer);
static GeeAbstractMultiMapValueIterator* gee_abstract_multi_map_value_iterator_construct (GType object_type,
                                                                                   GType k_type,
                                                                                   GBoxedCopyFunc k_dup_func,
                                                                                   GDestroyNotify k_destroy_func,
                                                                                   GType v_type,
                                                                                   GBoxedCopyFunc v_dup_func,
                                                                                   GDestroyNotify v_destroy_func,
                                                                                   GeeMapIterator* outer);
static GType gee_abstract_multi_map_value_iterator_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static gboolean gee_abstract_multi_map_values_real_contains (GeeAbstractCollection* base,
                                                      gconstpointer value);
static gboolean gee_abstract_multi_map_values_real_add (GeeAbstractCollection* base,
                                                 gconstpointer value);
static gboolean gee_abstract_multi_map_values_real_remove (GeeAbstractCollection* base,
                                                    gconstpointer value);
static void gee_abstract_multi_map_values_real_clear (GeeAbstractCollection* base);
static void gee_abstract_multi_map_values_finalize (GObject * obj);
static GType gee_abstract_multi_map_values_get_type_once (void);
static void _vala_gee_abstract_multi_map_values_get_property (GObject * object,
                                                       guint property_id,
                                                       GValue * value,
                                                       GParamSpec * pspec);
static void _vala_gee_abstract_multi_map_values_set_property (GObject * object,
                                                       guint property_id,
                                                       const GValue * value,
                                                       GParamSpec * pspec);
static gboolean gee_abstract_multi_map_mapping_iterator_get_read_only (GeeAbstractMultiMapMappingIterator* self);
static GeeAbstractMultiMapMappingIterator* gee_abstract_multi_map_mapping_iterator_new (GType k_type,
                                                                                 GBoxedCopyFunc k_dup_func,
                                                                                 GDestroyNotify k_destroy_func,
                                                                                 GType v_type,
                                                                                 GBoxedCopyFunc v_dup_func,
                                                                                 GDestroyNotify v_destroy_func,
                                                                                 GeeMapIterator* outer);
static GeeAbstractMultiMapMappingIterator* gee_abstract_multi_map_mapping_iterator_construct (GType object_type,
                                                                                       GType k_type,
                                                                                       GBoxedCopyFunc k_dup_func,
                                                                                       GDestroyNotify k_destroy_func,
                                                                                       GType v_type,
                                                                                       GBoxedCopyFunc v_dup_func,
                                                                                       GDestroyNotify v_destroy_func,
                                                                                       GeeMapIterator* outer);
static gboolean gee_abstract_multi_map_mapping_iterator_next (GeeAbstractMultiMapMappingIterator* self);
static gboolean gee_abstract_multi_map_mapping_iterator_has_next (GeeAbstractMultiMapMappingIterator* self);
static void gee_abstract_multi_map_mapping_iterator_remove (GeeAbstractMultiMapMappingIterator* self);
static void gee_abstract_multi_map_mapping_iterator_unset (GeeAbstractMultiMapMappingIterator* self);
static gboolean gee_abstract_multi_map_mapping_iterator_get_valid (GeeAbstractMultiMapMappingIterator* self);
static void gee_abstract_multi_map_mapping_iterator_finalize (GObject * obj);
static GType gee_abstract_multi_map_mapping_iterator_get_type_once (void);
static void _vala_gee_abstract_multi_map_mapping_iterator_get_property (GObject * object,
                                                                 guint property_id,
                                                                 GValue * value,
                                                                 GParamSpec * pspec);
static void _vala_gee_abstract_multi_map_mapping_iterator_set_property (GObject * object,
                                                                 guint property_id,
                                                                 const GValue * value,
                                                                 GParamSpec * pspec);
static gpointer gee_abstract_multi_map_key_iterator_real_get (GeeIterator* base);
static gboolean gee_abstract_multi_map_key_iterator_real_foreach (GeeTraversable* base,
                                                           GeeForallFunc f,
                                                           gpointer f_target);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gboolean ___lambda50_ (Block2Data* _data2_,
                       gpointer v);
static gboolean ____lambda50__gee_forall_func (gpointer g,
                                        gpointer self);
static gboolean __lambda51_ (Block1Data* _data1_,
                      gconstpointer key,
                      GeeCollection* col);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static gboolean __lambda52_ (Block3Data* _data3_,
                      gpointer v);
static gboolean ___lambda52__gee_forall_func (gpointer g,
                                       gpointer self);
static gboolean ___lambda51__gee_forall_map_func (gconstpointer k,
                                           gconstpointer v,
                                           gpointer self);
static GType gee_abstract_multi_map_key_iterator_get_type_once (void);
static void _vala_gee_abstract_multi_map_key_iterator_get_property (GObject * object,
                                                             guint property_id,
                                                             GValue * value,
                                                             GParamSpec * pspec);
static void _vala_gee_abstract_multi_map_key_iterator_set_property (GObject * object,
                                                             guint property_id,
                                                             const GValue * value,
                                                             GParamSpec * pspec);
static gpointer gee_abstract_multi_map_value_iterator_real_get (GeeIterator* base);
static gboolean gee_abstract_multi_map_value_iterator_real_foreach (GeeTraversable* base,
                                                             GeeForallFunc f,
                                                             gpointer f_target);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static gboolean __lambda53_ (Block4Data* _data4_,
                      gconstpointer key,
                      GeeCollection* col);
static gboolean ___lambda53__gee_forall_map_func (gconstpointer k,
                                           gconstpointer v,
                                           gpointer self);
static GType gee_abstract_multi_map_value_iterator_get_type_once (void);
static void _vala_gee_abstract_multi_map_value_iterator_get_property (GObject * object,
                                                               guint property_id,
                                                               GValue * value,
                                                               GParamSpec * pspec);
static void _vala_gee_abstract_multi_map_value_iterator_set_property (GObject * object,
                                                               guint property_id,
                                                               const GValue * value,
                                                               GParamSpec * pspec);
static gpointer gee_abstract_multi_map_map_iterator_real_get_key (GeeMapIterator* base);
static gpointer gee_abstract_multi_map_map_iterator_real_get_value (GeeMapIterator* base);
static void gee_abstract_multi_map_map_iterator_real_set_value (GeeMapIterator* base,
                                                         gconstpointer value);
static GType gee_abstract_multi_map_map_iterator_get_type_once (void);
static void _vala_gee_abstract_multi_map_map_iterator_get_property (GObject * object,
                                                             guint property_id,
                                                             GValue * value,
                                                             GParamSpec * pspec);
static void _vala_gee_abstract_multi_map_map_iterator_set_property (GObject * object,
                                                             guint property_id,
                                                             const GValue * value,
                                                             GParamSpec * pspec);
static GObject * gee_abstract_multi_map_constructor (GType type,
                                              guint n_construct_properties,
                                              GObjectConstructParam * construct_properties);
static void gee_abstract_multi_map_finalize (GObject * obj);
static GType gee_abstract_multi_map_get_type_once (void);
static void _vala_gee_abstract_multi_map_get_property (GObject * object,
                                                guint property_id,
                                                GValue * value,
                                                GParamSpec * pspec);
static void _vala_gee_abstract_multi_map_set_property (GObject * object,
                                                guint property_id,
                                                const GValue * value,
                                                GParamSpec * pspec);

static inline gpointer
gee_abstract_multi_map_get_instance_private (GeeAbstractMultiMap* self)
{
	return G_STRUCT_MEMBER_P (self, GeeAbstractMultiMap_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

GeeAbstractMultiMap*
gee_abstract_multi_map_construct (GType object_type,
                                  GType k_type,
                                  GBoxedCopyFunc k_dup_func,
                                  GDestroyNotify k_destroy_func,
                                  GType v_type,
                                  GBoxedCopyFunc v_dup_func,
                                  GDestroyNotify v_destroy_func,
                                  GeeMap* storage_map)
{
	GeeAbstractMultiMap * self = NULL;
	GeeMap* _tmp0_;
	g_return_val_if_fail (storage_map != NULL, NULL);
	self = (GeeAbstractMultiMap*) g_object_new (object_type, "k-type", k_type, "k-dup-func", k_dup_func, "k-destroy-func", k_destroy_func, "v-type", v_type, "v-dup-func", v_dup_func, "v-destroy-func", v_destroy_func, NULL);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = _g_object_ref0 (storage_map);
	_g_object_unref0 (self->_storage_map);
	self->_storage_map = _tmp0_;
	return self;
}

static GeeSet*
gee_abstract_multi_map_real_get_keys (GeeMultiMap* base)
{
	GeeAbstractMultiMap * self;
	GeeMap* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* _tmp2_;
	GeeSet* result;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = self->_storage_map;
	_tmp1_ = gee_map_get_keys (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}

static GeeMultiSet*
gee_abstract_multi_map_real_get_all_keys (GeeMultiMap* base)
{
	GeeAbstractMultiMap * self;
	GeeAbstractMultiMapAllKeys* _tmp0_;
	GeeMultiSet* result;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = gee_abstract_multi_map_all_keys_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, (GDestroyNotify) self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, (GDestroyNotify) self->priv->v_destroy_func, self);
	result = (GeeMultiSet*) _tmp0_;
	return result;
}

static GeeCollection*
gee_abstract_multi_map_real_get_values (GeeMultiMap* base)
{
	GeeAbstractMultiMap * self;
	GeeAbstractMultiMapValues* _tmp0_;
	GeeCollection* result;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = gee_abstract_multi_map_values_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, (GDestroyNotify) self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, (GDestroyNotify) self->priv->v_destroy_func, self);
	result = (GeeCollection*) _tmp0_;
	return result;
}

static gboolean
gee_abstract_multi_map_real_contains (GeeMultiMap* base,
                                      gconstpointer key)
{
	GeeAbstractMultiMap * self;
	GeeMap* _tmp0_;
	gboolean result;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = self->_storage_map;
	result = gee_map_has_key (_tmp0_, key);
	return result;
}

static GeeCollection*
gee_abstract_multi_map_real_get (GeeMultiMap* base,
                                 gconstpointer key)
{
	GeeAbstractMultiMap * self;
	GeeCollection* col = NULL;
	GeeMap* _tmp0_;
	gpointer _tmp1_;
	GeeCollection* _tmp2_ = NULL;
	GeeCollection* _tmp3_;
	GeeCollection* result;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = self->_storage_map;
	_tmp1_ = gee_map_get (_tmp0_, key);
	col = (GeeCollection*) _tmp1_;
	_tmp3_ = col;
	if (_tmp3_ != NULL) {
		GeeCollection* _tmp4_;
		GeeCollection* _tmp5_;
		GeeCollection* _tmp6_;
		_tmp4_ = col;
		_tmp5_ = gee_collection_get_read_only_view (_tmp4_);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp2_);
		_tmp2_ = _tmp6_;
	} else {
		GeeSet* _tmp7_;
		_tmp7_ = gee_set_empty (self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, (GDestroyNotify) self->priv->v_destroy_func);
		_g_object_unref0 (_tmp2_);
		_tmp2_ = (GeeCollection*) _tmp7_;
	}
	result = _tmp2_;
	_g_object_unref0 (col);
	return result;
}

static void
gee_abstract_multi_map_real_set (GeeMultiMap* base,
                                 gconstpointer key,
                                 gconstpointer value)
{
	GeeAbstractMultiMap * self;
	GeeMap* _tmp0_;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = self->_storage_map;
	if (gee_map_has_key (_tmp0_, key)) {
		GeeMap* _tmp1_;
		gpointer _tmp2_;
		GeeCollection* _tmp3_;
		gboolean _tmp4_;
		_tmp1_ = self->_storage_map;
		_tmp2_ = gee_map_get (_tmp1_, key);
		_tmp3_ = (GeeCollection*) _tmp2_;
		_tmp4_ = gee_collection_add (_tmp3_, value);
		_g_object_unref0 (_tmp3_);
		if (_tmp4_) {
			gint _tmp5_;
			_tmp5_ = self->priv->_nitems;
			self->priv->_nitems = _tmp5_ + 1;
		}
	} else {
		GeeCollection* s = NULL;
		GeeCollection* _tmp6_;
		GeeCollection* _tmp7_;
		GeeMap* _tmp8_;
		GeeCollection* _tmp9_;
		gint _tmp10_;
		_tmp6_ = gee_abstract_multi_map_create_value_storage (self);
		s = _tmp6_;
		_tmp7_ = s;
		gee_collection_add (_tmp7_, value);
		_tmp8_ = self->_storage_map;
		_tmp9_ = s;
		gee_map_set (_tmp8_, key, _tmp9_);
		_tmp10_ = self->priv->_nitems;
		self->priv->_nitems = _tmp10_ + 1;
		_g_object_unref0 (s);
	}
}

static gboolean
gee_abstract_multi_map_real_remove (GeeMultiMap* base,
                                    gconstpointer key,
                                    gconstpointer value)
{
	GeeAbstractMultiMap * self;
	GeeMap* _tmp0_;
	gboolean result;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = self->_storage_map;
	if (gee_map_has_key (_tmp0_, key)) {
		GeeCollection* values = NULL;
		GeeMap* _tmp1_;
		gpointer _tmp2_;
		GeeCollection* _tmp3_;
		_tmp1_ = self->_storage_map;
		_tmp2_ = gee_map_get (_tmp1_, key);
		values = (GeeCollection*) _tmp2_;
		_tmp3_ = values;
		if (gee_collection_contains (_tmp3_, value)) {
			GeeCollection* _tmp4_;
			gint _tmp5_;
			GeeCollection* _tmp6_;
			gint _tmp7_;
			gint _tmp8_;
			_tmp4_ = values;
			gee_collection_remove (_tmp4_, value);
			_tmp5_ = self->priv->_nitems;
			self->priv->_nitems = _tmp5_ - 1;
			_tmp6_ = values;
			_tmp7_ = gee_collection_get_size (_tmp6_);
			_tmp8_ = _tmp7_;
			if (_tmp8_ == 0) {
				GeeMap* _tmp9_;
				_tmp9_ = self->_storage_map;
				gee_map_unset (_tmp9_, key, NULL);
			}
			result = TRUE;
			_g_object_unref0 (values);
			return result;
		}
		_g_object_unref0 (values);
	}
	result = FALSE;
	return result;
}

static gboolean
gee_abstract_multi_map_real_remove_all (GeeMultiMap* base,
                                        gconstpointer key)
{
	GeeAbstractMultiMap * self;
	GeeMap* _tmp0_;
	gboolean result;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = self->_storage_map;
	if (gee_map_has_key (_tmp0_, key)) {
		gint size = 0;
		GeeMap* _tmp1_;
		gpointer _tmp2_;
		GeeCollection* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		GeeMap* _tmp7_;
		_tmp1_ = self->_storage_map;
		_tmp2_ = gee_map_get (_tmp1_, key);
		_tmp3_ = (GeeCollection*) _tmp2_;
		_tmp4_ = gee_collection_get_size (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp3_);
		size = _tmp6_;
		_tmp7_ = self->_storage_map;
		if (gee_map_unset (_tmp7_, key, NULL)) {
			self->priv->_nitems = self->priv->_nitems - size;
			result = TRUE;
			return result;
		}
	}
	result = FALSE;
	return result;
}

static void
gee_abstract_multi_map_real_clear (GeeMultiMap* base)
{
	GeeAbstractMultiMap * self;
	GeeMap* _tmp0_;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = self->_storage_map;
	gee_map_clear (_tmp0_);
	self->priv->_nitems = 0;
}

static GeeMapIterator*
gee_abstract_multi_map_real_map_iterator (GeeMultiMap* base)
{
	GeeAbstractMultiMap * self;
	GeeMap* _tmp0_;
	GeeMapIterator* _tmp1_;
	GeeMapIterator* _tmp2_;
	GeeAbstractMultiMapMapIterator* _tmp3_;
	GeeMapIterator* _tmp4_;
	GeeMapIterator* result;
	self = (GeeAbstractMultiMap*) base;
	_tmp0_ = self->_storage_map;
	_tmp1_ = gee_map_map_iterator (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = gee_abstract_multi_map_map_iterator_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, (GDestroyNotify) self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, (GDestroyNotify) self->priv->v_destroy_func, _tmp2_);
	_tmp4_ = (GeeMapIterator*) _tmp3_;
	_g_object_unref0 (_tmp2_);
	result = _tmp4_;
	return result;
}

static GeeCollection*
gee_abstract_multi_map_real_create_value_storage (GeeAbstractMultiMap* self)
{
	g_critical ("Type `%s' does not implement abstract method `gee_abstract_multi_map_create_value_storage'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GeeCollection*
gee_abstract_multi_map_create_value_storage (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->create_value_storage) {
		return _klass_->create_value_storage (self);
	}
	return NULL;
}

static GeeMultiSet*
gee_abstract_multi_map_real_create_multi_key_set (GeeAbstractMultiMap* self)
{
	g_critical ("Type `%s' does not implement abstract method `gee_abstract_multi_map_create_multi_key_set'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GeeMultiSet*
gee_abstract_multi_map_create_multi_key_set (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->create_multi_key_set) {
		return _klass_->create_multi_key_set (self);
	}
	return NULL;
}

static GeeEqualDataFunc
gee_abstract_multi_map_real_get_value_equal_func (GeeAbstractMultiMap* self,
                                                  gpointer* result_target,
                                                  GDestroyNotify* result_target_destroy_notify)
{
	g_critical ("Type `%s' does not implement abstract method `gee_abstract_multi_map_get_value_equal_func'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GeeEqualDataFunc
gee_abstract_multi_map_get_value_equal_func (GeeAbstractMultiMap* self,
                                             gpointer* result_target,
                                             GDestroyNotify* result_target_destroy_notify)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->get_value_equal_func) {
		return _klass_->get_value_equal_func (self, result_target, result_target_destroy_notify);
	}
	return NULL;
}

static void
gee_abstract_multi_map_real_reserved0 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved0 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved0) {
		_klass_->reserved0 (self);
	}
}

static void
gee_abstract_multi_map_real_reserved1 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved1 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved1) {
		_klass_->reserved1 (self);
	}
}

static void
gee_abstract_multi_map_real_reserved2 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved2 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved2) {
		_klass_->reserved2 (self);
	}
}

static void
gee_abstract_multi_map_real_reserved3 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved3 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved3) {
		_klass_->reserved3 (self);
	}
}

static void
gee_abstract_multi_map_real_reserved4 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved4 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved4) {
		_klass_->reserved4 (self);
	}
}

static void
gee_abstract_multi_map_real_reserved5 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved5 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved5) {
		_klass_->reserved5 (self);
	}
}

static void
gee_abstract_multi_map_real_reserved6 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved6 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved6) {
		_klass_->reserved6 (self);
	}
}

static void
gee_abstract_multi_map_real_reserved7 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved7 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved7) {
		_klass_->reserved7 (self);
	}
}

static void
gee_abstract_multi_map_real_reserved8 (GeeAbstractMultiMap* self)
{
}

void
gee_abstract_multi_map_reserved8 (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->reserved8) {
		_klass_->reserved8 (self);
	}
}

static gint
gee_abstract_multi_map_real_get_size (GeeMultiMap* base)
{
	gint result;
	GeeAbstractMultiMap* self;
	self = (GeeAbstractMultiMap*) base;
	result = self->priv->_nitems;
	return result;
}

static gboolean
gee_abstract_multi_map_real_get_read_only (GeeMultiMap* base)
{
	gboolean result;
	GeeAbstractMultiMap* self;
	self = (GeeAbstractMultiMap*) base;
	result = FALSE;
	return result;
}

GeeMultiMap*
gee_abstract_multi_map_get_read_only_view (GeeAbstractMultiMap* self)
{
	GeeAbstractMultiMapClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_GET_CLASS (self);
	if (_klass_->get_read_only_view) {
		return _klass_->get_read_only_view (self);
	}
	return NULL;
}

static GeeMultiMap*
gee_abstract_multi_map_real_get_read_only_view (GeeAbstractMultiMap* base)
{
	GeeMultiMap* result;
	GeeAbstractMultiMap* self;
	GeeMultiMap* instance = NULL;
	GObject* _tmp0_;
	GeeMultiMap* _tmp1_;
	self = base;
	_tmp0_ = g_weak_ref_get (&self->priv->_read_only_view);
	instance = G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, GEE_TYPE_MULTI_MAP, GeeMultiMap);
	_tmp1_ = instance;
	if (_tmp1_ == NULL) {
		GeeReadOnlyMultiMap* _tmp2_;
		GeeMultiMap* _tmp3_;
		_tmp2_ = gee_read_only_multi_map_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, (GDestroyNotify) self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, (GDestroyNotify) self->priv->v_destroy_func, (GeeMultiMap*) self);
		_g_object_unref0 (instance);
		instance = (GeeMultiMap*) _tmp2_;
		_tmp3_ = instance;
		g_weak_ref_set (&self->priv->_read_only_view, (GObject*) _tmp3_);
	}
	result = instance;
	return result;
}

static inline gpointer
gee_abstract_multi_map_all_keys_get_instance_private (GeeAbstractMultiMapAllKeys* self)
{
	return G_STRUCT_MEMBER_P (self, GeeAbstractMultiMapAllKeys_private_offset);
}

static GeeAbstractMultiMapAllKeys*
gee_abstract_multi_map_all_keys_construct (GType object_type,
                                           GType k_type,
                                           GBoxedCopyFunc k_dup_func,
                                           GDestroyNotify k_destroy_func,
                                           GType v_type,
                                           GBoxedCopyFunc v_dup_func,
                                           GDestroyNotify v_destroy_func,
                                           GeeAbstractMultiMap* multi_map)
{
	GeeAbstractMultiMapAllKeys * self = NULL;
	GeeAbstractMultiMap* _tmp0_;
	g_return_val_if_fail (multi_map != NULL, NULL);
	self = (GeeAbstractMultiMapAllKeys*) gee_abstract_collection_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, (GDestroyNotify) k_destroy_func);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = _g_object_ref0 (multi_map);
	_g_object_unref0 (self->_multi_map);
	self->_multi_map = _tmp0_;
	return self;
}

static GeeAbstractMultiMapAllKeys*
gee_abstract_multi_map_all_keys_new (GType k_type,
                                     GBoxedCopyFunc k_dup_func,
                                     GDestroyNotify k_destroy_func,
                                     GType v_type,
                                     GBoxedCopyFunc v_dup_func,
                                     GDestroyNotify v_destroy_func,
                                     GeeAbstractMultiMap* multi_map)
{
	return gee_abstract_multi_map_all_keys_construct (GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, multi_map);
}

static GeeIterator*
gee_abstract_multi_map_all_keys_real_iterator (GeeAbstractCollection* base)
{
	GeeAbstractMultiMapAllKeys * self;
	GeeAbstractMultiMap* _tmp0_;
	GeeMap* _tmp1_;
	GeeMapIterator* _tmp2_;
	GeeMapIterator* _tmp3_;
	GeeAbstractMultiMapKeyIterator* _tmp4_;
	GeeIterator* _tmp5_;
	GeeIterator* result;
	self = (GeeAbstractMultiMapAllKeys*) base;
	_tmp0_ = self->_multi_map;
	_tmp1_ = _tmp0_->_storage_map;
	_tmp2_ = gee_map_map_iterator (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_multi_map_key_iterator_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, (GDestroyNotify) self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, (GDestroyNotify) self->priv->v_destroy_func, _tmp3_);
	_tmp5_ = (GeeIterator*) _tmp4_;
	_g_object_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}

static gboolean
gee_abstract_multi_map_all_keys_real_contains (GeeAbstractCollection* base,
                                               gconstpointer key)
{
	GeeAbstractMultiMapAllKeys * self;
	GeeAbstractMultiMap* _tmp0_;
	GeeMap* _tmp1_;
	gboolean result;
	self = (GeeAbstractMultiMapAllKeys*) base;
	_tmp0_ = self->_multi_map;
	_tmp1_ = _tmp0_->_storage_map;
	result = gee_map_has_key (_tmp1_, key);
	return result;
}

static gboolean
gee_abstract_multi_map_all_keys_real_add (GeeAbstractCollection* base,
                                          gconstpointer key)
{
	GeeAbstractMultiMapAllKeys * self;
	self = (GeeAbstractMultiMapAllKeys*) base;
	g_assert_not_reached ();
}

static gboolean
gee_abstract_multi_map_all_keys_real_remove (GeeAbstractCollection* base,
                                             gconstpointer item)
{
	GeeAbstractMultiMapAllKeys * self;
	self = (GeeAbstractMultiMapAllKeys*) base;
	g_assert_not_reached ();
}

static void
gee_abstract_multi_map_all_keys_real_clear (GeeAbstractCollection* base)
{
	GeeAbstractMultiMapAllKeys * self;
	self = (GeeAbstractMultiMapAllKeys*) base;
	g_assert_not_reached ();
}

static gint
gee_abstract_multi_map_all_keys_real_count (GeeMultiSet* base,
                                            gconstpointer item)
{
	GeeAbstractMultiMapAllKeys * self;
	GeeCollection* collection = NULL;
	GeeAbstractMultiMap* _tmp0_;
	GeeMap* _tmp1_;
	gpointer _tmp2_;
	gint _tmp3_ = 0;
	GeeCollection* _tmp4_;
	gint result;
	self = (GeeAbstractMultiMapAllKeys*) base;
	_tmp0_ = self->_multi_map;
	_tmp1_ = _tmp0_->_storage_map;
	_tmp2_ = gee_map_get (_tmp1_, item);
	collection = (GeeCollection*) _tmp2_;
	_tmp4_ = collection;
	if (_tmp4_ != NULL) {
		GeeCollection* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		_tmp5_ = collection;
		_tmp6_ = gee_collection_get_size (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp3_ = _tmp7_;
	} else {
		_tmp3_ = 0;
	}
	result = _tmp3_;
	_g_object_unref0 (collection);
	return result;
}

static gint
gee_abstract_multi_map_all_keys_real_get_size (GeeAbstractCollection* base)
{
	gint result;
	GeeAbstractMultiMapAllKeys* self;
	GeeAbstractMultiMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	self = (GeeAbstractMultiMapAllKeys*) base;
	_tmp0_ = self->_multi_map;
	_tmp1_ = gee_multi_map_get_size ((GeeMultiMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}

static gboolean
gee_abstract_multi_map_all_keys_real_get_read_only (GeeAbstractCollection* base)
{
	gboolean result;
	GeeAbstractMultiMapAllKeys* self;
	self = (GeeAbstractMultiMapAllKeys*) base;
	result = TRUE;
	return result;
}

static void
gee_abstract_multi_map_all_keys_class_init (GeeAbstractMultiMapAllKeysClass * klass,
                                            gpointer klass_data)
{
	gee_abstract_multi_map_all_keys_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeAbstractMultiMapAllKeys_private_offset);
	((GeeAbstractCollectionClass *) klass)->iterator = (GeeIterator* (*) (GeeAbstractCollection*)) gee_abstract_multi_map_all_keys_real_iterator;
	((GeeAbstractCollectionClass *) klass)->contains = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_abstract_multi_map_all_keys_real_contains;
	((GeeAbstractCollectionClass *) klass)->add = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_abstract_multi_map_all_keys_real_add;
	((GeeAbstractCollectionClass *) klass)->remove = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_abstract_multi_map_all_keys_real_remove;
	((GeeAbstractCollectionClass *) klass)->clear = (void (*) (GeeAbstractCollection*)) gee_abstract_multi_map_all_keys_real_clear;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_abstract_multi_map_all_keys_real_get_size;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_read_only = gee_abstract_multi_map_all_keys_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_abstract_multi_map_all_keys_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_abstract_multi_map_all_keys_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_abstract_multi_map_all_keys_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_SIZE_PROPERTY, gee_abstract_multi_map_all_keys_properties[GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_SIZE_PROPERTY] = g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_READ_ONLY_PROPERTY, gee_abstract_multi_map_all_keys_properties[GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_READ_ONLY_PROPERTY] = g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static GType
gee_abstract_multi_map_all_keys_gee_multi_set_get_g_type (GeeAbstractMultiMapAllKeys* self)
{
	return self->priv->k_type;
}

static GBoxedCopyFunc
gee_abstract_multi_map_all_keys_gee_multi_set_get_g_dup_func (GeeAbstractMultiMapAllKeys* self)
{
	return self->priv->k_dup_func;
}

static GDestroyNotify
gee_abstract_multi_map_all_keys_gee_multi_set_get_g_destroy_func (GeeAbstractMultiMapAllKeys* self)
{
	return self->priv->k_destroy_func;
}

static void
gee_abstract_multi_map_all_keys_gee_multi_set_interface_init (GeeMultiSetIface * iface,
                                                              gpointer iface_data)
{
	gee_abstract_multi_map_all_keys_gee_multi_set_parent_iface = g_type_interface_peek_parent (iface);
	iface->count = (gint (*) (GeeMultiSet*, gconstpointer)) gee_abstract_multi_map_all_keys_real_count;
	iface->get_g_type = (GType (*) (GeeMultiSet *)) gee_abstract_multi_map_all_keys_gee_multi_set_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc (*) (GeeMultiSet *)) gee_abstract_multi_map_all_keys_gee_multi_set_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify (*) (GeeMultiSet *)) gee_abstract_multi_map_all_keys_gee_multi_set_get_g_destroy_func;
}

static void
gee_abstract_multi_map_all_keys_instance_init (GeeAbstractMultiMapAllKeys * self,
                                               gpointer klass)
{
	self->priv = gee_abstract_multi_map_all_keys_get_instance_private (self);
}

static void
gee_abstract_multi_map_all_keys_finalize (GObject * obj)
{
	GeeAbstractMultiMapAllKeys * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS, GeeAbstractMultiMapAllKeys);
	_g_object_unref0 (self->_multi_map);
	G_OBJECT_CLASS (gee_abstract_multi_map_all_keys_parent_class)->finalize (obj);
}

static GType
gee_abstract_multi_map_all_keys_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeAbstractMultiMapAllKeysClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_abstract_multi_map_all_keys_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeAbstractMultiMapAllKeys), 0, (GInstanceInitFunc) gee_abstract_multi_map_all_keys_instance_init, NULL };
	static const GInterfaceInfo gee_multi_set_info = { (GInterfaceInitFunc) gee_abstract_multi_map_all_keys_gee_multi_set_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType gee_abstract_multi_map_all_keys_type_id;
	gee_abstract_multi_map_all_keys_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_COLLECTION, "GeeAbstractMultiMapAllKeys", &g_define_type_info, 0);
	g_type_add_interface_static (gee_abstract_multi_map_all_keys_type_id, GEE_TYPE_MULTI_SET, &gee_multi_set_info);
	GeeAbstractMultiMapAllKeys_private_offset = g_type_add_instance_private (gee_abstract_multi_map_all_keys_type_id, sizeof (GeeAbstractMultiMapAllKeysPrivate));
	return gee_abstract_multi_map_all_keys_type_id;
}

static GType
gee_abstract_multi_map_all_keys_get_type (void)
{
	static volatile gsize gee_abstract_multi_map_all_keys_type_id__once = 0;
	if (g_once_init_enter (&gee_abstract_multi_map_all_keys_type_id__once)) {
		GType gee_abstract_multi_map_all_keys_type_id;
		gee_abstract_multi_map_all_keys_type_id = gee_abstract_multi_map_all_keys_get_type_once ();
		g_once_init_leave (&gee_abstract_multi_map_all_keys_type_id__once, gee_abstract_multi_map_all_keys_type_id);
	}
	return gee_abstract_multi_map_all_keys_type_id__once;
}

static void
_vala_gee_abstract_multi_map_all_keys_get_property (GObject * object,
                                                    guint property_id,
                                                    GValue * value,
                                                    GParamSpec * pspec)
{
	GeeAbstractMultiMapAllKeys * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS, GeeAbstractMultiMapAllKeys);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_SIZE_PROPERTY:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_READ_ONLY_PROPERTY:
		g_value_set_boolean (value, gee_abstract_collection_get_read_only ((GeeAbstractCollection*) self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_TYPE:
		g_value_set_gtype (value, self->priv->k_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_DUP_FUNC:
		g_value_set_pointer (value, self->priv->k_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->k_destroy_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_TYPE:
		g_value_set_gtype (value, self->priv->v_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_DUP_FUNC:
		g_value_set_pointer (value, self->priv->v_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->v_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_abstract_multi_map_all_keys_set_property (GObject * object,
                                                    guint property_id,
                                                    const GValue * value,
                                                    GParamSpec * pspec)
{
	GeeAbstractMultiMapAllKeys * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_ALL_KEYS, GeeAbstractMultiMapAllKeys);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_ALL_KEYS_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
gee_abstract_multi_map_values_get_instance_private (GeeAbstractMultiMapValues* self)
{
	return G_STRUCT_MEMBER_P (self, GeeAbstractMultiMapValues_private_offset);
}

static GeeAbstractMultiMapValues*
gee_abstract_multi_map_values_construct (GType object_type,
                                         GType k_type,
                                         GBoxedCopyFunc k_dup_func,
                                         GDestroyNotify k_destroy_func,
                                         GType v_type,
                                         GBoxedCopyFunc v_dup_func,
                                         GDestroyNotify v_destroy_func,
                                         GeeAbstractMultiMap* multi_map)
{
	GeeAbstractMultiMapValues * self = NULL;
	GeeAbstractMultiMap* _tmp0_;
	g_return_val_if_fail (multi_map != NULL, NULL);
	self = (GeeAbstractMultiMapValues*) gee_abstract_collection_construct (object_type, v_type, (GBoxedCopyFunc) v_dup_func, (GDestroyNotify) v_destroy_func);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = _g_object_ref0 (multi_map);
	_g_object_unref0 (self->_multi_map);
	self->_multi_map = _tmp0_;
	return self;
}

static GeeAbstractMultiMapValues*
gee_abstract_multi_map_values_new (GType k_type,
                                   GBoxedCopyFunc k_dup_func,
                                   GDestroyNotify k_destroy_func,
                                   GType v_type,
                                   GBoxedCopyFunc v_dup_func,
                                   GDestroyNotify v_destroy_func,
                                   GeeAbstractMultiMap* multi_map)
{
	return gee_abstract_multi_map_values_construct (GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, multi_map);
}

static GeeIterator*
gee_abstract_multi_map_values_real_iterator (GeeAbstractCollection* base)
{
	GeeAbstractMultiMapValues * self;
	GeeAbstractMultiMap* _tmp0_;
	GeeMap* _tmp1_;
	GeeMapIterator* _tmp2_;
	GeeMapIterator* _tmp3_;
	GeeAbstractMultiMapValueIterator* _tmp4_;
	GeeIterator* _tmp5_;
	GeeIterator* result;
	self = (GeeAbstractMultiMapValues*) base;
	_tmp0_ = self->_multi_map;
	_tmp1_ = _tmp0_->_storage_map;
	_tmp2_ = gee_map_map_iterator (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_multi_map_value_iterator_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, (GDestroyNotify) self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, (GDestroyNotify) self->priv->v_destroy_func, _tmp3_);
	_tmp5_ = (GeeIterator*) _tmp4_;
	_g_object_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}

static gboolean
gee_abstract_multi_map_values_real_contains (GeeAbstractCollection* base,
                                             gconstpointer value)
{
	GeeAbstractMultiMapValues * self;
	gboolean result;
	self = (GeeAbstractMultiMapValues*) base;
	{
		GeeIterator* _col_it = NULL;
		GeeAbstractMultiMap* _tmp0_;
		GeeMap* _tmp1_;
		GeeCollection* _tmp2_;
		GeeCollection* _tmp3_;
		GeeCollection* _tmp4_;
		GeeIterator* _tmp5_;
		GeeIterator* _tmp6_;
		_tmp0_ = self->_multi_map;
		_tmp1_ = _tmp0_->_storage_map;
		_tmp2_ = gee_map_get_values (_tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = _tmp3_;
		_tmp5_ = gee_iterable_iterator ((GeeIterable*) _tmp4_);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp4_);
		_col_it = _tmp6_;
		while (TRUE) {
			GeeIterator* _tmp7_;
			GeeCollection* col = NULL;
			GeeIterator* _tmp8_;
			gpointer _tmp9_;
			GeeCollection* _tmp10_;
			_tmp7_ = _col_it;
			if (!gee_iterator_next (_tmp7_)) {
				break;
			}
			_tmp8_ = _col_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			col = (GeeCollection*) _tmp9_;
			_tmp10_ = col;
			if (gee_collection_contains (_tmp10_, value)) {
				result = TRUE;
				_g_object_unref0 (col);
				_g_object_unref0 (_col_it);
				return result;
			}
			_g_object_unref0 (col);
		}
		_g_object_unref0 (_col_it);
	}
	result = FALSE;
	return result;
}

static gboolean
gee_abstract_multi_map_values_real_add (GeeAbstractCollection* base,
                                        gconstpointer value)
{
	GeeAbstractMultiMapValues * self;
	self = (GeeAbstractMultiMapValues*) base;
	g_assert_not_reached ();
}

static gboolean
gee_abstract_multi_map_values_real_remove (GeeAbstractCollection* base,
                                           gconstpointer value)
{
	GeeAbstractMultiMapValues * self;
	self = (GeeAbstractMultiMapValues*) base;
	g_assert_not_reached ();
}

static void
gee_abstract_multi_map_values_real_clear (GeeAbstractCollection* base)
{
	GeeAbstractMultiMapValues * self;
	self = (GeeAbstractMultiMapValues*) base;
	g_assert_not_reached ();
}

static gint
gee_abstract_multi_map_values_real_get_size (GeeAbstractCollection* base)
{
	gint result;
	GeeAbstractMultiMapValues* self;
	GeeAbstractMultiMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	self = (GeeAbstractMultiMapValues*) base;
	_tmp0_ = self->_multi_map;
	_tmp1_ = gee_multi_map_get_size ((GeeMultiMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}

static gboolean
gee_abstract_multi_map_values_real_get_read_only (GeeAbstractCollection* base)
{
	gboolean result;
	GeeAbstractMultiMapValues* self;
	self = (GeeAbstractMultiMapValues*) base;
	result = TRUE;
	return result;
}

static void
gee_abstract_multi_map_values_class_init (GeeAbstractMultiMapValuesClass * klass,
                                          gpointer klass_data)
{
	gee_abstract_multi_map_values_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeAbstractMultiMapValues_private_offset);
	((GeeAbstractCollectionClass *) klass)->iterator = (GeeIterator* (*) (GeeAbstractCollection*)) gee_abstract_multi_map_values_real_iterator;
	((GeeAbstractCollectionClass *) klass)->contains = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_abstract_multi_map_values_real_contains;
	((GeeAbstractCollectionClass *) klass)->add = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_abstract_multi_map_values_real_add;
	((GeeAbstractCollectionClass *) klass)->remove = (gboolean (*) (GeeAbstractCollection*, gconstpointer)) gee_abstract_multi_map_values_real_remove;
	((GeeAbstractCollectionClass *) klass)->clear = (void (*) (GeeAbstractCollection*)) gee_abstract_multi_map_values_real_clear;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_abstract_multi_map_values_real_get_size;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_read_only = gee_abstract_multi_map_values_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_abstract_multi_map_values_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_abstract_multi_map_values_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_abstract_multi_map_values_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUES_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUES_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUES_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUES_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUES_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUES_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUES_SIZE_PROPERTY, gee_abstract_multi_map_values_properties[GEE_ABSTRACT_MULTI_MAP_VALUES_SIZE_PROPERTY] = g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUES_READ_ONLY_PROPERTY, gee_abstract_multi_map_values_properties[GEE_ABSTRACT_MULTI_MAP_VALUES_READ_ONLY_PROPERTY] = g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
gee_abstract_multi_map_values_instance_init (GeeAbstractMultiMapValues * self,
                                             gpointer klass)
{
	self->priv = gee_abstract_multi_map_values_get_instance_private (self);
}

static void
gee_abstract_multi_map_values_finalize (GObject * obj)
{
	GeeAbstractMultiMapValues * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES, GeeAbstractMultiMapValues);
	_g_object_unref0 (self->_multi_map);
	G_OBJECT_CLASS (gee_abstract_multi_map_values_parent_class)->finalize (obj);
}

static GType
gee_abstract_multi_map_values_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeAbstractMultiMapValuesClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_abstract_multi_map_values_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeAbstractMultiMapValues), 0, (GInstanceInitFunc) gee_abstract_multi_map_values_instance_init, NULL };
	GType gee_abstract_multi_map_values_type_id;
	gee_abstract_multi_map_values_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_COLLECTION, "GeeAbstractMultiMapValues", &g_define_type_info, 0);
	GeeAbstractMultiMapValues_private_offset = g_type_add_instance_private (gee_abstract_multi_map_values_type_id, sizeof (GeeAbstractMultiMapValuesPrivate));
	return gee_abstract_multi_map_values_type_id;
}

static GType
gee_abstract_multi_map_values_get_type (void)
{
	static volatile gsize gee_abstract_multi_map_values_type_id__once = 0;
	if (g_once_init_enter (&gee_abstract_multi_map_values_type_id__once)) {
		GType gee_abstract_multi_map_values_type_id;
		gee_abstract_multi_map_values_type_id = gee_abstract_multi_map_values_get_type_once ();
		g_once_init_leave (&gee_abstract_multi_map_values_type_id__once, gee_abstract_multi_map_values_type_id);
	}
	return gee_abstract_multi_map_values_type_id__once;
}

static void
_vala_gee_abstract_multi_map_values_get_property (GObject * object,
                                                  guint property_id,
                                                  GValue * value,
                                                  GParamSpec * pspec)
{
	GeeAbstractMultiMapValues * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES, GeeAbstractMultiMapValues);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_VALUES_SIZE_PROPERTY:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_READ_ONLY_PROPERTY:
		g_value_set_boolean (value, gee_abstract_collection_get_read_only ((GeeAbstractCollection*) self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_K_TYPE:
		g_value_set_gtype (value, self->priv->k_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_K_DUP_FUNC:
		g_value_set_pointer (value, self->priv->k_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_K_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->k_destroy_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_V_TYPE:
		g_value_set_gtype (value, self->priv->v_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_V_DUP_FUNC:
		g_value_set_pointer (value, self->priv->v_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_V_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->v_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_abstract_multi_map_values_set_property (GObject * object,
                                                  guint property_id,
                                                  const GValue * value,
                                                  GParamSpec * pspec)
{
	GeeAbstractMultiMapValues * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_VALUES, GeeAbstractMultiMapValues);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_VALUES_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUES_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
gee_abstract_multi_map_mapping_iterator_get_instance_private (GeeAbstractMultiMapMappingIterator* self)
{
	return G_STRUCT_MEMBER_P (self, GeeAbstractMultiMapMappingIterator_private_offset);
}

static GeeAbstractMultiMapMappingIterator*
gee_abstract_multi_map_mapping_iterator_construct (GType object_type,
                                                   GType k_type,
                                                   GBoxedCopyFunc k_dup_func,
                                                   GDestroyNotify k_destroy_func,
                                                   GType v_type,
                                                   GBoxedCopyFunc v_dup_func,
                                                   GDestroyNotify v_destroy_func,
                                                   GeeMapIterator* outer)
{
	GeeAbstractMultiMapMappingIterator * self = NULL;
	GeeMapIterator* _tmp0_;
	self = (GeeAbstractMultiMapMappingIterator*) g_object_new (object_type, "k-type", k_type, "k-dup-func", k_dup_func, "k-destroy-func", k_destroy_func, "v-type", v_type, "v-dup-func", v_dup_func, "v-destroy-func", v_destroy_func, NULL);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = _g_object_ref0 (outer);
	_g_object_unref0 (self->outer);
	self->outer = _tmp0_;
	return self;
}

static GeeAbstractMultiMapMappingIterator*
gee_abstract_multi_map_mapping_iterator_new (GType k_type,
                                             GBoxedCopyFunc k_dup_func,
                                             GDestroyNotify k_destroy_func,
                                             GType v_type,
                                             GBoxedCopyFunc v_dup_func,
                                             GDestroyNotify v_destroy_func,
                                             GeeMapIterator* outer)
{
	return gee_abstract_multi_map_mapping_iterator_construct (GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, outer);
}

static gboolean
gee_abstract_multi_map_mapping_iterator_next (GeeAbstractMultiMapMappingIterator* self)
{
	gboolean _tmp0_ = FALSE;
	GeeIterator* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->inner;
	if (_tmp1_ != NULL) {
		GeeIterator* _tmp2_;
		_tmp2_ = self->inner;
		_tmp0_ = gee_iterator_next (_tmp2_);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	} else {
		GeeMapIterator* _tmp3_;
		_tmp3_ = self->outer;
		if (gee_map_iterator_next (_tmp3_)) {
			GeeMapIterator* _tmp4_;
			gpointer _tmp5_;
			GeeCollection* _tmp6_;
			GeeIterator* _tmp7_;
			GeeIterator* _tmp8_;
			_tmp4_ = self->outer;
			_tmp5_ = gee_map_iterator_get_value (_tmp4_);
			_tmp6_ = (GeeCollection*) _tmp5_;
			_tmp7_ = gee_iterable_iterator ((GeeIterable*) _tmp6_);
			_g_object_unref0 (self->inner);
			self->inner = _tmp7_;
			_g_object_unref0 (_tmp6_);
			_tmp8_ = self->inner;
			_vala_assert (gee_iterator_next (_tmp8_), "inner.next ()");
			result = TRUE;
			return result;
		} else {
			result = FALSE;
			return result;
		}
	}
}

static gboolean
gee_abstract_multi_map_mapping_iterator_has_next (GeeAbstractMultiMapMappingIterator* self)
{
	gboolean _tmp0_ = FALSE;
	GeeIterator* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->inner;
	if (gee_iterator_has_next (_tmp1_)) {
		_tmp0_ = TRUE;
	} else {
		GeeMapIterator* _tmp2_;
		_tmp2_ = self->outer;
		_tmp0_ = gee_map_iterator_has_next (_tmp2_);
	}
	result = _tmp0_;
	return result;
}

static void
gee_abstract_multi_map_mapping_iterator_remove (GeeAbstractMultiMapMappingIterator* self)
{
	g_return_if_fail (self != NULL);
	g_assert_not_reached ();
}

static void
gee_abstract_multi_map_mapping_iterator_unset (GeeAbstractMultiMapMappingIterator* self)
{
	GeeIterator* _tmp0_;
	GeeMapIterator* _tmp1_;
	gpointer _tmp2_;
	GeeCollection* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->inner;
	gee_iterator_remove (_tmp0_);
	_tmp1_ = self->outer;
	_tmp2_ = gee_map_iterator_get_value (_tmp1_);
	_tmp3_ = (GeeCollection*) _tmp2_;
	_tmp4_ = gee_collection_get_is_empty (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp3_);
	if (_tmp6_) {
		GeeMapIterator* _tmp7_;
		_tmp7_ = self->outer;
		gee_map_iterator_unset (_tmp7_);
	}
}

static gboolean
gee_abstract_multi_map_mapping_iterator_get_read_only (GeeAbstractMultiMapMappingIterator* self)
{
	GeeAbstractMultiMapMappingIteratorClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_GET_CLASS (self);
	if (_klass_->get_read_only) {
		return _klass_->get_read_only (self);
	}
	return FALSE;
}

static gboolean
gee_abstract_multi_map_mapping_iterator_real_get_read_only (GeeAbstractMultiMapMappingIterator* base)
{
	gboolean result;
	GeeAbstractMultiMapMappingIterator* self;
	self = base;
	result = TRUE;
	return result;
}

static gboolean
gee_abstract_multi_map_mapping_iterator_get_valid (GeeAbstractMultiMapMappingIterator* self)
{
	gboolean result;
	gboolean _tmp0_ = FALSE;
	GeeIterator* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->inner;
	if (_tmp1_ != NULL) {
		GeeIterator* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = self->inner;
		_tmp3_ = gee_iterator_get_valid (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}

static void
gee_abstract_multi_map_mapping_iterator_class_init (GeeAbstractMultiMapMappingIteratorClass * klass,
                                                    gpointer klass_data)
{
	gee_abstract_multi_map_mapping_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeAbstractMultiMapMappingIterator_private_offset);
	GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_CLASS (klass)->get_read_only = gee_abstract_multi_map_mapping_iterator_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_abstract_multi_map_mapping_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_abstract_multi_map_mapping_iterator_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_abstract_multi_map_mapping_iterator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_READ_ONLY_PROPERTY, gee_abstract_multi_map_mapping_iterator_properties[GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_READ_ONLY_PROPERTY] = g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_VALID_PROPERTY, gee_abstract_multi_map_mapping_iterator_properties[GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_VALID_PROPERTY] = g_param_spec_boolean ("valid", "valid", "valid", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
gee_abstract_multi_map_mapping_iterator_instance_init (GeeAbstractMultiMapMappingIterator * self,
                                                       gpointer klass)
{
	self->priv = gee_abstract_multi_map_mapping_iterator_get_instance_private (self);
	self->inner = NULL;
}

static void
gee_abstract_multi_map_mapping_iterator_finalize (GObject * obj)
{
	GeeAbstractMultiMapMappingIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, GeeAbstractMultiMapMappingIterator);
	_g_object_unref0 (self->outer);
	_g_object_unref0 (self->inner);
	G_OBJECT_CLASS (gee_abstract_multi_map_mapping_iterator_parent_class)->finalize (obj);
}

static GType
gee_abstract_multi_map_mapping_iterator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeAbstractMultiMapMappingIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_abstract_multi_map_mapping_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeAbstractMultiMapMappingIterator), 0, (GInstanceInitFunc) gee_abstract_multi_map_mapping_iterator_instance_init, NULL };
	GType gee_abstract_multi_map_mapping_iterator_type_id;
	gee_abstract_multi_map_mapping_iterator_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeAbstractMultiMapMappingIterator", &g_define_type_info, 0);
	GeeAbstractMultiMapMappingIterator_private_offset = g_type_add_instance_private (gee_abstract_multi_map_mapping_iterator_type_id, sizeof (GeeAbstractMultiMapMappingIteratorPrivate));
	return gee_abstract_multi_map_mapping_iterator_type_id;
}

static GType
gee_abstract_multi_map_mapping_iterator_get_type (void)
{
	static volatile gsize gee_abstract_multi_map_mapping_iterator_type_id__once = 0;
	if (g_once_init_enter (&gee_abstract_multi_map_mapping_iterator_type_id__once)) {
		GType gee_abstract_multi_map_mapping_iterator_type_id;
		gee_abstract_multi_map_mapping_iterator_type_id = gee_abstract_multi_map_mapping_iterator_get_type_once ();
		g_once_init_leave (&gee_abstract_multi_map_mapping_iterator_type_id__once, gee_abstract_multi_map_mapping_iterator_type_id);
	}
	return gee_abstract_multi_map_mapping_iterator_type_id__once;
}

static void
_vala_gee_abstract_multi_map_mapping_iterator_get_property (GObject * object,
                                                            guint property_id,
                                                            GValue * value,
                                                            GParamSpec * pspec)
{
	GeeAbstractMultiMapMappingIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, GeeAbstractMultiMapMappingIterator);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_READ_ONLY_PROPERTY:
		g_value_set_boolean (value, gee_abstract_multi_map_mapping_iterator_get_read_only (self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_VALID_PROPERTY:
		g_value_set_boolean (value, gee_abstract_multi_map_mapping_iterator_get_valid (self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_TYPE:
		g_value_set_gtype (value, self->priv->k_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_DUP_FUNC:
		g_value_set_pointer (value, self->priv->k_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->k_destroy_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_TYPE:
		g_value_set_gtype (value, self->priv->v_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_DUP_FUNC:
		g_value_set_pointer (value, self->priv->v_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->v_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_abstract_multi_map_mapping_iterator_set_property (GObject * object,
                                                            guint property_id,
                                                            const GValue * value,
                                                            GParamSpec * pspec)
{
	GeeAbstractMultiMapMappingIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, GeeAbstractMultiMapMappingIterator);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAPPING_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
gee_abstract_multi_map_key_iterator_get_instance_private (GeeAbstractMultiMapKeyIterator* self)
{
	return G_STRUCT_MEMBER_P (self, GeeAbstractMultiMapKeyIterator_private_offset);
}

static GeeAbstractMultiMapKeyIterator*
gee_abstract_multi_map_key_iterator_construct (GType object_type,
                                               GType k_type,
                                               GBoxedCopyFunc k_dup_func,
                                               GDestroyNotify k_destroy_func,
                                               GType v_type,
                                               GBoxedCopyFunc v_dup_func,
                                               GDestroyNotify v_destroy_func,
                                               GeeMapIterator* outer)
{
	GeeAbstractMultiMapKeyIterator * self = NULL;
	self = (GeeAbstractMultiMapKeyIterator*) gee_abstract_multi_map_mapping_iterator_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, (GDestroyNotify) k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, (GDestroyNotify) v_destroy_func, outer);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	return self;
}

static GeeAbstractMultiMapKeyIterator*
gee_abstract_multi_map_key_iterator_new (GType k_type,
                                         GBoxedCopyFunc k_dup_func,
                                         GDestroyNotify k_destroy_func,
                                         GType v_type,
                                         GBoxedCopyFunc v_dup_func,
                                         GDestroyNotify v_destroy_func,
                                         GeeMapIterator* outer)
{
	return gee_abstract_multi_map_key_iterator_construct (GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, outer);
}

static gpointer
gee_abstract_multi_map_key_iterator_real_get (GeeIterator* base)
{
	GeeAbstractMultiMapKeyIterator * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GeeMapIterator* _tmp2_;
	gpointer _tmp3_;
	gpointer result;
	self = (GeeAbstractMultiMapKeyIterator*) base;
	_tmp0_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
	_tmp3_ = gee_map_iterator_get_key (_tmp2_);
	result = _tmp3_;
	return result;
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		GeeAbstractMultiMapKeyIterator* self;
		self = _data1_->self;
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		GeeAbstractMultiMapKeyIterator* self;
		self = _data2_->_data1_->self;
		((_data2_->key == NULL) || (self->priv->k_destroy_func == NULL)) ? NULL : (_data2_->key = (self->priv->k_destroy_func (_data2_->key), NULL));
		block1_data_unref (_data2_->_data1_);
		_data2_->_data1_ = NULL;
		g_slice_free (Block2Data, _data2_);
	}
}

static gboolean
___lambda50_ (Block2Data* _data2_,
              gpointer v)
{
	Block1Data* _data1_;
	GeeAbstractMultiMapKeyIterator* self;
	gconstpointer _tmp0_;
	gpointer _tmp1_;
	gboolean result;
	_data1_ = _data2_->_data1_;
	self = _data1_->self;
	_tmp0_ = _data2_->key;
	_tmp1_ = ((_tmp0_ != NULL) && (self->priv->k_dup_func != NULL)) ? self->priv->k_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	result = _data1_->f (_tmp1_, _data1_->f_target);
	((v == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (v = (self->priv->v_destroy_func (v), NULL));
	return result;
}

static gboolean
____lambda50__gee_forall_func (gpointer g,
                               gpointer self)
{
	gboolean result;
	result = ___lambda50_ (self, g);
	return result;
}

static Block3Data*
block3_data_ref (Block3Data* _data3_)
{
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}

static void
block3_data_unref (void * _userdata_)
{
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		GeeAbstractMultiMapKeyIterator* self;
		self = _data3_->_data1_->self;
		((_data3_->key == NULL) || (self->priv->k_destroy_func == NULL)) ? NULL : (_data3_->key = (self->priv->k_destroy_func (_data3_->key), NULL));
		block1_data_unref (_data3_->_data1_);
		_data3_->_data1_ = NULL;
		g_slice_free (Block3Data, _data3_);
	}
}

static gboolean
__lambda52_ (Block3Data* _data3_,
             gpointer v)
{
	Block1Data* _data1_;
	GeeAbstractMultiMapKeyIterator* self;
	gpointer _tmp0_;
	gboolean result;
	_data1_ = _data3_->_data1_;
	self = _data1_->self;
	_tmp0_ = ((_data3_->key != NULL) && (self->priv->k_dup_func != NULL)) ? self->priv->k_dup_func ((gpointer) _data3_->key) : ((gpointer) _data3_->key);
	result = _data1_->f (_tmp0_, _data1_->f_target);
	((v == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (v = (self->priv->v_destroy_func (v), NULL));
	return result;
}

static gboolean
___lambda52__gee_forall_func (gpointer g,
                              gpointer self)
{
	gboolean result;
	result = __lambda52_ (self, g);
	return result;
}

static gboolean
__lambda51_ (Block1Data* _data1_,
             gconstpointer key,
             GeeCollection* col)
{
	GeeAbstractMultiMapKeyIterator* self;
	Block3Data* _data3_;
	gpointer _tmp0_;
	gboolean result;
	self = _data1_->self;
	g_return_val_if_fail (col != NULL, FALSE);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->_data1_ = block1_data_ref (_data1_);
	_tmp0_ = ((key != NULL) && (self->priv->k_dup_func != NULL)) ? self->priv->k_dup_func ((gpointer) key) : ((gpointer) key);
	((_data3_->key == NULL) || (self->priv->k_destroy_func == NULL)) ? NULL : (_data3_->key = (self->priv->k_destroy_func (_data3_->key), NULL));
	_data3_->key = _tmp0_;
	result = gee_traversable_foreach ((GeeTraversable*) col, ___lambda52__gee_forall_func, _data3_);
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return result;
}

static gboolean
___lambda51__gee_forall_map_func (gconstpointer k,
                                  gconstpointer v,
                                  gpointer self)
{
	gboolean result;
	result = __lambda51_ (self, k, (GeeCollection*) v);
	return result;
}

static gboolean
gee_abstract_multi_map_key_iterator_real_foreach (GeeTraversable* base,
                                                  GeeForallFunc f,
                                                  gpointer f_target)
{
	GeeAbstractMultiMapKeyIterator * self;
	Block1Data* _data1_;
	gboolean _tmp0_ = FALSE;
	GeeIterator* _tmp1_;
	GeeMapIterator* _tmp9_;
	gboolean result;
	self = (GeeAbstractMultiMapKeyIterator*) base;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_data1_->f = f;
	_data1_->f_target = f_target;
	_tmp1_ = ((GeeAbstractMultiMapMappingIterator*) self)->inner;
	if (_tmp1_ != NULL) {
		GeeMapIterator* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
		_tmp3_ = gee_map_iterator_get_valid (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		Block2Data* _data2_;
		GeeMapIterator* _tmp5_;
		gpointer _tmp6_;
		GeeIterator* _tmp7_;
		GeeMapIterator* _tmp8_;
		_data2_ = g_slice_new0 (Block2Data);
		_data2_->_ref_count_ = 1;
		_data2_->_data1_ = block1_data_ref (_data1_);
		_tmp5_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
		_tmp6_ = gee_map_iterator_get_key (_tmp5_);
		_data2_->key = _tmp6_;
		_tmp7_ = ((GeeAbstractMultiMapMappingIterator*) self)->inner;
		if (!gee_traversable_foreach ((GeeTraversable*) _tmp7_, ____lambda50__gee_forall_func, _data2_)) {
			result = FALSE;
			block2_data_unref (_data2_);
			_data2_ = NULL;
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return result;
		}
		_tmp8_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
		gee_map_iterator_next (_tmp8_);
		block2_data_unref (_data2_);
		_data2_ = NULL;
	}
	_tmp9_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
	result = gee_map_iterator_foreach (_tmp9_, ___lambda51__gee_forall_map_func, _data1_);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}

static void
gee_abstract_multi_map_key_iterator_class_init (GeeAbstractMultiMapKeyIteratorClass * klass,
                                                gpointer klass_data)
{
	gee_abstract_multi_map_key_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeAbstractMultiMapKeyIterator_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_abstract_multi_map_key_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_abstract_multi_map_key_iterator_set_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
}

static GType
gee_abstract_multi_map_key_iterator_gee_traversable_get_g_type (GeeAbstractMultiMapKeyIterator* self)
{
	return self->priv->k_type;
}

static GBoxedCopyFunc
gee_abstract_multi_map_key_iterator_gee_traversable_get_g_dup_func (GeeAbstractMultiMapKeyIterator* self)
{
	return self->priv->k_dup_func;
}

static GDestroyNotify
gee_abstract_multi_map_key_iterator_gee_traversable_get_g_destroy_func (GeeAbstractMultiMapKeyIterator* self)
{
	return self->priv->k_destroy_func;
}

static void
gee_abstract_multi_map_key_iterator_gee_traversable_interface_init (GeeTraversableIface * iface,
                                                                    gpointer iface_data)
{
	gee_abstract_multi_map_key_iterator_gee_traversable_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach = (gboolean (*) (GeeTraversable*, GeeForallFunc, gpointer)) gee_abstract_multi_map_key_iterator_real_foreach;
	iface->get_g_type = (GType (*) (GeeTraversable *)) gee_abstract_multi_map_key_iterator_gee_traversable_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc (*) (GeeTraversable *)) gee_abstract_multi_map_key_iterator_gee_traversable_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify (*) (GeeTraversable *)) gee_abstract_multi_map_key_iterator_gee_traversable_get_g_destroy_func;
}

static void
gee_abstract_multi_map_key_iterator_gee_iterator_interface_init (GeeIteratorIface * iface,
                                                                 gpointer iface_data)
{
	gee_abstract_multi_map_key_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->get = (gpointer (*) (GeeIterator*)) gee_abstract_multi_map_key_iterator_real_get;
	iface->remove = (void (*) (GeeIterator*)) gee_abstract_multi_map_mapping_iterator_remove;
	iface->next = (gboolean (*) (GeeIterator*)) gee_abstract_multi_map_mapping_iterator_next;
	iface->has_next = (gboolean (*) (GeeIterator*)) gee_abstract_multi_map_mapping_iterator_has_next;
	iface->get_valid = (gboolean (*) (GeeIterator *)) gee_abstract_multi_map_mapping_iterator_get_valid;
	iface->get_read_only = (gboolean (*) (GeeIterator *)) gee_abstract_multi_map_mapping_iterator_get_read_only;
}

static void
gee_abstract_multi_map_key_iterator_instance_init (GeeAbstractMultiMapKeyIterator * self,
                                                   gpointer klass)
{
	self->priv = gee_abstract_multi_map_key_iterator_get_instance_private (self);
}

static GType
gee_abstract_multi_map_key_iterator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeAbstractMultiMapKeyIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_abstract_multi_map_key_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeAbstractMultiMapKeyIterator), 0, (GInstanceInitFunc) gee_abstract_multi_map_key_iterator_instance_init, NULL };
	static const GInterfaceInfo gee_traversable_info = { (GInterfaceInitFunc) gee_abstract_multi_map_key_iterator_gee_traversable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_abstract_multi_map_key_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType gee_abstract_multi_map_key_iterator_type_id;
	gee_abstract_multi_map_key_iterator_type_id = g_type_register_static (GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, "GeeAbstractMultiMapKeyIterator", &g_define_type_info, 0);
	g_type_add_interface_static (gee_abstract_multi_map_key_iterator_type_id, GEE_TYPE_TRAVERSABLE, &gee_traversable_info);
	g_type_add_interface_static (gee_abstract_multi_map_key_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
	GeeAbstractMultiMapKeyIterator_private_offset = g_type_add_instance_private (gee_abstract_multi_map_key_iterator_type_id, sizeof (GeeAbstractMultiMapKeyIteratorPrivate));
	return gee_abstract_multi_map_key_iterator_type_id;
}

static GType
gee_abstract_multi_map_key_iterator_get_type (void)
{
	static volatile gsize gee_abstract_multi_map_key_iterator_type_id__once = 0;
	if (g_once_init_enter (&gee_abstract_multi_map_key_iterator_type_id__once)) {
		GType gee_abstract_multi_map_key_iterator_type_id;
		gee_abstract_multi_map_key_iterator_type_id = gee_abstract_multi_map_key_iterator_get_type_once ();
		g_once_init_leave (&gee_abstract_multi_map_key_iterator_type_id__once, gee_abstract_multi_map_key_iterator_type_id);
	}
	return gee_abstract_multi_map_key_iterator_type_id__once;
}

static void
_vala_gee_abstract_multi_map_key_iterator_get_property (GObject * object,
                                                        guint property_id,
                                                        GValue * value,
                                                        GParamSpec * pspec)
{
	GeeAbstractMultiMapKeyIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR, GeeAbstractMultiMapKeyIterator);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_TYPE:
		g_value_set_gtype (value, self->priv->k_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_DUP_FUNC:
		g_value_set_pointer (value, self->priv->k_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->k_destroy_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_TYPE:
		g_value_set_gtype (value, self->priv->v_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_DUP_FUNC:
		g_value_set_pointer (value, self->priv->v_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->v_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_abstract_multi_map_key_iterator_set_property (GObject * object,
                                                        guint property_id,
                                                        const GValue * value,
                                                        GParamSpec * pspec)
{
	GeeAbstractMultiMapKeyIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_KEY_ITERATOR, GeeAbstractMultiMapKeyIterator);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_KEY_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
gee_abstract_multi_map_value_iterator_get_instance_private (GeeAbstractMultiMapValueIterator* self)
{
	return G_STRUCT_MEMBER_P (self, GeeAbstractMultiMapValueIterator_private_offset);
}

static GeeAbstractMultiMapValueIterator*
gee_abstract_multi_map_value_iterator_construct (GType object_type,
                                                 GType k_type,
                                                 GBoxedCopyFunc k_dup_func,
                                                 GDestroyNotify k_destroy_func,
                                                 GType v_type,
                                                 GBoxedCopyFunc v_dup_func,
                                                 GDestroyNotify v_destroy_func,
                                                 GeeMapIterator* outer)
{
	GeeAbstractMultiMapValueIterator * self = NULL;
	self = (GeeAbstractMultiMapValueIterator*) gee_abstract_multi_map_mapping_iterator_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, (GDestroyNotify) k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, (GDestroyNotify) v_destroy_func, outer);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	return self;
}

static GeeAbstractMultiMapValueIterator*
gee_abstract_multi_map_value_iterator_new (GType k_type,
                                           GBoxedCopyFunc k_dup_func,
                                           GDestroyNotify k_destroy_func,
                                           GType v_type,
                                           GBoxedCopyFunc v_dup_func,
                                           GDestroyNotify v_destroy_func,
                                           GeeMapIterator* outer)
{
	return gee_abstract_multi_map_value_iterator_construct (GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, outer);
}

static gpointer
gee_abstract_multi_map_value_iterator_real_get (GeeIterator* base)
{
	GeeAbstractMultiMapValueIterator * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GeeIterator* _tmp2_;
	gpointer _tmp3_;
	gpointer result;
	self = (GeeAbstractMultiMapValueIterator*) base;
	_tmp0_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = ((GeeAbstractMultiMapMappingIterator*) self)->inner;
	_tmp3_ = gee_iterator_get (_tmp2_);
	result = _tmp3_;
	return result;
}

static Block4Data*
block4_data_ref (Block4Data* _data4_)
{
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}

static void
block4_data_unref (void * _userdata_)
{
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		GeeAbstractMultiMapValueIterator* self;
		self = _data4_->self;
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}

static gboolean
__lambda53_ (Block4Data* _data4_,
             gconstpointer key,
             GeeCollection* col)
{
	GeeAbstractMultiMapValueIterator* self;
	gboolean result;
	self = _data4_->self;
	g_return_val_if_fail (col != NULL, FALSE);
	result = gee_traversable_foreach ((GeeTraversable*) col, _data4_->f, _data4_->f_target);
	return result;
}

static gboolean
___lambda53__gee_forall_map_func (gconstpointer k,
                                  gconstpointer v,
                                  gpointer self)
{
	gboolean result;
	result = __lambda53_ (self, k, (GeeCollection*) v);
	return result;
}

static gboolean
gee_abstract_multi_map_value_iterator_real_foreach (GeeTraversable* base,
                                                    GeeForallFunc f,
                                                    gpointer f_target)
{
	GeeAbstractMultiMapValueIterator * self;
	Block4Data* _data4_;
	gboolean _tmp0_ = FALSE;
	GeeIterator* _tmp1_;
	GeeMapIterator* _tmp7_;
	gboolean result;
	self = (GeeAbstractMultiMapValueIterator*) base;
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_data4_->f = f;
	_data4_->f_target = f_target;
	_tmp1_ = ((GeeAbstractMultiMapMappingIterator*) self)->inner;
	if (_tmp1_ != NULL) {
		GeeMapIterator* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
		_tmp3_ = gee_map_iterator_get_valid (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GeeIterator* _tmp5_;
		GeeMapIterator* _tmp6_;
		_tmp5_ = ((GeeAbstractMultiMapMappingIterator*) self)->inner;
		if (!gee_traversable_foreach ((GeeTraversable*) _tmp5_, _data4_->f, _data4_->f_target)) {
			result = FALSE;
			block4_data_unref (_data4_);
			_data4_ = NULL;
			return result;
		}
		_tmp6_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
		gee_map_iterator_next (_tmp6_);
	}
	_tmp7_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
	result = gee_map_iterator_foreach (_tmp7_, ___lambda53__gee_forall_map_func, _data4_);
	block4_data_unref (_data4_);
	_data4_ = NULL;
	return result;
}

static void
gee_abstract_multi_map_value_iterator_class_init (GeeAbstractMultiMapValueIteratorClass * klass,
                                                  gpointer klass_data)
{
	gee_abstract_multi_map_value_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeAbstractMultiMapValueIterator_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_abstract_multi_map_value_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_abstract_multi_map_value_iterator_set_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
}

static GType
gee_abstract_multi_map_value_iterator_gee_traversable_get_g_type (GeeAbstractMultiMapValueIterator* self)
{
	return self->priv->v_type;
}

static GBoxedCopyFunc
gee_abstract_multi_map_value_iterator_gee_traversable_get_g_dup_func (GeeAbstractMultiMapValueIterator* self)
{
	return self->priv->v_dup_func;
}

static GDestroyNotify
gee_abstract_multi_map_value_iterator_gee_traversable_get_g_destroy_func (GeeAbstractMultiMapValueIterator* self)
{
	return self->priv->v_destroy_func;
}

static void
gee_abstract_multi_map_value_iterator_gee_traversable_interface_init (GeeTraversableIface * iface,
                                                                      gpointer iface_data)
{
	gee_abstract_multi_map_value_iterator_gee_traversable_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach = (gboolean (*) (GeeTraversable*, GeeForallFunc, gpointer)) gee_abstract_multi_map_value_iterator_real_foreach;
	iface->get_g_type = (GType (*) (GeeTraversable *)) gee_abstract_multi_map_value_iterator_gee_traversable_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc (*) (GeeTraversable *)) gee_abstract_multi_map_value_iterator_gee_traversable_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify (*) (GeeTraversable *)) gee_abstract_multi_map_value_iterator_gee_traversable_get_g_destroy_func;
}

static void
gee_abstract_multi_map_value_iterator_gee_iterator_interface_init (GeeIteratorIface * iface,
                                                                   gpointer iface_data)
{
	gee_abstract_multi_map_value_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->get = (gpointer (*) (GeeIterator*)) gee_abstract_multi_map_value_iterator_real_get;
	iface->remove = (void (*) (GeeIterator*)) gee_abstract_multi_map_mapping_iterator_remove;
	iface->next = (gboolean (*) (GeeIterator*)) gee_abstract_multi_map_mapping_iterator_next;
	iface->has_next = (gboolean (*) (GeeIterator*)) gee_abstract_multi_map_mapping_iterator_has_next;
	iface->get_valid = (gboolean (*) (GeeIterator *)) gee_abstract_multi_map_mapping_iterator_get_valid;
	iface->get_read_only = (gboolean (*) (GeeIterator *)) gee_abstract_multi_map_mapping_iterator_get_read_only;
}

static void
gee_abstract_multi_map_value_iterator_instance_init (GeeAbstractMultiMapValueIterator * self,
                                                     gpointer klass)
{
	self->priv = gee_abstract_multi_map_value_iterator_get_instance_private (self);
}

static GType
gee_abstract_multi_map_value_iterator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeAbstractMultiMapValueIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_abstract_multi_map_value_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeAbstractMultiMapValueIterator), 0, (GInstanceInitFunc) gee_abstract_multi_map_value_iterator_instance_init, NULL };
	static const GInterfaceInfo gee_traversable_info = { (GInterfaceInitFunc) gee_abstract_multi_map_value_iterator_gee_traversable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_abstract_multi_map_value_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType gee_abstract_multi_map_value_iterator_type_id;
	gee_abstract_multi_map_value_iterator_type_id = g_type_register_static (GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, "GeeAbstractMultiMapValueIterator", &g_define_type_info, 0);
	g_type_add_interface_static (gee_abstract_multi_map_value_iterator_type_id, GEE_TYPE_TRAVERSABLE, &gee_traversable_info);
	g_type_add_interface_static (gee_abstract_multi_map_value_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
	GeeAbstractMultiMapValueIterator_private_offset = g_type_add_instance_private (gee_abstract_multi_map_value_iterator_type_id, sizeof (GeeAbstractMultiMapValueIteratorPrivate));
	return gee_abstract_multi_map_value_iterator_type_id;
}

static GType
gee_abstract_multi_map_value_iterator_get_type (void)
{
	static volatile gsize gee_abstract_multi_map_value_iterator_type_id__once = 0;
	if (g_once_init_enter (&gee_abstract_multi_map_value_iterator_type_id__once)) {
		GType gee_abstract_multi_map_value_iterator_type_id;
		gee_abstract_multi_map_value_iterator_type_id = gee_abstract_multi_map_value_iterator_get_type_once ();
		g_once_init_leave (&gee_abstract_multi_map_value_iterator_type_id__once, gee_abstract_multi_map_value_iterator_type_id);
	}
	return gee_abstract_multi_map_value_iterator_type_id__once;
}

static void
_vala_gee_abstract_multi_map_value_iterator_get_property (GObject * object,
                                                          guint property_id,
                                                          GValue * value,
                                                          GParamSpec * pspec)
{
	GeeAbstractMultiMapValueIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR, GeeAbstractMultiMapValueIterator);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_TYPE:
		g_value_set_gtype (value, self->priv->k_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_DUP_FUNC:
		g_value_set_pointer (value, self->priv->k_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->k_destroy_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_TYPE:
		g_value_set_gtype (value, self->priv->v_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_DUP_FUNC:
		g_value_set_pointer (value, self->priv->v_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->v_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_abstract_multi_map_value_iterator_set_property (GObject * object,
                                                          guint property_id,
                                                          const GValue * value,
                                                          GParamSpec * pspec)
{
	GeeAbstractMultiMapValueIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_VALUE_ITERATOR, GeeAbstractMultiMapValueIterator);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_VALUE_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
gee_abstract_multi_map_map_iterator_get_instance_private (GeeAbstractMultiMapMapIterator* self)
{
	return G_STRUCT_MEMBER_P (self, GeeAbstractMultiMapMapIterator_private_offset);
}

static GeeAbstractMultiMapMapIterator*
gee_abstract_multi_map_map_iterator_construct (GType object_type,
                                               GType k_type,
                                               GBoxedCopyFunc k_dup_func,
                                               GDestroyNotify k_destroy_func,
                                               GType v_type,
                                               GBoxedCopyFunc v_dup_func,
                                               GDestroyNotify v_destroy_func,
                                               GeeMapIterator* outer)
{
	GeeAbstractMultiMapMapIterator * self = NULL;
	self = (GeeAbstractMultiMapMapIterator*) gee_abstract_multi_map_mapping_iterator_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, (GDestroyNotify) k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, (GDestroyNotify) v_destroy_func, outer);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	return self;
}

static GeeAbstractMultiMapMapIterator*
gee_abstract_multi_map_map_iterator_new (GType k_type,
                                         GBoxedCopyFunc k_dup_func,
                                         GDestroyNotify k_destroy_func,
                                         GType v_type,
                                         GBoxedCopyFunc v_dup_func,
                                         GDestroyNotify v_destroy_func,
                                         GeeMapIterator* outer)
{
	return gee_abstract_multi_map_map_iterator_construct (GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, outer);
}

static gpointer
gee_abstract_multi_map_map_iterator_real_get_key (GeeMapIterator* base)
{
	GeeAbstractMultiMapMapIterator * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GeeMapIterator* _tmp2_;
	gpointer _tmp3_;
	gpointer result;
	self = (GeeAbstractMultiMapMapIterator*) base;
	_tmp0_ = gee_map_iterator_get_valid ((GeeMapIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = ((GeeAbstractMultiMapMappingIterator*) self)->outer;
	_tmp3_ = gee_map_iterator_get_key (_tmp2_);
	result = _tmp3_;
	return result;
}

static gpointer
gee_abstract_multi_map_map_iterator_real_get_value (GeeMapIterator* base)
{
	GeeAbstractMultiMapMapIterator * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GeeIterator* _tmp2_;
	gpointer _tmp3_;
	gpointer result;
	self = (GeeAbstractMultiMapMapIterator*) base;
	_tmp0_ = gee_map_iterator_get_valid ((GeeMapIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = ((GeeAbstractMultiMapMappingIterator*) self)->inner;
	_tmp3_ = gee_iterator_get (_tmp2_);
	result = _tmp3_;
	return result;
}

static void
gee_abstract_multi_map_map_iterator_real_set_value (GeeMapIterator* base,
                                                    gconstpointer value)
{
	GeeAbstractMultiMapMapIterator * self;
	self = (GeeAbstractMultiMapMapIterator*) base;
	g_assert_not_reached ();
}

static gboolean
gee_abstract_multi_map_map_iterator_real_get_mutable (GeeMapIterator* base)
{
	gboolean result;
	GeeAbstractMultiMapMapIterator* self;
	self = (GeeAbstractMultiMapMapIterator*) base;
	result = FALSE;
	return result;
}

static void
gee_abstract_multi_map_map_iterator_class_init (GeeAbstractMultiMapMapIteratorClass * klass,
                                                gpointer klass_data)
{
	gee_abstract_multi_map_map_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeAbstractMultiMapMapIterator_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_abstract_multi_map_map_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_abstract_multi_map_map_iterator_set_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_MUTABLE_PROPERTY, gee_abstract_multi_map_map_iterator_properties[GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_MUTABLE_PROPERTY] = g_param_spec_boolean ("mutable", "mutable", "mutable", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static GType
gee_abstract_multi_map_map_iterator_gee_map_iterator_get_k_type (GeeAbstractMultiMapMapIterator* self)
{
	return self->priv->k_type;
}

static GBoxedCopyFunc
gee_abstract_multi_map_map_iterator_gee_map_iterator_get_k_dup_func (GeeAbstractMultiMapMapIterator* self)
{
	return self->priv->k_dup_func;
}

static GDestroyNotify
gee_abstract_multi_map_map_iterator_gee_map_iterator_get_k_destroy_func (GeeAbstractMultiMapMapIterator* self)
{
	return self->priv->k_destroy_func;
}

static GType
gee_abstract_multi_map_map_iterator_gee_map_iterator_get_v_type (GeeAbstractMultiMapMapIterator* self)
{
	return self->priv->v_type;
}

static GBoxedCopyFunc
gee_abstract_multi_map_map_iterator_gee_map_iterator_get_v_dup_func (GeeAbstractMultiMapMapIterator* self)
{
	return self->priv->v_dup_func;
}

static GDestroyNotify
gee_abstract_multi_map_map_iterator_gee_map_iterator_get_v_destroy_func (GeeAbstractMultiMapMapIterator* self)
{
	return self->priv->v_destroy_func;
}

static void
gee_abstract_multi_map_map_iterator_gee_map_iterator_interface_init (GeeMapIteratorIface * iface,
                                                                     gpointer iface_data)
{
	gee_abstract_multi_map_map_iterator_gee_map_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_key = (gpointer (*) (GeeMapIterator*)) gee_abstract_multi_map_map_iterator_real_get_key;
	iface->get_value = (gpointer (*) (GeeMapIterator*)) gee_abstract_multi_map_map_iterator_real_get_value;
	iface->set_value = (void (*) (GeeMapIterator*, gconstpointer)) gee_abstract_multi_map_map_iterator_real_set_value;
	iface->get_k_type = (GType (*) (GeeMapIterator *)) gee_abstract_multi_map_map_iterator_gee_map_iterator_get_k_type;
	iface->get_k_dup_func = (GBoxedCopyFunc (*) (GeeMapIterator *)) gee_abstract_multi_map_map_iterator_gee_map_iterator_get_k_dup_func;
	iface->get_k_destroy_func = (GDestroyNotify (*) (GeeMapIterator *)) gee_abstract_multi_map_map_iterator_gee_map_iterator_get_k_destroy_func;
	iface->get_v_type = (GType (*) (GeeMapIterator *)) gee_abstract_multi_map_map_iterator_gee_map_iterator_get_v_type;
	iface->get_v_dup_func = (GBoxedCopyFunc (*) (GeeMapIterator *)) gee_abstract_multi_map_map_iterator_gee_map_iterator_get_v_dup_func;
	iface->get_v_destroy_func = (GDestroyNotify (*) (GeeMapIterator *)) gee_abstract_multi_map_map_iterator_gee_map_iterator_get_v_destroy_func;
	iface->next = (gboolean (*) (GeeMapIterator*)) gee_abstract_multi_map_mapping_iterator_next;
	iface->has_next = (gboolean (*) (GeeMapIterator*)) gee_abstract_multi_map_mapping_iterator_has_next;
	iface->unset = (void (*) (GeeMapIterator*)) gee_abstract_multi_map_mapping_iterator_unset;
	iface->get_mutable = gee_abstract_multi_map_map_iterator_real_get_mutable;
	iface->get_valid = (gboolean (*) (GeeMapIterator *)) gee_abstract_multi_map_mapping_iterator_get_valid;
	iface->get_read_only = (gboolean (*) (GeeMapIterator *)) gee_abstract_multi_map_mapping_iterator_get_read_only;
}

static void
gee_abstract_multi_map_map_iterator_instance_init (GeeAbstractMultiMapMapIterator * self,
                                                   gpointer klass)
{
	self->priv = gee_abstract_multi_map_map_iterator_get_instance_private (self);
}

static GType
gee_abstract_multi_map_map_iterator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeAbstractMultiMapMapIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_abstract_multi_map_map_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeAbstractMultiMapMapIterator), 0, (GInstanceInitFunc) gee_abstract_multi_map_map_iterator_instance_init, NULL };
	static const GInterfaceInfo gee_map_iterator_info = { (GInterfaceInitFunc) gee_abstract_multi_map_map_iterator_gee_map_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType gee_abstract_multi_map_map_iterator_type_id;
	gee_abstract_multi_map_map_iterator_type_id = g_type_register_static (GEE_ABSTRACT_MULTI_MAP_TYPE_MAPPING_ITERATOR, "GeeAbstractMultiMapMapIterator", &g_define_type_info, 0);
	g_type_add_interface_static (gee_abstract_multi_map_map_iterator_type_id, GEE_TYPE_MAP_ITERATOR, &gee_map_iterator_info);
	GeeAbstractMultiMapMapIterator_private_offset = g_type_add_instance_private (gee_abstract_multi_map_map_iterator_type_id, sizeof (GeeAbstractMultiMapMapIteratorPrivate));
	return gee_abstract_multi_map_map_iterator_type_id;
}

static GType
gee_abstract_multi_map_map_iterator_get_type (void)
{
	static volatile gsize gee_abstract_multi_map_map_iterator_type_id__once = 0;
	if (g_once_init_enter (&gee_abstract_multi_map_map_iterator_type_id__once)) {
		GType gee_abstract_multi_map_map_iterator_type_id;
		gee_abstract_multi_map_map_iterator_type_id = gee_abstract_multi_map_map_iterator_get_type_once ();
		g_once_init_leave (&gee_abstract_multi_map_map_iterator_type_id__once, gee_abstract_multi_map_map_iterator_type_id);
	}
	return gee_abstract_multi_map_map_iterator_type_id__once;
}

static void
_vala_gee_abstract_multi_map_map_iterator_get_property (GObject * object,
                                                        guint property_id,
                                                        GValue * value,
                                                        GParamSpec * pspec)
{
	GeeAbstractMultiMapMapIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR, GeeAbstractMultiMapMapIterator);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_MUTABLE_PROPERTY:
		g_value_set_boolean (value, gee_map_iterator_get_mutable ((GeeMapIterator*) self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_TYPE:
		g_value_set_gtype (value, self->priv->k_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_DUP_FUNC:
		g_value_set_pointer (value, self->priv->k_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->k_destroy_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_TYPE:
		g_value_set_gtype (value, self->priv->v_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_DUP_FUNC:
		g_value_set_pointer (value, self->priv->v_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->v_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_abstract_multi_map_map_iterator_set_property (GObject * object,
                                                        guint property_id,
                                                        const GValue * value,
                                                        GParamSpec * pspec)
{
	GeeAbstractMultiMapMapIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_ABSTRACT_MULTI_MAP_TYPE_MAP_ITERATOR, GeeAbstractMultiMapMapIterator);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_MAP_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static GObject *
gee_abstract_multi_map_constructor (GType type,
                                    guint n_construct_properties,
                                    GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	GeeAbstractMultiMap * self;
	parent_class = G_OBJECT_CLASS (gee_abstract_multi_map_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_TYPE_ABSTRACT_MULTI_MAP, GeeAbstractMultiMap);
	g_weak_ref_clear (&self->priv->_read_only_view);
	g_weak_ref_init (&self->priv->_read_only_view, NULL);
	return obj;
}

static void
gee_abstract_multi_map_class_init (GeeAbstractMultiMapClass * klass,
                                   gpointer klass_data)
{
	gee_abstract_multi_map_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &GeeAbstractMultiMap_private_offset);
	((GeeAbstractMultiMapClass *) klass)->create_value_storage = (GeeCollection* (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_create_value_storage;
	((GeeAbstractMultiMapClass *) klass)->create_multi_key_set = (GeeMultiSet* (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_create_multi_key_set;
	((GeeAbstractMultiMapClass *) klass)->get_value_equal_func = (GeeEqualDataFunc (*) (GeeAbstractMultiMap*, gpointer*, GDestroyNotify*)) gee_abstract_multi_map_real_get_value_equal_func;
	((GeeAbstractMultiMapClass *) klass)->reserved0 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved0;
	((GeeAbstractMultiMapClass *) klass)->reserved1 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved1;
	((GeeAbstractMultiMapClass *) klass)->reserved2 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved2;
	((GeeAbstractMultiMapClass *) klass)->reserved3 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved3;
	((GeeAbstractMultiMapClass *) klass)->reserved4 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved4;
	((GeeAbstractMultiMapClass *) klass)->reserved5 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved5;
	((GeeAbstractMultiMapClass *) klass)->reserved6 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved6;
	((GeeAbstractMultiMapClass *) klass)->reserved7 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved7;
	((GeeAbstractMultiMapClass *) klass)->reserved8 = (void (*) (GeeAbstractMultiMap*)) gee_abstract_multi_map_real_reserved8;
	GEE_ABSTRACT_MULTI_MAP_CLASS (klass)->get_read_only_view = gee_abstract_multi_map_real_get_read_only_view;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_abstract_multi_map_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_abstract_multi_map_set_property;
	G_OBJECT_CLASS (klass)->constructor = gee_abstract_multi_map_constructor;
	G_OBJECT_CLASS (klass)->finalize = gee_abstract_multi_map_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_SIZE_PROPERTY, gee_abstract_multi_map_properties[GEE_ABSTRACT_MULTI_MAP_SIZE_PROPERTY] = g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_ABSTRACT_MULTI_MAP_READ_ONLY_PROPERTY, gee_abstract_multi_map_properties[GEE_ABSTRACT_MULTI_MAP_READ_ONLY_PROPERTY] = g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static GType
gee_abstract_multi_map_gee_multi_map_get_k_type (GeeAbstractMultiMap* self)
{
	return self->priv->k_type;
}

static GBoxedCopyFunc
gee_abstract_multi_map_gee_multi_map_get_k_dup_func (GeeAbstractMultiMap* self)
{
	return self->priv->k_dup_func;
}

static GDestroyNotify
gee_abstract_multi_map_gee_multi_map_get_k_destroy_func (GeeAbstractMultiMap* self)
{
	return self->priv->k_destroy_func;
}

static GType
gee_abstract_multi_map_gee_multi_map_get_v_type (GeeAbstractMultiMap* self)
{
	return self->priv->v_type;
}

static GBoxedCopyFunc
gee_abstract_multi_map_gee_multi_map_get_v_dup_func (GeeAbstractMultiMap* self)
{
	return self->priv->v_dup_func;
}

static GDestroyNotify
gee_abstract_multi_map_gee_multi_map_get_v_destroy_func (GeeAbstractMultiMap* self)
{
	return self->priv->v_destroy_func;
}

static void
gee_abstract_multi_map_gee_multi_map_interface_init (GeeMultiMapIface * iface,
                                                     gpointer iface_data)
{
	gee_abstract_multi_map_gee_multi_map_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_keys = (GeeSet* (*) (GeeMultiMap*)) gee_abstract_multi_map_real_get_keys;
	iface->get_all_keys = (GeeMultiSet* (*) (GeeMultiMap*)) gee_abstract_multi_map_real_get_all_keys;
	iface->get_values = (GeeCollection* (*) (GeeMultiMap*)) gee_abstract_multi_map_real_get_values;
	iface->contains = (gboolean (*) (GeeMultiMap*, gconstpointer)) gee_abstract_multi_map_real_contains;
	iface->get = (GeeCollection* (*) (GeeMultiMap*, gconstpointer)) gee_abstract_multi_map_real_get;
	iface->set = (void (*) (GeeMultiMap*, gconstpointer, gconstpointer)) gee_abstract_multi_map_real_set;
	iface->remove = (gboolean (*) (GeeMultiMap*, gconstpointer, gconstpointer)) gee_abstract_multi_map_real_remove;
	iface->remove_all = (gboolean (*) (GeeMultiMap*, gconstpointer)) gee_abstract_multi_map_real_remove_all;
	iface->clear = (void (*) (GeeMultiMap*)) gee_abstract_multi_map_real_clear;
	iface->map_iterator = (GeeMapIterator* (*) (GeeMultiMap*)) gee_abstract_multi_map_real_map_iterator;
	iface->get_k_type = (GType (*) (GeeMultiMap *)) gee_abstract_multi_map_gee_multi_map_get_k_type;
	iface->get_k_dup_func = (GBoxedCopyFunc (*) (GeeMultiMap *)) gee_abstract_multi_map_gee_multi_map_get_k_dup_func;
	iface->get_k_destroy_func = (GDestroyNotify (*) (GeeMultiMap *)) gee_abstract_multi_map_gee_multi_map_get_k_destroy_func;
	iface->get_v_type = (GType (*) (GeeMultiMap *)) gee_abstract_multi_map_gee_multi_map_get_v_type;
	iface->get_v_dup_func = (GBoxedCopyFunc (*) (GeeMultiMap *)) gee_abstract_multi_map_gee_multi_map_get_v_dup_func;
	iface->get_v_destroy_func = (GDestroyNotify (*) (GeeMultiMap *)) gee_abstract_multi_map_gee_multi_map_get_v_destroy_func;
	iface->get_size = gee_abstract_multi_map_real_get_size;
	iface->get_read_only = gee_abstract_multi_map_real_get_read_only;
	iface->get_read_only_view = (GeeMultiMap* (*) (GeeMultiMap *)) gee_abstract_multi_map_get_read_only_view;
}

static void
gee_abstract_multi_map_instance_init (GeeAbstractMultiMap * self,
                                      gpointer klass)
{
	self->priv = gee_abstract_multi_map_get_instance_private (self);
	self->priv->_nitems = 0;
}

static void
gee_abstract_multi_map_finalize (GObject * obj)
{
	GeeAbstractMultiMap * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_TYPE_ABSTRACT_MULTI_MAP, GeeAbstractMultiMap);
	_g_object_unref0 (self->_storage_map);
	g_weak_ref_clear (&self->priv->_read_only_view);
	G_OBJECT_CLASS (gee_abstract_multi_map_parent_class)->finalize (obj);
}

/**
 * Skeletal implementation of the {@link MultiMap} interface.
 *
 * @see HashMultiMap
 * @see TreeMultiMap
 */
static GType
gee_abstract_multi_map_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeeAbstractMultiMapClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_abstract_multi_map_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeAbstractMultiMap), 0, (GInstanceInitFunc) gee_abstract_multi_map_instance_init, NULL };
	static const GInterfaceInfo gee_multi_map_info = { (GInterfaceInitFunc) gee_abstract_multi_map_gee_multi_map_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType gee_abstract_multi_map_type_id;
	gee_abstract_multi_map_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeAbstractMultiMap", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	g_type_add_interface_static (gee_abstract_multi_map_type_id, GEE_TYPE_MULTI_MAP, &gee_multi_map_info);
	GeeAbstractMultiMap_private_offset = g_type_add_instance_private (gee_abstract_multi_map_type_id, sizeof (GeeAbstractMultiMapPrivate));
	return gee_abstract_multi_map_type_id;
}

GType
gee_abstract_multi_map_get_type (void)
{
	static volatile gsize gee_abstract_multi_map_type_id__once = 0;
	if (g_once_init_enter (&gee_abstract_multi_map_type_id__once)) {
		GType gee_abstract_multi_map_type_id;
		gee_abstract_multi_map_type_id = gee_abstract_multi_map_get_type_once ();
		g_once_init_leave (&gee_abstract_multi_map_type_id__once, gee_abstract_multi_map_type_id);
	}
	return gee_abstract_multi_map_type_id__once;
}

static void
_vala_gee_abstract_multi_map_get_property (GObject * object,
                                           guint property_id,
                                           GValue * value,
                                           GParamSpec * pspec)
{
	GeeAbstractMultiMap * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_TYPE_ABSTRACT_MULTI_MAP, GeeAbstractMultiMap);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_SIZE_PROPERTY:
		g_value_set_int (value, gee_multi_map_get_size ((GeeMultiMap*) self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_READ_ONLY_PROPERTY:
		g_value_set_boolean (value, gee_multi_map_get_read_only ((GeeMultiMap*) self));
		break;
		case GEE_ABSTRACT_MULTI_MAP_K_TYPE:
		g_value_set_gtype (value, self->priv->k_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_K_DUP_FUNC:
		g_value_set_pointer (value, self->priv->k_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_K_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->k_destroy_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_V_TYPE:
		g_value_set_gtype (value, self->priv->v_type);
		break;
		case GEE_ABSTRACT_MULTI_MAP_V_DUP_FUNC:
		g_value_set_pointer (value, self->priv->v_dup_func);
		break;
		case GEE_ABSTRACT_MULTI_MAP_V_DESTROY_FUNC:
		g_value_set_pointer (value, self->priv->v_destroy_func);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_gee_abstract_multi_map_set_property (GObject * object,
                                           guint property_id,
                                           const GValue * value,
                                           GParamSpec * pspec)
{
	GeeAbstractMultiMap * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_TYPE_ABSTRACT_MULTI_MAP, GeeAbstractMultiMap);
	switch (property_id) {
		case GEE_ABSTRACT_MULTI_MAP_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_ABSTRACT_MULTI_MAP_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

