/* testreadonlycollection.c generated by valac 0.56.3, the Vala compiler
 * generated from testreadonlycollection.vala, do not modify */

/* testreadonlycollection.vala
 *
 * Copyright (C) 2008  Jürg Billeter
 * Copyright (C) 2009  Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Tomaž Vajngerl <quikee@gmail.com>
 * 	Julien Peeters <contact@julienpeeters.fr>
 */

#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define GEE_TYPE_TEST_CASE (gee_test_case_get_type ())
#define GEE_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TEST_CASE, GeeTestCase))
#define GEE_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_TEST_CASE, GeeTestCaseClass))
#define GEE_IS_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TEST_CASE))
#define GEE_IS_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_TEST_CASE))
#define GEE_TEST_CASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_TEST_CASE, GeeTestCaseClass))

typedef struct _GeeTestCase GeeTestCase;
typedef struct _GeeTestCaseClass GeeTestCaseClass;
typedef struct _GeeTestCasePrivate GeeTestCasePrivate;

#define TYPE_READ_ONLY_COLLECTION_TESTS (read_only_collection_tests_get_type ())
#define READ_ONLY_COLLECTION_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTests))
#define READ_ONLY_COLLECTION_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTestsClass))
#define IS_READ_ONLY_COLLECTION_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_READ_ONLY_COLLECTION_TESTS))
#define IS_READ_ONLY_COLLECTION_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_READ_ONLY_COLLECTION_TESTS))
#define READ_ONLY_COLLECTION_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTestsClass))

typedef struct _ReadOnlyCollectionTests ReadOnlyCollectionTests;
typedef struct _ReadOnlyCollectionTestsClass ReadOnlyCollectionTestsClass;
typedef struct _ReadOnlyCollectionTestsPrivate ReadOnlyCollectionTestsPrivate;
enum  {
	READ_ONLY_COLLECTION_TESTS_0_PROPERTY,
	READ_ONLY_COLLECTION_TESTS_NUM_PROPERTIES
};
static GParamSpec* read_only_collection_tests_properties[READ_ONLY_COLLECTION_TESTS_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef void (*GeeTestCaseTestMethod) (gpointer user_data);
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeTestCase {
	GObject parent_instance;
	GeeTestCasePrivate * priv;
};

struct _GeeTestCaseClass {
	GObjectClass parent_class;
	void (*set_up) (GeeTestCase* self);
	void (*tear_down) (GeeTestCase* self);
};

struct _ReadOnlyCollectionTests {
	GeeTestCase parent_instance;
	ReadOnlyCollectionTestsPrivate * priv;
	GeeCollection* test_collection;
	GeeCollection* ro_collection;
};

struct _ReadOnlyCollectionTestsClass {
	GeeTestCaseClass parent_class;
	GeeCollection* (*get_ro_view) (ReadOnlyCollectionTests* self, GeeCollection* collection);
};

static gpointer read_only_collection_tests_parent_class = NULL;

VALA_EXTERN GType gee_test_case_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GeeTestCase, g_object_unref)
VALA_EXTERN GType read_only_collection_tests_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ReadOnlyCollectionTests, g_object_unref)
VALA_EXTERN void gee_test_case_set_up (GeeTestCase* self);
VALA_EXTERN void gee_test_case_tear_down (GeeTestCase* self);
VALA_EXTERN GeeCollection* read_only_collection_tests_get_ro_view (ReadOnlyCollectionTests* self,
                                                       GeeCollection* collection);
VALA_EXTERN ReadOnlyCollectionTests* read_only_collection_tests_new (void);
VALA_EXTERN ReadOnlyCollectionTests* read_only_collection_tests_construct (GType object_type);
VALA_EXTERN ReadOnlyCollectionTests* read_only_collection_tests_new_with_name (const gchar* name);
VALA_EXTERN ReadOnlyCollectionTests* read_only_collection_tests_construct_with_name (GType object_type,
                                                                         const gchar* name);
VALA_EXTERN GeeTestCase* gee_test_case_construct (GType object_type,
                                      const gchar* name);
VALA_EXTERN void gee_test_case_add_test (GeeTestCase* self,
                             const gchar* name,
                             GeeTestCaseTestMethod test,
                             gpointer test_target,
                             GDestroyNotify test_target_destroy_notify);
VALA_EXTERN void read_only_collection_tests_test_unique_read_only_view_instance (ReadOnlyCollectionTests* self);
static void _read_only_collection_tests_test_unique_read_only_view_instance_gee_test_case_test_method (gpointer self);
VALA_EXTERN void read_only_collection_tests_test_immutable_iterator (ReadOnlyCollectionTests* self);
static void _read_only_collection_tests_test_immutable_iterator_gee_test_case_test_method (gpointer self);
VALA_EXTERN void read_only_collection_tests_test_immutable (ReadOnlyCollectionTests* self);
static void _read_only_collection_tests_test_immutable_gee_test_case_test_method (gpointer self);
VALA_EXTERN void read_only_collection_tests_test_accurate_view (ReadOnlyCollectionTests* self);
static void _read_only_collection_tests_test_accurate_view_gee_test_case_test_method (gpointer self);
static void read_only_collection_tests_real_set_up (GeeTestCase* base);
static void read_only_collection_tests_real_tear_down (GeeTestCase* base);
static GeeCollection* read_only_collection_tests_real_get_ro_view (ReadOnlyCollectionTests* self,
                                                            GeeCollection* collection);
static void read_only_collection_tests_finalize (GObject * obj);
static GType read_only_collection_tests_get_type_once (void);

ReadOnlyCollectionTests*
read_only_collection_tests_construct (GType object_type)
{
	ReadOnlyCollectionTests * self = NULL;
	self = (ReadOnlyCollectionTests*) read_only_collection_tests_construct_with_name (object_type, "ReadOnlyCollection");
	return self;
}

ReadOnlyCollectionTests*
read_only_collection_tests_new (void)
{
	return read_only_collection_tests_construct (TYPE_READ_ONLY_COLLECTION_TESTS);
}

static void
_read_only_collection_tests_test_unique_read_only_view_instance_gee_test_case_test_method (gpointer self)
{
	read_only_collection_tests_test_unique_read_only_view_instance ((ReadOnlyCollectionTests*) self);
}

static void
_read_only_collection_tests_test_immutable_iterator_gee_test_case_test_method (gpointer self)
{
	read_only_collection_tests_test_immutable_iterator ((ReadOnlyCollectionTests*) self);
}

static void
_read_only_collection_tests_test_immutable_gee_test_case_test_method (gpointer self)
{
	read_only_collection_tests_test_immutable ((ReadOnlyCollectionTests*) self);
}

static void
_read_only_collection_tests_test_accurate_view_gee_test_case_test_method (gpointer self)
{
	read_only_collection_tests_test_accurate_view ((ReadOnlyCollectionTests*) self);
}

ReadOnlyCollectionTests*
read_only_collection_tests_construct_with_name (GType object_type,
                                                const gchar* name)
{
	ReadOnlyCollectionTests * self = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	self = (ReadOnlyCollectionTests*) gee_test_case_construct (object_type, name);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyCollection] unique read-only view instance", _read_only_collection_tests_test_unique_read_only_view_instance_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyCollection] immutable iterator", _read_only_collection_tests_test_immutable_iterator_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyCollection] immutable", _read_only_collection_tests_test_immutable_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyCollection] accurate view", _read_only_collection_tests_test_accurate_view_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	return self;
}

ReadOnlyCollectionTests*
read_only_collection_tests_new_with_name (const gchar* name)
{
	return read_only_collection_tests_construct_with_name (TYPE_READ_ONLY_COLLECTION_TESTS, name);
}

static void
read_only_collection_tests_real_set_up (GeeTestCase* base)
{
	ReadOnlyCollectionTests * self;
	GeeHashMultiSet* _tmp0_;
	GeeCollection* _tmp1_;
	GeeCollection* _tmp2_;
	self = (ReadOnlyCollectionTests*) base;
	_tmp0_ = gee_hash_multi_set_new_fixed (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->test_collection);
	self->test_collection = (GeeCollection*) _tmp0_;
	_tmp1_ = self->test_collection;
	_tmp2_ = read_only_collection_tests_get_ro_view (self, _tmp1_);
	_g_object_unref0 (self->ro_collection);
	self->ro_collection = _tmp2_;
}

static void
read_only_collection_tests_real_tear_down (GeeTestCase* base)
{
	ReadOnlyCollectionTests * self;
	self = (ReadOnlyCollectionTests*) base;
	_g_object_unref0 (self->test_collection);
	self->test_collection = NULL;
	_g_object_unref0 (self->ro_collection);
	self->ro_collection = NULL;
}

static GeeCollection*
read_only_collection_tests_real_get_ro_view (ReadOnlyCollectionTests* self,
                                             GeeCollection* collection)
{
	GeeCollection* _tmp0_;
	GeeCollection* _tmp1_;
	GeeCollection* result;
	g_return_val_if_fail (collection != NULL, NULL);
	_tmp0_ = gee_collection_get_read_only_view (collection);
	_tmp1_ = _tmp0_;
	result = _tmp1_;
	return result;
}

GeeCollection*
read_only_collection_tests_get_ro_view (ReadOnlyCollectionTests* self,
                                        GeeCollection* collection)
{
	ReadOnlyCollectionTestsClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = READ_ONLY_COLLECTION_TESTS_GET_CLASS (self);
	if (_klass_->get_ro_view) {
		return _klass_->get_ro_view (self, collection);
	}
	return NULL;
}

void
read_only_collection_tests_test_unique_read_only_view_instance (ReadOnlyCollectionTests* self)
{
	GeeCollection* another_ro_collection = NULL;
	GeeCollection* _tmp0_;
	GeeCollection* _tmp1_;
	GeeCollection* _tmp2_;
	GeeCollection* _tmp3_;
	GeeCollection* _tmp4_;
	GObject* _tmp5_;
	GeeCollection* _tmp6_;
	gconstpointer _tmp7_;
	GeeCollection* _tmp8_;
	GeeCollection* _tmp9_;
	GeeCollection* _tmp10_;
	gconstpointer _tmp11_;
	GeeCollection* _tmp12_;
	GeeCollection* _tmp13_;
	GeeCollection* _tmp14_;
	GeeCollection* _tmp15_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_collection;
	_tmp1_ = read_only_collection_tests_get_ro_view (self, _tmp0_);
	another_ro_collection = _tmp1_;
	_tmp2_ = self->ro_collection;
	_tmp3_ = another_ro_collection;
	_vala_assert (_tmp2_ == _tmp3_, "ro_collection == another_ro_collection");
	_tmp4_ = self->ro_collection;
	_tmp5_ = g_object_new (G_TYPE_OBJECT, NULL);
	g_object_set_data_full ((GObject*) _tmp4_, "marker", _tmp5_, g_object_unref);
	_tmp6_ = another_ro_collection;
	_tmp7_ = g_object_get_data ((GObject*) _tmp6_, "marker");
	_vala_assert (((GObject*) _tmp7_) != NULL, "another_ro_collection.get_data<Object> (\"marker\") != null");
	_g_object_unref0 (another_ro_collection);
	another_ro_collection = NULL;
	_g_object_unref0 (self->ro_collection);
	self->ro_collection = NULL;
	_tmp8_ = self->test_collection;
	_tmp9_ = read_only_collection_tests_get_ro_view (self, _tmp8_);
	_g_object_unref0 (another_ro_collection);
	another_ro_collection = _tmp9_;
	_tmp10_ = another_ro_collection;
	_tmp11_ = g_object_get_data ((GObject*) _tmp10_, "marker");
	_vala_assert (((GObject*) _tmp11_) == NULL, "another_ro_collection.get_data<Object> (\"marker\") == null");
	_tmp12_ = another_ro_collection;
	_tmp13_ = another_ro_collection;
	_tmp14_ = read_only_collection_tests_get_ro_view (self, _tmp13_);
	_tmp15_ = _tmp14_;
	_vala_assert (_tmp12_ == _tmp15_, "another_ro_collection == get_ro_view (another_ro_collection)");
	_g_object_unref0 (_tmp15_);
	_g_object_unref0 (another_ro_collection);
}

void
read_only_collection_tests_test_immutable_iterator (ReadOnlyCollectionTests* self)
{
	GeeCollection* _tmp0_;
	GeeCollection* _tmp1_;
	GeeCollection* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	GeeCollection* _tmp5_;
	GeeCollection* _tmp6_;
	GeeIterator* iterator = NULL;
	GeeCollection* _tmp7_;
	GeeIterator* _tmp8_;
	gboolean one_found = FALSE;
	gboolean two_found = FALSE;
	GeeIterator* _tmp18_;
	GeeIterator* _tmp19_;
	GeeCollection* _tmp20_;
	GeeIterator* _tmp21_;
	GeeIterator* _tmp22_;
	GeeIterator* _tmp23_;
	GeeIterator* _tmp24_;
	gboolean _tmp25_;
	gboolean _tmp26_;
	GeeCollection* _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	GeeCollection* _tmp31_;
	GeeCollection* _tmp32_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_collection;
	_vala_assert (gee_collection_add (_tmp0_, "one"), "test_collection.add (\"one\")");
	_tmp1_ = self->test_collection;
	_vala_assert (gee_collection_add (_tmp1_, "two"), "test_collection.add (\"two\")");
	_tmp2_ = self->ro_collection;
	_tmp3_ = gee_collection_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	_vala_assert (_tmp4_ == 2, "ro_collection.size == 2");
	_tmp5_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp5_, "one"), "ro_collection.contains (\"one\")");
	_tmp6_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp6_, "two"), "ro_collection.contains (\"two\")");
	_tmp7_ = self->ro_collection;
	_tmp8_ = gee_iterable_iterator ((GeeIterable*) _tmp7_);
	iterator = _tmp8_;
	one_found = FALSE;
	two_found = FALSE;
	while (TRUE) {
		GeeIterator* _tmp9_;
		GeeIterator* _tmp10_;
		gboolean _tmp11_;
		gboolean _tmp12_;
		GeeIterator* _tmp13_;
		gpointer _tmp14_;
		gchar* _tmp15_;
		GQuark _tmp17_ = 0U;
		static GQuark _tmp16_label0 = 0;
		static GQuark _tmp16_label1 = 0;
		_tmp9_ = iterator;
		if (!gee_iterator_next (_tmp9_)) {
			break;
		}
		_tmp10_ = iterator;
		_tmp11_ = gee_iterator_get_valid (_tmp10_);
		_tmp12_ = _tmp11_;
		_vala_assert (_tmp12_, "iterator.valid");
		_tmp13_ = iterator;
		_tmp14_ = gee_iterator_get (_tmp13_);
		_tmp15_ = (gchar*) _tmp14_;
		_tmp17_ = (NULL == _tmp15_) ? 0 : g_quark_from_string (_tmp15_);
		g_free (_tmp15_);
		if (_tmp17_ == ((0 != _tmp16_label0) ? _tmp16_label0 : (_tmp16_label0 = g_quark_from_static_string ("one")))) {
			switch (0) {
				default:
				{
					_vala_assert (!one_found, "! one_found");
					one_found = TRUE;
					break;
				}
			}
		} else if (_tmp17_ == ((0 != _tmp16_label1) ? _tmp16_label1 : (_tmp16_label1 = g_quark_from_static_string ("two")))) {
			switch (0) {
				default:
				{
					_vala_assert (!two_found, "! two_found");
					two_found = TRUE;
					break;
				}
			}
		} else {
			switch (0) {
				default:
				{
					g_assert_not_reached ();
				}
			}
		}
	}
	_vala_assert (one_found, "one_found");
	_vala_assert (two_found, "two_found");
	_tmp18_ = iterator;
	_vala_assert (!gee_iterator_has_next (_tmp18_), "! iterator.has_next ()");
	_tmp19_ = iterator;
	_vala_assert (!gee_iterator_next (_tmp19_), "! iterator.next ()");
	_tmp20_ = self->ro_collection;
	_tmp21_ = gee_iterable_iterator ((GeeIterable*) _tmp20_);
	_g_object_unref0 (iterator);
	iterator = _tmp21_;
	_tmp22_ = iterator;
	_vala_assert (gee_iterator_has_next (_tmp22_), "iterator.has_next ()");
	_tmp23_ = iterator;
	_vala_assert (gee_iterator_next (_tmp23_), "iterator.next ()");
	_tmp24_ = iterator;
	_tmp25_ = gee_iterator_get_read_only (_tmp24_);
	_tmp26_ = _tmp25_;
	_vala_assert (_tmp26_, "iterator.read_only");
	if (g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR)) {
		GeeIterator* _tmp27_;
		_tmp27_ = iterator;
		gee_iterator_remove (_tmp27_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp28_ = self->ro_collection;
	_tmp29_ = gee_collection_get_size (_tmp28_);
	_tmp30_ = _tmp29_;
	_vala_assert (_tmp30_ == 2, "ro_collection.size == 2");
	_tmp31_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp31_, "one"), "ro_collection.contains (\"one\")");
	_tmp32_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp32_, "two"), "ro_collection.contains (\"two\")");
	_g_object_unref0 (iterator);
}

void
read_only_collection_tests_test_immutable (ReadOnlyCollectionTests* self)
{
	GeeCollection* _tmp0_;
	GeeCollection* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	GeeCollection* _tmp4_;
	GeeCollection* dummy = NULL;
	GeeArrayList* _tmp5_;
	GeeCollection* _tmp6_;
	GeeCollection* _tmp7_;
	GeeCollection* _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	GeeCollection* _tmp12_;
	GeeCollection* _tmp14_;
	gint _tmp15_;
	gint _tmp16_;
	GeeCollection* _tmp17_;
	GeeCollection* _tmp19_;
	gint _tmp20_;
	gint _tmp21_;
	GeeCollection* _tmp22_;
	GeeCollection* _tmp25_;
	gint _tmp26_;
	gint _tmp27_;
	GeeCollection* _tmp28_;
	GeeCollection* _tmp31_;
	gint _tmp32_;
	gint _tmp33_;
	GeeCollection* _tmp34_;
	GeeCollection* _tmp35_;
	GeeCollection* _tmp38_;
	gint _tmp39_;
	gint _tmp40_;
	GeeCollection* _tmp41_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_collection;
	_vala_assert (gee_collection_add (_tmp0_, "one"), "test_collection.add (\"one\")");
	_tmp1_ = self->ro_collection;
	_tmp2_ = gee_collection_get_size (_tmp1_);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_ == 1, "ro_collection.size == 1");
	_tmp4_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp4_, "one"), "ro_collection.contains (\"one\")");
	_tmp5_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
	dummy = (GeeCollection*) _tmp5_;
	_tmp6_ = dummy;
	_vala_assert (gee_collection_add (_tmp6_, "one"), "dummy.add (\"one\")");
	_tmp7_ = dummy;
	_vala_assert (gee_collection_add (_tmp7_, "two"), "dummy.add (\"two\")");
	if (g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR)) {
		GeeCollection* _tmp8_;
		_tmp8_ = self->ro_collection;
		_vala_assert (gee_collection_add (_tmp8_, "two"), "ro_collection.add (\"two\")");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp9_ = self->ro_collection;
	_tmp10_ = gee_collection_get_size (_tmp9_);
	_tmp11_ = _tmp10_;
	_vala_assert (_tmp11_ == 1, "ro_collection.size == 1");
	_tmp12_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp12_, "one"), "ro_collection.contains (\"one\")");
	if (g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR)) {
		GeeCollection* _tmp13_;
		_tmp13_ = self->ro_collection;
		gee_collection_clear (_tmp13_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp14_ = self->ro_collection;
	_tmp15_ = gee_collection_get_size (_tmp14_);
	_tmp16_ = _tmp15_;
	_vala_assert (_tmp16_ == 1, "ro_collection.size == 1");
	_tmp17_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp17_, "one"), "ro_collection.contains (\"one\")");
	if (g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR)) {
		GeeCollection* _tmp18_;
		_tmp18_ = self->ro_collection;
		_vala_assert (gee_collection_remove (_tmp18_, "one"), "ro_collection.remove (\"one\")");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp19_ = self->ro_collection;
	_tmp20_ = gee_collection_get_size (_tmp19_);
	_tmp21_ = _tmp20_;
	_vala_assert (_tmp21_ == 1, "ro_collection.size == 1");
	_tmp22_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp22_, "one"), "ro_collection.contains (\"one\")");
	if (g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR)) {
		GeeCollection* _tmp23_;
		GeeCollection* _tmp24_;
		_tmp23_ = self->ro_collection;
		_tmp24_ = dummy;
		_vala_assert (gee_collection_add_all (_tmp23_, _tmp24_), "ro_collection.add_all (dummy)");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp25_ = self->ro_collection;
	_tmp26_ = gee_collection_get_size (_tmp25_);
	_tmp27_ = _tmp26_;
	_vala_assert (_tmp27_ == 1, "ro_collection.size == 1");
	_tmp28_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp28_, "one"), "ro_collection.contains (\"one\")");
	if (g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR)) {
		GeeCollection* _tmp29_;
		GeeCollection* _tmp30_;
		_tmp29_ = self->ro_collection;
		_tmp30_ = dummy;
		_vala_assert (gee_collection_remove_all (_tmp29_, _tmp30_), "ro_collection.remove_all (dummy)");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp31_ = self->ro_collection;
	_tmp32_ = gee_collection_get_size (_tmp31_);
	_tmp33_ = _tmp32_;
	_vala_assert (_tmp33_ == 1, "ro_collection.size == 1");
	_tmp34_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp34_, "one"), "ro_collection.contains (\"one\")");
	_tmp35_ = dummy;
	_vala_assert (gee_collection_remove (_tmp35_, "one"), "dummy.remove (\"one\")");
	if (g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR)) {
		GeeCollection* _tmp36_;
		GeeCollection* _tmp37_;
		_tmp36_ = self->ro_collection;
		_tmp37_ = dummy;
		_vala_assert (gee_collection_retain_all (_tmp36_, _tmp37_), "ro_collection.retain_all (dummy)");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp38_ = self->ro_collection;
	_tmp39_ = gee_collection_get_size (_tmp38_);
	_tmp40_ = _tmp39_;
	_vala_assert (_tmp40_ == 1, "ro_collection.size == 1");
	_tmp41_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp41_, "one"), "ro_collection.contains (\"one\")");
	_g_object_unref0 (dummy);
}

void
read_only_collection_tests_test_accurate_view (ReadOnlyCollectionTests* self)
{
	GeeCollection* dummy = NULL;
	GeeArrayList* _tmp0_;
	GeeCollection* _tmp1_;
	GType _tmp2_;
	GType _tmp3_;
	GeeCollection* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	GeeCollection* _tmp7_;
	gboolean _tmp8_;
	gboolean _tmp9_;
	GeeCollection* _tmp10_;
	GeeCollection* _tmp11_;
	GeeCollection* _tmp12_;
	gint _tmp13_;
	gint _tmp14_;
	GeeCollection* _tmp15_;
	gboolean _tmp16_;
	gboolean _tmp17_;
	GeeCollection* _tmp18_;
	GeeCollection* _tmp19_;
	GeeCollection* _tmp20_;
	gint _tmp21_;
	gint _tmp22_;
	GeeCollection* _tmp23_;
	gboolean _tmp24_;
	gboolean _tmp25_;
	GeeCollection* _tmp26_;
	GeeCollection* _tmp27_;
	GeeCollection* _tmp28_;
	GeeCollection* _tmp29_;
	GeeCollection* _tmp30_;
	gint _tmp31_;
	gint _tmp32_;
	GeeCollection* _tmp33_;
	gboolean _tmp34_;
	gboolean _tmp35_;
	GeeCollection* _tmp36_;
	GeeCollection* _tmp37_;
	GeeCollection* _tmp38_;
	GeeCollection* _tmp39_;
	GeeCollection* _tmp40_;
	gint _tmp41_;
	gint _tmp42_;
	GeeCollection* _tmp43_;
	gboolean _tmp44_;
	gboolean _tmp45_;
	GeeCollection* _tmp46_;
	GeeCollection* _tmp47_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
	dummy = (GeeCollection*) _tmp0_;
	_vala_assert (gee_collection_add (dummy, "one"), "dummy.add (\"one\")");
	_vala_assert (gee_collection_add (dummy, "two"), "dummy.add (\"two\")");
	_tmp1_ = self->ro_collection;
	_tmp2_ = gee_traversable_get_element_type ((GeeTraversable*) _tmp1_);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_ == G_TYPE_STRING, "ro_collection.element_type == typeof (string)");
	_tmp4_ = self->ro_collection;
	_tmp5_ = gee_collection_get_size (_tmp4_);
	_tmp6_ = _tmp5_;
	_vala_assert (_tmp6_ == 0, "ro_collection.size == 0");
	_tmp7_ = self->ro_collection;
	_tmp8_ = gee_collection_get_is_empty (_tmp7_);
	_tmp9_ = _tmp8_;
	_vala_assert (_tmp9_, "ro_collection.is_empty");
	_tmp10_ = self->ro_collection;
	_vala_assert (!gee_collection_contains (_tmp10_, "one"), "! ro_collection.contains (\"one\")");
	_tmp11_ = self->test_collection;
	_vala_assert (gee_collection_add (_tmp11_, "one"), "test_collection.add (\"one\")");
	_tmp12_ = self->ro_collection;
	_tmp13_ = gee_collection_get_size (_tmp12_);
	_tmp14_ = _tmp13_;
	_vala_assert (_tmp14_ == 1, "ro_collection.size == 1");
	_tmp15_ = self->ro_collection;
	_tmp16_ = gee_collection_get_is_empty (_tmp15_);
	_tmp17_ = _tmp16_;
	_vala_assert (!_tmp17_, "! ro_collection.is_empty");
	_tmp18_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp18_, "one"), "ro_collection.contains (\"one\")");
	_tmp19_ = self->test_collection;
	_vala_assert (gee_collection_add (_tmp19_, "two"), "test_collection.add (\"two\")");
	_tmp20_ = self->ro_collection;
	_tmp21_ = gee_collection_get_size (_tmp20_);
	_tmp22_ = _tmp21_;
	_vala_assert (_tmp22_ == 2, "ro_collection.size == 2");
	_tmp23_ = self->ro_collection;
	_tmp24_ = gee_collection_get_is_empty (_tmp23_);
	_tmp25_ = _tmp24_;
	_vala_assert (!_tmp25_, "! ro_collection.is_empty");
	_tmp26_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp26_, "one"), "ro_collection.contains (\"one\")");
	_tmp27_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp27_, "two"), "ro_collection.contains (\"two\")");
	_tmp28_ = self->ro_collection;
	_vala_assert (gee_collection_contains_all (_tmp28_, dummy), "ro_collection.contains_all (dummy)");
	_tmp29_ = self->test_collection;
	_vala_assert (gee_collection_remove (_tmp29_, "one"), "test_collection.remove (\"one\")");
	_tmp30_ = self->ro_collection;
	_tmp31_ = gee_collection_get_size (_tmp30_);
	_tmp32_ = _tmp31_;
	_vala_assert (_tmp32_ == 1, "ro_collection.size == 1");
	_tmp33_ = self->ro_collection;
	_tmp34_ = gee_collection_get_is_empty (_tmp33_);
	_tmp35_ = _tmp34_;
	_vala_assert (!_tmp35_, "! ro_collection.is_empty");
	_tmp36_ = self->ro_collection;
	_vala_assert (!gee_collection_contains (_tmp36_, "one"), "! ro_collection.contains (\"one\")");
	_tmp37_ = self->ro_collection;
	_vala_assert (gee_collection_contains (_tmp37_, "two"), "ro_collection.contains (\"two\")");
	_tmp38_ = self->ro_collection;
	_vala_assert (!gee_collection_contains_all (_tmp38_, dummy), "! ro_collection.contains_all (dummy)");
	_tmp39_ = self->test_collection;
	gee_collection_clear (_tmp39_);
	_tmp40_ = self->ro_collection;
	_tmp41_ = gee_collection_get_size (_tmp40_);
	_tmp42_ = _tmp41_;
	_vala_assert (_tmp42_ == 0, "ro_collection.size == 0");
	_tmp43_ = self->ro_collection;
	_tmp44_ = gee_collection_get_is_empty (_tmp43_);
	_tmp45_ = _tmp44_;
	_vala_assert (_tmp45_, "ro_collection.is_empty");
	_tmp46_ = self->ro_collection;
	_vala_assert (!gee_collection_contains (_tmp46_, "one"), "! ro_collection.contains (\"one\")");
	_tmp47_ = self->ro_collection;
	_vala_assert (!gee_collection_contains (_tmp47_, "two"), "! ro_collection.contains (\"two\")");
	_g_object_unref0 (dummy);
}

static void
read_only_collection_tests_class_init (ReadOnlyCollectionTestsClass * klass,
                                       gpointer klass_data)
{
	read_only_collection_tests_parent_class = g_type_class_peek_parent (klass);
	((GeeTestCaseClass *) klass)->set_up = (void (*) (GeeTestCase*)) read_only_collection_tests_real_set_up;
	((GeeTestCaseClass *) klass)->tear_down = (void (*) (GeeTestCase*)) read_only_collection_tests_real_tear_down;
	((ReadOnlyCollectionTestsClass *) klass)->get_ro_view = (GeeCollection* (*) (ReadOnlyCollectionTests*, GeeCollection*)) read_only_collection_tests_real_get_ro_view;
	G_OBJECT_CLASS (klass)->finalize = read_only_collection_tests_finalize;
}

static void
read_only_collection_tests_instance_init (ReadOnlyCollectionTests * self,
                                          gpointer klass)
{
}

static void
read_only_collection_tests_finalize (GObject * obj)
{
	ReadOnlyCollectionTests * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTests);
	_g_object_unref0 (self->test_collection);
	_g_object_unref0 (self->ro_collection);
	G_OBJECT_CLASS (read_only_collection_tests_parent_class)->finalize (obj);
}

static GType
read_only_collection_tests_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (ReadOnlyCollectionTestsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) read_only_collection_tests_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ReadOnlyCollectionTests), 0, (GInstanceInitFunc) read_only_collection_tests_instance_init, NULL };
	GType read_only_collection_tests_type_id;
	read_only_collection_tests_type_id = g_type_register_static (GEE_TYPE_TEST_CASE, "ReadOnlyCollectionTests", &g_define_type_info, 0);
	return read_only_collection_tests_type_id;
}

GType
read_only_collection_tests_get_type (void)
{
	static volatile gsize read_only_collection_tests_type_id__once = 0;
	if (g_once_init_enter (&read_only_collection_tests_type_id__once)) {
		GType read_only_collection_tests_type_id;
		read_only_collection_tests_type_id = read_only_collection_tests_get_type_once ();
		g_once_init_leave (&read_only_collection_tests_type_id__once, read_only_collection_tests_type_id);
	}
	return read_only_collection_tests_type_id__once;
}

