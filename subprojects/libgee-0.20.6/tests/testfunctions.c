/* testfunctions.c generated by valac 0.56.3, the Vala compiler
 * generated from testfunctions.vala, do not modify */

/* testfunctions.vala
 *
 * Copyright (C) 2010  Maciej Piechotka
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Maciej Piechotka <uzytkownik2@gmail.com>
 */

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <gee.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define GEE_TYPE_TEST_CASE (gee_test_case_get_type ())
#define GEE_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TEST_CASE, GeeTestCase))
#define GEE_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_TEST_CASE, GeeTestCaseClass))
#define GEE_IS_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TEST_CASE))
#define GEE_IS_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_TEST_CASE))
#define GEE_TEST_CASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_TEST_CASE, GeeTestCaseClass))

typedef struct _GeeTestCase GeeTestCase;
typedef struct _GeeTestCaseClass GeeTestCaseClass;
typedef struct _GeeTestCasePrivate GeeTestCasePrivate;

#define TYPE_FUNCTIONS_TESTS (functions_tests_get_type ())
#define FUNCTIONS_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTIONS_TESTS, FunctionsTests))
#define FUNCTIONS_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTIONS_TESTS, FunctionsTestsClass))
#define IS_FUNCTIONS_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTIONS_TESTS))
#define IS_FUNCTIONS_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTIONS_TESTS))
#define FUNCTIONS_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTIONS_TESTS, FunctionsTestsClass))

typedef struct _FunctionsTests FunctionsTests;
typedef struct _FunctionsTestsClass FunctionsTestsClass;
typedef struct _FunctionsTestsPrivate FunctionsTestsPrivate;
enum  {
	FUNCTIONS_TESTS_0_PROPERTY,
	FUNCTIONS_TESTS_NUM_PROPERTIES
};
static GParamSpec* functions_tests_properties[FUNCTIONS_TESTS_NUM_PROPERTIES];
typedef void (*GeeTestCaseTestMethod) (gpointer user_data);
#define _g_free0(var) (var = (g_free (var), NULL))

#define FUNCTIONS_TESTS_TYPE_MY_COMPARABLE (functions_tests_my_comparable_get_type ())
#define FUNCTIONS_TESTS_MY_COMPARABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparable))
#define FUNCTIONS_TESTS_MY_COMPARABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparableClass))
#define FUNCTIONS_TESTS_IS_MY_COMPARABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE))
#define FUNCTIONS_TESTS_IS_MY_COMPARABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE))
#define FUNCTIONS_TESTS_MY_COMPARABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparableClass))

typedef struct _FunctionsTestsMyComparable FunctionsTestsMyComparable;
typedef struct _FunctionsTestsMyComparableClass FunctionsTestsMyComparableClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FUNCTIONS_TESTS_TYPE_MY_HASHABLE (functions_tests_my_hashable_get_type ())
#define FUNCTIONS_TESTS_MY_HASHABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashable))
#define FUNCTIONS_TESTS_MY_HASHABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashableClass))
#define FUNCTIONS_TESTS_IS_MY_HASHABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE))
#define FUNCTIONS_TESTS_IS_MY_HASHABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FUNCTIONS_TESTS_TYPE_MY_HASHABLE))
#define FUNCTIONS_TESTS_MY_HASHABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashableClass))

typedef struct _FunctionsTestsMyHashable FunctionsTestsMyHashable;
typedef struct _FunctionsTestsMyHashableClass FunctionsTestsMyHashableClass;
typedef struct _Block8Data Block8Data;
typedef struct _Block9Data Block9Data;
typedef struct _Block10Data Block10Data;
typedef struct _Block11Data Block11Data;
typedef struct _FunctionsTestsMyComparablePrivate FunctionsTestsMyComparablePrivate;
enum  {
	FUNCTIONS_TESTS_MY_COMPARABLE_0_PROPERTY,
	FUNCTIONS_TESTS_MY_COMPARABLE_NUM_PROPERTIES
};
static GParamSpec* functions_tests_my_comparable_properties[FUNCTIONS_TESTS_MY_COMPARABLE_NUM_PROPERTIES];
typedef struct _FunctionsTestsMyHashablePrivate FunctionsTestsMyHashablePrivate;
enum  {
	FUNCTIONS_TESTS_MY_HASHABLE_0_PROPERTY,
	FUNCTIONS_TESTS_MY_HASHABLE_NUM_PROPERTIES
};
static GParamSpec* functions_tests_my_hashable_properties[FUNCTIONS_TESTS_MY_HASHABLE_NUM_PROPERTIES];
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeTestCase {
	GObject parent_instance;
	GeeTestCasePrivate * priv;
};

struct _GeeTestCaseClass {
	GObjectClass parent_class;
	void (*set_up) (GeeTestCase* self);
	void (*tear_down) (GeeTestCase* self);
};

struct _FunctionsTests {
	GeeTestCase parent_instance;
	FunctionsTestsPrivate * priv;
};

struct _FunctionsTestsClass {
	GeeTestCaseClass parent_class;
};

struct _Block8Data {
	int _ref_count_;
	FunctionsTests* self;
	gint i;
	gint j;
};

struct _Block9Data {
	int _ref_count_;
	Block8Data * _data8_;
	gint k;
};

struct _Block10Data {
	int _ref_count_;
	FunctionsTests* self;
	gint i;
};

struct _Block11Data {
	int _ref_count_;
	Block10Data * _data10_;
	gint j;
	gint start;
};

struct _FunctionsTestsMyComparable {
	GObject parent_instance;
	FunctionsTestsMyComparablePrivate * priv;
};

struct _FunctionsTestsMyComparableClass {
	GObjectClass parent_class;
};

struct _FunctionsTestsMyComparablePrivate {
	gint i;
};

struct _FunctionsTestsMyHashable {
	GObject parent_instance;
	FunctionsTestsMyHashablePrivate * priv;
};

struct _FunctionsTestsMyHashableClass {
	GObjectClass parent_class;
};

struct _FunctionsTestsMyHashablePrivate {
	gint i;
};

static gpointer functions_tests_parent_class = NULL;
static gint FunctionsTestsMyComparable_private_offset;
static gpointer functions_tests_my_comparable_parent_class = NULL;
static GeeComparableIface * functions_tests_my_comparable_gee_comparable_parent_iface = NULL;
static gint FunctionsTestsMyHashable_private_offset;
static gpointer functions_tests_my_hashable_parent_class = NULL;
static GeeComparableIface * functions_tests_my_hashable_gee_comparable_parent_iface = NULL;
static GeeHashableIface * functions_tests_my_hashable_gee_hashable_parent_iface = NULL;

VALA_EXTERN GType gee_test_case_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GeeTestCase, g_object_unref)
VALA_EXTERN GType functions_tests_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FunctionsTests, g_object_unref)
VALA_EXTERN FunctionsTests* functions_tests_new (void);
VALA_EXTERN FunctionsTests* functions_tests_construct (GType object_type);
VALA_EXTERN GeeTestCase* gee_test_case_construct (GType object_type,
                                      const gchar* name);
VALA_EXTERN void gee_test_case_add_test (GeeTestCase* self,
                             const gchar* name,
                             GeeTestCaseTestMethod test,
                             gpointer test_target,
                             GDestroyNotify test_target_destroy_notify);
VALA_EXTERN void functions_tests_test_string_func (FunctionsTests* self);
static void _functions_tests_test_string_func_gee_test_case_test_method (gpointer self);
VALA_EXTERN void functions_tests_test_int_func (FunctionsTests* self);
static void _functions_tests_test_int_func_gee_test_case_test_method (gpointer self);
VALA_EXTERN void functions_tests_test_compare_func (FunctionsTests* self);
static void _functions_tests_test_compare_func_gee_test_case_test_method (gpointer self);
VALA_EXTERN void functions_tests_test_hash_func (FunctionsTests* self);
static void _functions_tests_test_hash_func_gee_test_case_test_method (gpointer self);
VALA_EXTERN void functions_tests_test_unfold (FunctionsTests* self);
static void _functions_tests_test_unfold_gee_test_case_test_method (gpointer self);
VALA_EXTERN void functions_tests_test_concat (FunctionsTests* self);
static void _functions_tests_test_concat_gee_test_case_test_method (gpointer self);
static GType functions_tests_my_comparable_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FunctionsTestsMyComparable, g_object_unref)
static FunctionsTestsMyComparable* functions_tests_my_comparable_new (gint i);
static FunctionsTestsMyComparable* functions_tests_my_comparable_construct (GType object_type,
                                                                     gint i);
static GType functions_tests_my_hashable_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FunctionsTestsMyHashable, g_object_unref)
static FunctionsTestsMyHashable* functions_tests_my_hashable_new (gint i);
static FunctionsTestsMyHashable* functions_tests_my_hashable_construct (GType object_type,
                                                                 gint i);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static GeeLazy* __lambda54_ (Block8Data* _data8_);
static Block9Data* block9_data_ref (Block9Data* _data9_);
static void block9_data_unref (void * _userdata_);
static gint __lambda55_ (Block9Data* _data9_);
static gpointer ___lambda55__gee_lazy_func (gpointer self);
static GeeLazy* ___lambda54__gee_unfold_func (gpointer self);
static Block10Data* block10_data_ref (Block10Data* _data10_);
static void block10_data_unref (void * _userdata_);
static GeeLazy* __lambda56_ (Block10Data* _data10_);
static Block11Data* block11_data_ref (Block11Data* _data11_);
static void block11_data_unref (void * _userdata_);
static GeeLazy* __lambda57_ (Block11Data* _data11_);
static GeeLazy* ___lambda57__gee_unfold_func (gpointer self);
static GeeLazy* ___lambda56__gee_unfold_func (gpointer self);
static gint functions_tests_my_comparable_real_compare_to (GeeComparable* base,
                                                    FunctionsTestsMyComparable* cmp);
static void functions_tests_my_comparable_finalize (GObject * obj);
static GType functions_tests_my_comparable_get_type_once (void);
static gint functions_tests_my_hashable_real_compare_to (GeeComparable* base,
                                                  FunctionsTestsMyHashable* cmp);
static guint functions_tests_my_hashable_real_hash (GeeHashable* base);
static gboolean functions_tests_my_hashable_real_equal_to (GeeHashable* base,
                                                    FunctionsTestsMyHashable* hash);
static void functions_tests_my_hashable_finalize (GObject * obj);
static GType functions_tests_my_hashable_get_type_once (void);
static GType functions_tests_get_type_once (void);

static void
_functions_tests_test_string_func_gee_test_case_test_method (gpointer self)
{
	functions_tests_test_string_func ((FunctionsTests*) self);
}

static void
_functions_tests_test_int_func_gee_test_case_test_method (gpointer self)
{
	functions_tests_test_int_func ((FunctionsTests*) self);
}

static void
_functions_tests_test_compare_func_gee_test_case_test_method (gpointer self)
{
	functions_tests_test_compare_func ((FunctionsTests*) self);
}

static void
_functions_tests_test_hash_func_gee_test_case_test_method (gpointer self)
{
	functions_tests_test_hash_func ((FunctionsTests*) self);
}

static void
_functions_tests_test_unfold_gee_test_case_test_method (gpointer self)
{
	functions_tests_test_unfold ((FunctionsTests*) self);
}

static void
_functions_tests_test_concat_gee_test_case_test_method (gpointer self)
{
	functions_tests_test_concat ((FunctionsTests*) self);
}

FunctionsTests*
functions_tests_construct (GType object_type)
{
	FunctionsTests * self = NULL;
	self = (FunctionsTests*) gee_test_case_construct (object_type, "Functions");
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing strings", _functions_tests_test_string_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing int", _functions_tests_test_int_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing instances of Comparable", _functions_tests_test_compare_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing instances of Hashable", _functions_tests_test_hash_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Iterator] unfold", _functions_tests_test_unfold_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Iterator] concat", _functions_tests_test_concat_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	return self;
}

FunctionsTests*
functions_tests_new (void)
{
	return functions_tests_construct (TYPE_FUNCTIONS_TESTS);
}

void
functions_tests_test_string_func (FunctionsTests* self)
{
	gchar* one = NULL;
	gchar* _tmp0_;
	gchar* two = NULL;
	gchar* _tmp1_;
	gchar* two_copy = NULL;
	gchar* _tmp2_;
	GeeEqualDataFunc eq = NULL;
	gpointer _tmp3_ = NULL;
	GDestroyNotify _tmp4_ = NULL;
	GeeEqualDataFunc _tmp5_;
	gpointer eq_target;
	GDestroyNotify eq_target_destroy_notify;
	GCompareDataFunc cmp = NULL;
	gpointer _tmp6_ = NULL;
	GDestroyNotify _tmp7_ = NULL;
	GCompareDataFunc _tmp8_;
	gpointer cmp_target;
	GDestroyNotify cmp_target_destroy_notify;
	GeeHashDataFunc hash = NULL;
	gpointer _tmp9_ = NULL;
	GDestroyNotify _tmp10_ = NULL;
	GeeHashDataFunc _tmp11_;
	gpointer hash_target;
	GDestroyNotify hash_target_destroy_notify;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("one");
	one = _tmp0_;
	_tmp1_ = g_strdup ("two");
	two = _tmp1_;
	_tmp2_ = g_strdup (two);
	two_copy = _tmp2_;
	_tmp5_ = gee_functions_get_equal_func_for (G_TYPE_STRING, &_tmp3_, &_tmp4_);
	eq = _tmp5_;
	eq_target = _tmp3_;
	eq_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_compare_func_for (G_TYPE_STRING, &_tmp6_, &_tmp7_);
	cmp = _tmp8_;
	cmp_target = _tmp6_;
	cmp_target_destroy_notify = _tmp7_;
	_tmp11_ = gee_functions_get_hash_func_for (G_TYPE_STRING, &_tmp9_, &_tmp10_);
	hash = _tmp11_;
	hash_target = _tmp9_;
	hash_target_destroy_notify = _tmp10_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_vala_assert (eq (two, two, eq_target), "eq (two, two)");
	_vala_assert (cmp (two, two, cmp_target) == 0, "cmp (two, two) == 0");
	_vala_assert (hash (two, hash_target) == hash (two, hash_target), "hash (two) == hash (two)");
	_vala_assert (eq (two, two_copy, eq_target), "eq (two, two_copy)");
	_vala_assert (cmp (two, two_copy, cmp_target) == 0, "cmp (two, two_copy) == 0");
	_vala_assert (hash (two, hash_target) == hash (two_copy, hash_target), "hash (two) == hash (two_copy)");
	_vala_assert (!eq (one, two, eq_target), "!eq (one, two)");
	_vala_assert (cmp (one, two, cmp_target) < 0, "cmp (one, two) < 0");
	_vala_assert (!eq (two, one, eq_target), "!eq (two, one)");
	_vala_assert (cmp (two, one, cmp_target) > 0, "cmp (two, one) > 0");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_free0 (two_copy);
	_g_free0 (two);
	_g_free0 (one);
}

void
functions_tests_test_int_func (FunctionsTests* self)
{
	gint one = 0;
	gint two = 0;
	GeeEqualDataFunc eq = NULL;
	gpointer _tmp0_ = NULL;
	GDestroyNotify _tmp1_ = NULL;
	GeeEqualDataFunc _tmp2_;
	gpointer eq_target;
	GDestroyNotify eq_target_destroy_notify;
	GCompareDataFunc cmp = NULL;
	gpointer _tmp3_ = NULL;
	GDestroyNotify _tmp4_ = NULL;
	GCompareDataFunc _tmp5_;
	gpointer cmp_target;
	GDestroyNotify cmp_target_destroy_notify;
	GeeHashDataFunc hash = NULL;
	gpointer _tmp6_ = NULL;
	GDestroyNotify _tmp7_ = NULL;
	GeeHashDataFunc _tmp8_;
	gpointer hash_target;
	GDestroyNotify hash_target_destroy_notify;
	g_return_if_fail (self != NULL);
	one = 1;
	two = 2;
	_tmp2_ = gee_functions_get_equal_func_for (G_TYPE_INT, &_tmp0_, &_tmp1_);
	eq = _tmp2_;
	eq_target = _tmp0_;
	eq_target_destroy_notify = _tmp1_;
	_tmp5_ = gee_functions_get_compare_func_for (G_TYPE_INT, &_tmp3_, &_tmp4_);
	cmp = _tmp5_;
	cmp_target = _tmp3_;
	cmp_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_hash_func_for (G_TYPE_INT, &_tmp6_, &_tmp7_);
	hash = _tmp8_;
	hash_target = _tmp6_;
	hash_target_destroy_notify = _tmp7_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_vala_assert (eq ((gpointer) ((gintptr) two), (gpointer) ((gintptr) two), eq_target), "eq (two, two)");
	_vala_assert (cmp ((gpointer) ((gintptr) two), (gpointer) ((gintptr) two), cmp_target) == 0, "cmp (two, two) == 0");
	_vala_assert (hash ((gpointer) ((gintptr) two), hash_target) == hash ((gpointer) ((gintptr) two), hash_target), "hash (two) == hash (two)");
	_vala_assert (!eq ((gpointer) ((gintptr) one), (gpointer) ((gintptr) two), eq_target), "!eq (one, two)");
	_vala_assert (cmp ((gpointer) ((gintptr) one), (gpointer) ((gintptr) two), cmp_target) < 0, "cmp (one, two) < 0");
	_vala_assert (!eq ((gpointer) ((gintptr) two), (gpointer) ((gintptr) one), eq_target), "!eq (two, one)");
	_vala_assert (cmp ((gpointer) ((gintptr) two), (gpointer) ((gintptr) one), cmp_target) > 0, "cmp (two, one) > 0");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
}

void
functions_tests_test_compare_func (FunctionsTests* self)
{
	FunctionsTestsMyComparable* two = NULL;
	FunctionsTestsMyComparable* _tmp0_;
	FunctionsTestsMyComparable* one = NULL;
	FunctionsTestsMyComparable* _tmp1_;
	FunctionsTestsMyComparable* two_copy = NULL;
	FunctionsTestsMyComparable* _tmp2_;
	GeeEqualDataFunc eq = NULL;
	gpointer _tmp3_ = NULL;
	GDestroyNotify _tmp4_ = NULL;
	GeeEqualDataFunc _tmp5_;
	gpointer eq_target;
	GDestroyNotify eq_target_destroy_notify;
	GCompareDataFunc cmp = NULL;
	gpointer _tmp6_ = NULL;
	GDestroyNotify _tmp7_ = NULL;
	GCompareDataFunc _tmp8_;
	gpointer cmp_target;
	GDestroyNotify cmp_target_destroy_notify;
	g_return_if_fail (self != NULL);
	_tmp0_ = functions_tests_my_comparable_new (2);
	two = _tmp0_;
	_tmp1_ = functions_tests_my_comparable_new (1);
	one = _tmp1_;
	_tmp2_ = functions_tests_my_comparable_new (2);
	two_copy = _tmp2_;
	_tmp5_ = gee_functions_get_equal_func_for (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, &_tmp3_, &_tmp4_);
	eq = _tmp5_;
	eq_target = _tmp3_;
	eq_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_compare_func_for (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, &_tmp6_, &_tmp7_);
	cmp = _tmp8_;
	cmp_target = _tmp6_;
	cmp_target_destroy_notify = _tmp7_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (eq (two, two, eq_target), "eq (two, two)");
	_vala_assert (cmp (two, two, cmp_target) == 0, "cmp (two, two) == 0");
	_vala_assert (eq (two, two_copy, eq_target), "eq (two, two_copy)");
	_vala_assert (cmp (two, two_copy, cmp_target) == 0, "cmp (two, two_copy) == 0");
	_vala_assert (!eq (one, two, eq_target), "!eq (one, two)");
	_vala_assert (cmp (one, two, cmp_target) < 0, "cmp (one, two) < 0");
	_vala_assert (!eq (two, one, eq_target), "!eq (two, one)");
	_vala_assert (cmp (two, one, cmp_target) > 0, "cmp (two, one) > 0");
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_object_unref0 (two_copy);
	_g_object_unref0 (one);
	_g_object_unref0 (two);
}

void
functions_tests_test_hash_func (FunctionsTests* self)
{
	FunctionsTestsMyHashable* two = NULL;
	FunctionsTestsMyHashable* _tmp0_;
	FunctionsTestsMyHashable* one = NULL;
	FunctionsTestsMyHashable* _tmp1_;
	FunctionsTestsMyHashable* two_copy = NULL;
	FunctionsTestsMyHashable* _tmp2_;
	FunctionsTestsMyHashable* minus_one = NULL;
	FunctionsTestsMyHashable* _tmp3_;
	FunctionsTestsMyHashable* minus_one2 = NULL;
	FunctionsTestsMyHashable* _tmp4_;
	GeeEqualDataFunc eq = NULL;
	gpointer _tmp5_ = NULL;
	GDestroyNotify _tmp6_ = NULL;
	GeeEqualDataFunc _tmp7_;
	gpointer eq_target;
	GDestroyNotify eq_target_destroy_notify;
	GCompareDataFunc cmp = NULL;
	gpointer _tmp8_ = NULL;
	GDestroyNotify _tmp9_ = NULL;
	GCompareDataFunc _tmp10_;
	gpointer cmp_target;
	GDestroyNotify cmp_target_destroy_notify;
	GeeHashDataFunc hash = NULL;
	gpointer _tmp11_ = NULL;
	GDestroyNotify _tmp12_ = NULL;
	GeeHashDataFunc _tmp13_;
	gpointer hash_target;
	GDestroyNotify hash_target_destroy_notify;
	g_return_if_fail (self != NULL);
	_tmp0_ = functions_tests_my_hashable_new (2);
	two = _tmp0_;
	_tmp1_ = functions_tests_my_hashable_new (1);
	one = _tmp1_;
	_tmp2_ = functions_tests_my_hashable_new (2);
	two_copy = _tmp2_;
	_tmp3_ = functions_tests_my_hashable_new (-1);
	minus_one = _tmp3_;
	_tmp4_ = functions_tests_my_hashable_new (-1);
	minus_one2 = _tmp4_;
	_tmp7_ = gee_functions_get_equal_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp5_, &_tmp6_);
	eq = _tmp7_;
	eq_target = _tmp5_;
	eq_target_destroy_notify = _tmp6_;
	_tmp10_ = gee_functions_get_compare_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp8_, &_tmp9_);
	cmp = _tmp10_;
	cmp_target = _tmp8_;
	cmp_target_destroy_notify = _tmp9_;
	_tmp13_ = gee_functions_get_hash_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp11_, &_tmp12_);
	hash = _tmp13_;
	hash_target = _tmp11_;
	hash_target_destroy_notify = _tmp12_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_vala_assert (eq (two, two, eq_target), "eq (two, two)");
	_vala_assert (cmp (two, two, cmp_target) == 0, "cmp (two, two) == 0");
	_vala_assert (hash (two, hash_target) == hash (two, hash_target), "hash (two) == hash (two)");
	_vala_assert (eq (two, two_copy, eq_target), "eq (two, two_copy)");
	_vala_assert (cmp (two, two_copy, cmp_target) == 0, "cmp (two, two_copy) == 0");
	_vala_assert (hash (two, hash_target) == hash (two_copy, hash_target), "hash (two) == hash (two_copy)");
	_vala_assert (!eq (one, two, eq_target), "!eq (one, two)");
	_vala_assert (cmp (one, two, cmp_target) < 0, "cmp (one, two) < 0");
	_vala_assert (!eq (two, one, eq_target), "!eq (two, one)");
	_vala_assert (cmp (two, one, cmp_target) > 0, "cmp (two, one) > 0");
	_vala_assert (hash (one, hash_target) == ((guint) 1), "hash (one) == 1");
	_vala_assert (!eq (minus_one, minus_one2, eq_target), "!eq (minus_one, minus_one2)");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_object_unref0 (minus_one2);
	_g_object_unref0 (minus_one);
	_g_object_unref0 (two_copy);
	_g_object_unref0 (one);
	_g_object_unref0 (two);
}

static Block8Data*
block8_data_ref (Block8Data* _data8_)
{
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}

static void
block8_data_unref (void * _userdata_)
{
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		FunctionsTests* self;
		self = _data8_->self;
		_g_object_unref0 (self);
		g_slice_free (Block8Data, _data8_);
	}
}

static Block9Data*
block9_data_ref (Block9Data* _data9_)
{
	g_atomic_int_inc (&_data9_->_ref_count_);
	return _data9_;
}

static void
block9_data_unref (void * _userdata_)
{
	Block9Data* _data9_;
	_data9_ = (Block9Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data9_->_ref_count_)) {
		FunctionsTests* self;
		self = _data9_->_data8_->self;
		block8_data_unref (_data9_->_data8_);
		_data9_->_data8_ = NULL;
		g_slice_free (Block9Data, _data9_);
	}
}

static gint
__lambda55_ (Block9Data* _data9_)
{
	Block8Data* _data8_;
	FunctionsTests* self;
	gint result;
	_data8_ = _data9_->_data8_;
	self = _data8_->self;
	_vala_assert ((_data9_->k + 1) == _data8_->i, "k + 1 == i");
	_data8_->j = _data9_->k;
	result = _data9_->k;
	return result;
}

static gpointer
___lambda55__gee_lazy_func (gpointer self)
{
	gpointer result;
	result = (gpointer) ((gintptr) __lambda55_ (self));
	return result;
}

static GeeLazy*
__lambda54_ (Block8Data* _data8_)
{
	FunctionsTests* self;
	Block9Data* _data9_;
	gint _tmp0_;
	GeeLazy* _tmp1_;
	GeeLazy* result;
	self = _data8_->self;
	_data9_ = g_slice_new0 (Block9Data);
	_data9_->_ref_count_ = 1;
	_data9_->_data8_ = block8_data_ref (_data8_);
	_vala_assert ((_data8_->j + 1) == _data8_->i, "j + 1 == i");
	if (_data8_->i == 10) {
		result = NULL;
		block9_data_unref (_data9_);
		_data9_ = NULL;
		return result;
	}
	_tmp0_ = _data8_->i;
	_data8_->i = _tmp0_ + 1;
	_data9_->k = _tmp0_;
	_tmp1_ = gee_lazy_new (G_TYPE_INT, NULL, NULL, ___lambda55__gee_lazy_func, block9_data_ref (_data9_), block9_data_unref);
	result = _tmp1_;
	block9_data_unref (_data9_);
	_data9_ = NULL;
	return result;
}

static GeeLazy*
___lambda54__gee_unfold_func (gpointer self)
{
	GeeLazy* result;
	result = __lambda54_ (self);
	return result;
}

void
functions_tests_test_unfold (FunctionsTests* self)
{
	Block8Data* _data8_;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp0_;
	gint k = 0;
	g_return_if_fail (self != NULL);
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	_data8_->self = g_object_ref (self);
	_data8_->i = 0;
	_data8_->j = -1;
	_tmp0_ = gee_iterator_unfold (G_TYPE_INT, NULL, NULL, ___lambda54__gee_unfold_func, block8_data_ref (_data8_), block8_data_unref, NULL);
	iter = _tmp0_;
	k = 0;
	while (TRUE) {
		GeeIterator* _tmp1_;
		GeeIterator* _tmp2_;
		gpointer _tmp3_;
		GeeIterator* _tmp4_;
		gpointer _tmp5_;
		gint _tmp6_;
		_tmp1_ = iter;
		if (!gee_iterator_next (_tmp1_)) {
			break;
		}
		_tmp2_ = iter;
		_tmp3_ = gee_iterator_get (_tmp2_);
		_vala_assert (((gint) ((gintptr) _tmp3_)) == k, "iter.get () == k");
		_tmp4_ = iter;
		_tmp5_ = gee_iterator_get (_tmp4_);
		_vala_assert (((gint) ((gintptr) _tmp5_)) == k, "iter.get () == k");
		_tmp6_ = k;
		k = _tmp6_ + 1;
	}
	_vala_assert (k == 10, "k == 10");
	_g_object_unref0 (iter);
	block8_data_unref (_data8_);
	_data8_ = NULL;
}

static Block10Data*
block10_data_ref (Block10Data* _data10_)
{
	g_atomic_int_inc (&_data10_->_ref_count_);
	return _data10_;
}

static void
block10_data_unref (void * _userdata_)
{
	Block10Data* _data10_;
	_data10_ = (Block10Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data10_->_ref_count_)) {
		FunctionsTests* self;
		self = _data10_->self;
		_g_object_unref0 (self);
		g_slice_free (Block10Data, _data10_);
	}
}

static Block11Data*
block11_data_ref (Block11Data* _data11_)
{
	g_atomic_int_inc (&_data11_->_ref_count_);
	return _data11_;
}

static void
block11_data_unref (void * _userdata_)
{
	Block11Data* _data11_;
	_data11_ = (Block11Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data11_->_ref_count_)) {
		FunctionsTests* self;
		self = _data11_->_data10_->self;
		block10_data_unref (_data11_->_data10_);
		_data11_->_data10_ = NULL;
		g_slice_free (Block11Data, _data11_);
	}
}

static GeeLazy*
__lambda57_ (Block11Data* _data11_)
{
	Block10Data* _data10_;
	FunctionsTests* self;
	gint _tmp0_;
	GeeLazy* _tmp1_;
	GeeLazy* result;
	_data10_ = _data11_->_data10_;
	self = _data10_->self;
	if (_data11_->j == (_data11_->start + 3)) {
		result = NULL;
		return result;
	}
	_tmp0_ = _data11_->j;
	_data11_->j = _tmp0_ + 1;
	_tmp1_ = gee_lazy_new_from_value (G_TYPE_INT, NULL, NULL, (gpointer) ((gintptr) _tmp0_));
	result = _tmp1_;
	return result;
}

static GeeLazy*
___lambda57__gee_unfold_func (gpointer self)
{
	GeeLazy* result;
	result = __lambda57_ (self);
	return result;
}

static GeeLazy*
__lambda56_ (Block10Data* _data10_)
{
	FunctionsTests* self;
	Block11Data* _data11_;
	gint _tmp0_;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp1_;
	GeeIterator* _tmp2_;
	GeeLazy* _tmp3_;
	GeeLazy* result;
	self = _data10_->self;
	_data11_ = g_slice_new0 (Block11Data);
	_data11_->_ref_count_ = 1;
	_data11_->_data10_ = block10_data_ref (_data10_);
	if (_data10_->i >= 3) {
		result = NULL;
		block11_data_unref (_data11_);
		_data11_ = NULL;
		return result;
	}
	_tmp0_ = _data10_->i;
	_data10_->i = _tmp0_ + 1;
	_data11_->j = _tmp0_ * 3;
	_data11_->start = _data11_->j;
	_tmp1_ = gee_iterator_unfold (G_TYPE_INT, NULL, NULL, ___lambda57__gee_unfold_func, block11_data_ref (_data11_), block11_data_unref, NULL);
	iter = _tmp1_;
	_tmp2_ = iter;
	_tmp3_ = gee_lazy_new_from_value (GEE_TYPE_ITERATOR, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, _tmp2_);
	result = _tmp3_;
	_g_object_unref0 (iter);
	block11_data_unref (_data11_);
	_data11_ = NULL;
	return result;
}

static GeeLazy*
___lambda56__gee_unfold_func (gpointer self)
{
	GeeLazy* result;
	result = __lambda56_ (self);
	return result;
}

void
functions_tests_test_concat (FunctionsTests* self)
{
	Block10Data* _data10_;
	GeeIterator* iter_ = NULL;
	GeeIterator* _tmp0_;
	gint j = 0;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp1_;
	GeeIterator* _tmp2_;
	g_return_if_fail (self != NULL);
	_data10_ = g_slice_new0 (Block10Data);
	_data10_->_ref_count_ = 1;
	_data10_->self = g_object_ref (self);
	_data10_->i = 0;
	_tmp0_ = gee_iterator_unfold (GEE_TYPE_ITERATOR, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, ___lambda56__gee_unfold_func, block10_data_ref (_data10_), block10_data_unref, NULL);
	iter_ = _tmp0_;
	j = 0;
	_tmp1_ = iter_;
	_tmp2_ = gee_iterator_concat (G_TYPE_INT, NULL, NULL, _tmp1_);
	iter = _tmp2_;
	while (TRUE) {
		GeeIterator* _tmp3_;
		GeeIterator* _tmp4_;
		gpointer _tmp5_;
		GeeIterator* _tmp6_;
		gpointer _tmp7_;
		gint _tmp8_;
		_tmp3_ = iter;
		if (!gee_iterator_next (_tmp3_)) {
			break;
		}
		_tmp4_ = iter;
		_tmp5_ = gee_iterator_get (_tmp4_);
		_vala_assert (j == ((gint) ((gintptr) _tmp5_)), "j == iter.get ()");
		_tmp6_ = iter;
		_tmp7_ = gee_iterator_get (_tmp6_);
		_vala_assert (j == ((gint) ((gintptr) _tmp7_)), "j == iter.get ()");
		_tmp8_ = j;
		j = _tmp8_ + 1;
	}
	_vala_assert (_data10_->i == 3, "i == 3");
	_vala_assert (j == 9, "j == 9");
	_g_object_unref0 (iter);
	_g_object_unref0 (iter_);
	block10_data_unref (_data10_);
	_data10_ = NULL;
}

static inline gpointer
functions_tests_my_comparable_get_instance_private (FunctionsTestsMyComparable* self)
{
	return G_STRUCT_MEMBER_P (self, FunctionsTestsMyComparable_private_offset);
}

static FunctionsTestsMyComparable*
functions_tests_my_comparable_construct (GType object_type,
                                         gint i)
{
	FunctionsTestsMyComparable * self = NULL;
	self = (FunctionsTestsMyComparable*) g_object_new (object_type, NULL);
	self->priv->i = i;
	return self;
}

static FunctionsTestsMyComparable*
functions_tests_my_comparable_new (gint i)
{
	return functions_tests_my_comparable_construct (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, i);
}

static gint
functions_tests_my_comparable_real_compare_to (GeeComparable* base,
                                               FunctionsTestsMyComparable* cmp)
{
	FunctionsTestsMyComparable * self;
	gint result;
	self = (FunctionsTestsMyComparable*) base;
	g_return_val_if_fail (cmp != NULL, 0);
	if (self->priv->i == cmp->priv->i) {
		result = 0;
		return result;
	} else {
		if (self->priv->i >= cmp->priv->i) {
			result = 1;
			return result;
		} else {
			result = -1;
			return result;
		}
	}
}

static void
functions_tests_my_comparable_class_init (FunctionsTestsMyComparableClass * klass,
                                          gpointer klass_data)
{
	functions_tests_my_comparable_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FunctionsTestsMyComparable_private_offset);
	G_OBJECT_CLASS (klass)->finalize = functions_tests_my_comparable_finalize;
}

static void
functions_tests_my_comparable_gee_comparable_interface_init (GeeComparableIface * iface,
                                                             gpointer iface_data)
{
	functions_tests_my_comparable_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*) (GeeComparable*, gconstpointer)) functions_tests_my_comparable_real_compare_to;
}

static void
functions_tests_my_comparable_instance_init (FunctionsTestsMyComparable * self,
                                             gpointer klass)
{
	self->priv = functions_tests_my_comparable_get_instance_private (self);
}

static void
functions_tests_my_comparable_finalize (GObject * obj)
{
	FunctionsTestsMyComparable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparable);
	G_OBJECT_CLASS (functions_tests_my_comparable_parent_class)->finalize (obj);
}

static GType
functions_tests_my_comparable_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsMyComparableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_my_comparable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTestsMyComparable), 0, (GInstanceInitFunc) functions_tests_my_comparable_instance_init, NULL };
	static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) functions_tests_my_comparable_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType functions_tests_my_comparable_type_id;
	functions_tests_my_comparable_type_id = g_type_register_static (G_TYPE_OBJECT, "FunctionsTestsMyComparable", &g_define_type_info, 0);
	g_type_add_interface_static (functions_tests_my_comparable_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
	FunctionsTestsMyComparable_private_offset = g_type_add_instance_private (functions_tests_my_comparable_type_id, sizeof (FunctionsTestsMyComparablePrivate));
	return functions_tests_my_comparable_type_id;
}

static GType
functions_tests_my_comparable_get_type (void)
{
	static volatile gsize functions_tests_my_comparable_type_id__once = 0;
	if (g_once_init_enter (&functions_tests_my_comparable_type_id__once)) {
		GType functions_tests_my_comparable_type_id;
		functions_tests_my_comparable_type_id = functions_tests_my_comparable_get_type_once ();
		g_once_init_leave (&functions_tests_my_comparable_type_id__once, functions_tests_my_comparable_type_id);
	}
	return functions_tests_my_comparable_type_id__once;
}

static inline gpointer
functions_tests_my_hashable_get_instance_private (FunctionsTestsMyHashable* self)
{
	return G_STRUCT_MEMBER_P (self, FunctionsTestsMyHashable_private_offset);
}

static FunctionsTestsMyHashable*
functions_tests_my_hashable_construct (GType object_type,
                                       gint i)
{
	FunctionsTestsMyHashable * self = NULL;
	self = (FunctionsTestsMyHashable*) g_object_new (object_type, NULL);
	self->priv->i = i;
	return self;
}

static FunctionsTestsMyHashable*
functions_tests_my_hashable_new (gint i)
{
	return functions_tests_my_hashable_construct (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, i);
}

static gint
functions_tests_my_hashable_real_compare_to (GeeComparable* base,
                                             FunctionsTestsMyHashable* cmp)
{
	FunctionsTestsMyHashable * self;
	gint result;
	self = (FunctionsTestsMyHashable*) base;
	g_return_val_if_fail (cmp != NULL, 0);
	if (self->priv->i == cmp->priv->i) {
		result = 0;
		return result;
	} else {
		if (self->priv->i >= cmp->priv->i) {
			result = 1;
			return result;
		} else {
			result = -1;
			return result;
		}
	}
}

static guint
functions_tests_my_hashable_real_hash (GeeHashable* base)
{
	FunctionsTestsMyHashable * self;
	guint result;
	self = (FunctionsTestsMyHashable*) base;
	result = (guint) self->priv->i;
	return result;
}

static gboolean
functions_tests_my_hashable_real_equal_to (GeeHashable* base,
                                           FunctionsTestsMyHashable* hash)
{
	FunctionsTestsMyHashable * self;
	gboolean _tmp0_ = FALSE;
	gboolean result;
	self = (FunctionsTestsMyHashable*) base;
	g_return_val_if_fail (hash != NULL, FALSE);
	if (self->priv->i == hash->priv->i) {
		_tmp0_ = self->priv->i != -1;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}

static void
functions_tests_my_hashable_class_init (FunctionsTestsMyHashableClass * klass,
                                        gpointer klass_data)
{
	functions_tests_my_hashable_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FunctionsTestsMyHashable_private_offset);
	G_OBJECT_CLASS (klass)->finalize = functions_tests_my_hashable_finalize;
}

static void
functions_tests_my_hashable_gee_comparable_interface_init (GeeComparableIface * iface,
                                                           gpointer iface_data)
{
	functions_tests_my_hashable_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*) (GeeComparable*, gconstpointer)) functions_tests_my_hashable_real_compare_to;
}

static void
functions_tests_my_hashable_gee_hashable_interface_init (GeeHashableIface * iface,
                                                         gpointer iface_data)
{
	functions_tests_my_hashable_gee_hashable_parent_iface = g_type_interface_peek_parent (iface);
	iface->hash = (guint (*) (GeeHashable*)) functions_tests_my_hashable_real_hash;
	iface->equal_to = (gboolean (*) (GeeHashable*, gconstpointer)) functions_tests_my_hashable_real_equal_to;
}

static void
functions_tests_my_hashable_instance_init (FunctionsTestsMyHashable * self,
                                           gpointer klass)
{
	self->priv = functions_tests_my_hashable_get_instance_private (self);
}

static void
functions_tests_my_hashable_finalize (GObject * obj)
{
	FunctionsTestsMyHashable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashable);
	G_OBJECT_CLASS (functions_tests_my_hashable_parent_class)->finalize (obj);
}

static GType
functions_tests_my_hashable_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsMyHashableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_my_hashable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTestsMyHashable), 0, (GInstanceInitFunc) functions_tests_my_hashable_instance_init, NULL };
	static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) functions_tests_my_hashable_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	static const GInterfaceInfo gee_hashable_info = { (GInterfaceInitFunc) functions_tests_my_hashable_gee_hashable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType functions_tests_my_hashable_type_id;
	functions_tests_my_hashable_type_id = g_type_register_static (G_TYPE_OBJECT, "FunctionsTestsMyHashable", &g_define_type_info, 0);
	g_type_add_interface_static (functions_tests_my_hashable_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
	g_type_add_interface_static (functions_tests_my_hashable_type_id, GEE_TYPE_HASHABLE, &gee_hashable_info);
	FunctionsTestsMyHashable_private_offset = g_type_add_instance_private (functions_tests_my_hashable_type_id, sizeof (FunctionsTestsMyHashablePrivate));
	return functions_tests_my_hashable_type_id;
}

static GType
functions_tests_my_hashable_get_type (void)
{
	static volatile gsize functions_tests_my_hashable_type_id__once = 0;
	if (g_once_init_enter (&functions_tests_my_hashable_type_id__once)) {
		GType functions_tests_my_hashable_type_id;
		functions_tests_my_hashable_type_id = functions_tests_my_hashable_get_type_once ();
		g_once_init_leave (&functions_tests_my_hashable_type_id__once, functions_tests_my_hashable_type_id);
	}
	return functions_tests_my_hashable_type_id__once;
}

static void
functions_tests_class_init (FunctionsTestsClass * klass,
                            gpointer klass_data)
{
	functions_tests_parent_class = g_type_class_peek_parent (klass);
}

static void
functions_tests_instance_init (FunctionsTests * self,
                               gpointer klass)
{
}

static GType
functions_tests_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTests), 0, (GInstanceInitFunc) functions_tests_instance_init, NULL };
	GType functions_tests_type_id;
	functions_tests_type_id = g_type_register_static (GEE_TYPE_TEST_CASE, "FunctionsTests", &g_define_type_info, 0);
	return functions_tests_type_id;
}

GType
functions_tests_get_type (void)
{
	static volatile gsize functions_tests_type_id__once = 0;
	if (g_once_init_enter (&functions_tests_type_id__once)) {
		GType functions_tests_type_id;
		functions_tests_type_id = functions_tests_get_type_once ();
		g_once_init_leave (&functions_tests_type_id__once, functions_tests_type_id);
	}
	return functions_tests_type_id__once;
}

